(function () {
    function Model(defaults) {
        var model = {}, values = {}, listeners = {}, trackedProperties = {};
        function when(properties, callback, thisArg) {
            thisArg = thisArg || this;
            properties = properties instanceof Array ? properties : [properties];
            var listener = debounce(function () {
                var args = properties.map(function (property) {
                    return values[property];
                });
                if (allAreDefined(args)) {
                    callback.apply(thisArg, args);
                }
            });
            listener();
            properties.forEach(function (property) {
                on(property, listener);
            });
            return listener;
        }
        function debounce(callback) {
            var queued = false;
            return function () {
                if (!queued) {
                    queued = true;
                    setTimeout(function () {
                        queued = false;
                        callback();
                    }, 0);
                }
            };
        }
        function allAreDefined(arr) {
            return !arr.some(function (d) {
                return typeof d === 'undefined' || d === null;
            });
        }
        function on(property, callback, thisArg) {
            thisArg = thisArg || this;
            getListeners(property).push(callback);
            track(property, thisArg);
        }
        function getListeners(property) {
            return listeners[property] || (listeners[property] = []);
        }
        function track(property, thisArg) {
            if (!(property in trackedProperties)) {
                trackedProperties[property] = true;
                values[property] = model[property];
                Object.defineProperty(model, property, {
                    get: function () {
                        return values[property];
                    },
                    set: function (newValue) {
                        var oldValue = values[property];
                        values[property] = newValue;
                        getListeners(property).forEach(function (callback) {
                            callback.call(thisArg, newValue, oldValue);
                        });
                    }
                });
            }
        }
        function cancel(listener) {
            for (var property in listeners) {
                off(property, listener);
            }
        }
        function off(property, callback) {
            listeners[property] = listeners[property].filter(function (listener) {
                return listener !== callback;
            });
        }
        function set(newValues) {
            for (var property in newValues) {
                model[property] = newValues[property];
            }
        }
        set(defaults);
        model.when = when;
        model.cancel = cancel;
        model.on = on;
        model.off = off;
        model.set = set;
        return model;
    }
    Model.None = '__NONE__';
    if (typeof define === 'function' && define.amd) {
        define('model', [], function () {
            return Model;
        });
    } else if (typeof exports === 'object') {
        module.exports = Model;
    } else {
        this.Model = Model;
    }
}());
;
(function () {
    var undefined;
    var VERSION = '3.8.0';
    var BIND_FLAG = 1, BIND_KEY_FLAG = 2, CURRY_BOUND_FLAG = 4, CURRY_FLAG = 8, CURRY_RIGHT_FLAG = 16, PARTIAL_FLAG = 32, PARTIAL_RIGHT_FLAG = 64, ARY_FLAG = 128, REARG_FLAG = 256;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = '...';
    var HOT_COUNT = 150, HOT_SPAN = 16;
    var LAZY_DROP_WHILE_FLAG = 0, LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2;
    var FUNC_ERROR_TEXT = 'Expected a function';
    var PLACEHOLDER = '__lodash_placeholder__';
    var argsTag = '[object Arguments]', arrayTag = '[object Array]', boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', funcTag = '[object Function]', mapTag = '[object Map]', numberTag = '[object Number]', objectTag = '[object Object]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', weakMapTag = '[object WeakMap]';
    var arrayBufferTag = '[object ArrayBuffer]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39|#96);/g, reUnescapedHtml = /[&<>"'`]/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;
    var reRegExpChars = /[.*+?^${}()|[\]\/\\]/g, reHasRegExpChars = RegExp(reRegExpChars.source);
    var reComboMark = /[\u0300-\u036f\ufe20-\ufe23]/g;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reHasHexPrefix = /^0[xX]/;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reLatin1 = /[\xc0-\xd6\xd8-\xde\xdf-\xf6\xf8-\xff]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var reWords = function () {
        var upper = '[A-Z\\xc0-\\xd6\\xd8-\\xde]', lower = '[a-z\\xdf-\\xf6\\xf8-\\xff]+';
        return RegExp(upper + '+(?=' + upper + lower + ')|' + upper + '?' + lower + '|' + upper + '+|[0-9]+', 'g');
    }();
    var whitespace = ' \t\x0B\f\xA0\uFEFF' + '\n\r\u2028\u2029' + '\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000';
    var contextProps = [
        'Array',
        'ArrayBuffer',
        'Date',
        'Error',
        'Float32Array',
        'Float64Array',
        'Function',
        'Int8Array',
        'Int16Array',
        'Int32Array',
        'Math',
        'Number',
        'Object',
        'RegExp',
        'Set',
        'String',
        '_',
        'clearTimeout',
        'document',
        'isFinite',
        'parseInt',
        'setTimeout',
        'TypeError',
        'Uint8Array',
        'Uint8ClampedArray',
        'Uint16Array',
        'Uint32Array',
        'WeakMap',
        'window'
    ];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[stringTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[mapTag] = cloneableTags[setTag] = cloneableTags[weakMapTag] = false;
    var debounceOptions = {
        'leading': false,
        'maxWait': 0,
        'trailing': false
    };
    var deburredLetters = {
        '\xC0': 'A',
        '\xC1': 'A',
        '\xC2': 'A',
        '\xC3': 'A',
        '\xC4': 'A',
        '\xC5': 'A',
        '\xE0': 'a',
        '\xE1': 'a',
        '\xE2': 'a',
        '\xE3': 'a',
        '\xE4': 'a',
        '\xE5': 'a',
        '\xC7': 'C',
        '\xE7': 'c',
        '\xD0': 'D',
        '\xF0': 'd',
        '\xC8': 'E',
        '\xC9': 'E',
        '\xCA': 'E',
        '\xCB': 'E',
        '\xE8': 'e',
        '\xE9': 'e',
        '\xEA': 'e',
        '\xEB': 'e',
        '\xCC': 'I',
        '\xCD': 'I',
        '\xCE': 'I',
        '\xCF': 'I',
        '\xEC': 'i',
        '\xED': 'i',
        '\xEE': 'i',
        '\xEF': 'i',
        '\xD1': 'N',
        '\xF1': 'n',
        '\xD2': 'O',
        '\xD3': 'O',
        '\xD4': 'O',
        '\xD5': 'O',
        '\xD6': 'O',
        '\xD8': 'O',
        '\xF2': 'o',
        '\xF3': 'o',
        '\xF4': 'o',
        '\xF5': 'o',
        '\xF6': 'o',
        '\xF8': 'o',
        '\xD9': 'U',
        '\xDA': 'U',
        '\xDB': 'U',
        '\xDC': 'U',
        '\xF9': 'u',
        '\xFA': 'u',
        '\xFB': 'u',
        '\xFC': 'u',
        '\xDD': 'Y',
        '\xFD': 'y',
        '\xFF': 'y',
        '\xC6': 'Ae',
        '\xE6': 'ae',
        '\xDE': 'Th',
        '\xFE': 'th',
        '\xDF': 'ss'
    };
    var htmlEscapes = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        '\'': '&#39;',
        '`': '&#96;'
    };
    var htmlUnescapes = {
        '&amp;': '&',
        '&lt;': '<',
        '&gt;': '>',
        '&quot;': '"',
        '&#39;': '\'',
        '&#96;': '`'
    };
    var objectTypes = {
        'function': true,
        'object': true
    };
    var stringEscapes = {
        '\\': '\\',
        '\'': '\'',
        '\n': 'n',
        '\r': 'r',
        '\u2028': 'u2028',
        '\u2029': 'u2029'
    };
    var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
    var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
    var freeGlobal = freeExports && freeModule && typeof global == 'object' && global && global.Object && global;
    var freeSelf = objectTypes[typeof self] && self && self.Object && self;
    var freeWindow = objectTypes[typeof window] && window && window.Object && window;
    var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
    var root = freeGlobal || freeWindow !== (this && this.window) && freeWindow || freeSelf || this;
    function baseCompareAscending(value, other) {
        if (value !== other) {
            var valIsReflexive = value === value, othIsReflexive = other === other;
            if (value > other || !valIsReflexive || value === undefined && othIsReflexive) {
                return 1;
            }
            if (value < other || !othIsReflexive || other === undefined && valIsReflexive) {
                return -1;
            }
        }
        return 0;
    }
    function baseFindIndex(array, predicate, fromRight) {
        var length = array.length, index = fromRight ? length : -1;
        while (fromRight ? index-- : ++index < length) {
            if (predicate(array[index], index, array)) {
                return index;
            }
        }
        return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
        if (value !== value) {
            return indexOfNaN(array, fromIndex);
        }
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
            if (array[index] === value) {
                return index;
            }
        }
        return -1;
    }
    function baseIsFunction(value) {
        return typeof value == 'function' || false;
    }
    function baseToString(value) {
        if (typeof value == 'string') {
            return value;
        }
        return value == null ? '' : value + '';
    }
    function charAtCallback(string) {
        return string.charCodeAt(0);
    }
    function charsLeftIndex(string, chars) {
        var index = -1, length = string.length;
        while (++index < length && chars.indexOf(string.charAt(index)) > -1) {
        }
        return index;
    }
    function charsRightIndex(string, chars) {
        var index = string.length;
        while (index-- && chars.indexOf(string.charAt(index)) > -1) {
        }
        return index;
    }
    function compareAscending(object, other) {
        return baseCompareAscending(object.criteria, other.criteria) || object.index - other.index;
    }
    function compareMultiple(object, other, orders) {
        var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index < length) {
            var result = baseCompareAscending(objCriteria[index], othCriteria[index]);
            if (result) {
                if (index >= ordersLength) {
                    return result;
                }
                return result * (orders[index] ? 1 : -1);
            }
        }
        return object.index - other.index;
    }
    function deburrLetter(letter) {
        return deburredLetters[letter];
    }
    function escapeHtmlChar(chr) {
        return htmlEscapes[chr];
    }
    function escapeStringChar(chr) {
        return '\\' + stringEscapes[chr];
    }
    function indexOfNaN(array, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 0 : -1);
        while (fromRight ? index-- : ++index < length) {
            var other = array[index];
            if (other !== other) {
                return index;
            }
        }
        return -1;
    }
    function isObjectLike(value) {
        return !!value && typeof value == 'object';
    }
    function isSpace(charCode) {
        return charCode <= 160 && (charCode >= 9 && charCode <= 13) || charCode == 32 || charCode == 160 || charCode == 5760 || charCode == 6158 || charCode >= 8192 && (charCode <= 8202 || charCode == 8232 || charCode == 8233 || charCode == 8239 || charCode == 8287 || charCode == 12288 || charCode == 65279);
    }
    function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = -1, result = [];
        while (++index < length) {
            if (array[index] === placeholder) {
                array[index] = PLACEHOLDER;
                result[++resIndex] = index;
            }
        }
        return result;
    }
    function sortedUniq(array, iteratee) {
        var seen, index = -1, length = array.length, resIndex = -1, result = [];
        while (++index < length) {
            var value = array[index], computed = iteratee ? iteratee(value, index, array) : value;
            if (!index || seen !== computed) {
                seen = computed;
                result[++resIndex] = value;
            }
        }
        return result;
    }
    function trimmedLeftIndex(string) {
        var index = -1, length = string.length;
        while (++index < length && isSpace(string.charCodeAt(index))) {
        }
        return index;
    }
    function trimmedRightIndex(string) {
        var index = string.length;
        while (index-- && isSpace(string.charCodeAt(index))) {
        }
        return index;
    }
    function unescapeHtmlChar(chr) {
        return htmlUnescapes[chr];
    }
    function runInContext(context) {
        context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
        var Array = context.Array, Date = context.Date, Error = context.Error, Function = context.Function, Math = context.Math, Number = context.Number, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError;
        var arrayProto = Array.prototype, objectProto = Object.prototype, stringProto = String.prototype;
        var document = (document = context.window) && document.document;
        var fnToString = Function.prototype.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var objToString = objectProto.toString;
        var oldDash = context._;
        var reIsNative = RegExp('^' + escapeRegExp(objToString).replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
        var ArrayBuffer = isNative(ArrayBuffer = context.ArrayBuffer) && ArrayBuffer, bufferSlice = isNative(bufferSlice = ArrayBuffer && new ArrayBuffer(0).slice) && bufferSlice, ceil = Math.ceil, clearTimeout = context.clearTimeout, floor = Math.floor, getOwnPropertySymbols = isNative(getOwnPropertySymbols = Object.getOwnPropertySymbols) && getOwnPropertySymbols, getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf, push = arrayProto.push, preventExtensions = isNative(preventExtensions = Object.preventExtensions) && preventExtensions, propertyIsEnumerable = objectProto.propertyIsEnumerable, Set = isNative(Set = context.Set) && Set, setTimeout = context.setTimeout, splice = arrayProto.splice, Uint8Array = isNative(Uint8Array = context.Uint8Array) && Uint8Array, WeakMap = isNative(WeakMap = context.WeakMap) && WeakMap;
        var Float64Array = function () {
            try {
                var func = isNative(func = context.Float64Array) && func, result = new func(new ArrayBuffer(10), 0, 1) && func;
            } catch (e) {
            }
            return result;
        }();
        var nativeAssign = function () {
            var func = preventExtensions && isNative(func = Object.assign) && func;
            try {
                if (func) {
                    var object = preventExtensions({ '1': 0 });
                    object[0] = 1;
                }
            } catch (e) {
                try {
                    func(object, 'xo');
                } catch (e) {
                }
                return !object[1] && func;
            }
            return false;
        }();
        var nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray, nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate, nativeIsFinite = context.isFinite, nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys, nativeMax = Math.max, nativeMin = Math.min, nativeNow = isNative(nativeNow = Date.now) && nativeNow, nativeNumIsFinite = isNative(nativeNumIsFinite = Number.isFinite) && nativeNumIsFinite, nativeParseInt = context.parseInt, nativeRandom = Math.random;
        var NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY, POSITIVE_INFINITY = Number.POSITIVE_INFINITY;
        var MAX_ARRAY_LENGTH = Math.pow(2, 32) - 1, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        var FLOAT64_BYTES_PER_ELEMENT = Float64Array ? Float64Array.BYTES_PER_ELEMENT : 0;
        var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;
        var metaMap = WeakMap && new WeakMap();
        var realNames = {};
        function lodash(value) {
            if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
                if (value instanceof LodashWrapper) {
                    return value;
                }
                if (hasOwnProperty.call(value, '__chain__') && hasOwnProperty.call(value, '__wrapped__')) {
                    return wrapperClone(value);
                }
            }
            return new LodashWrapper(value);
        }
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll, actions) {
            this.__wrapped__ = value;
            this.__actions__ = actions || [];
            this.__chain__ = !!chainAll;
        }
        var support = lodash.support = {};
        (function (x) {
            var Ctor = function () {
                    this.x = x;
                }, args = arguments, object = {
                    '0': x,
                    'length': x
                }, props = [];
            Ctor.prototype = {
                'valueOf': x,
                'y': x
            };
            for (var key in new Ctor()) {
                props.push(key);
            }
            support.funcDecomp = /\bthis\b/.test(function () {
                return this;
            });
            support.funcNames = typeof Function.name == 'string';
            try {
                support.dom = document.createDocumentFragment().nodeType === 11;
            } catch (e) {
                support.dom = false;
            }
            try {
                support.nonEnumArgs = !propertyIsEnumerable.call(args, 1);
            } catch (e) {
                support.nonEnumArgs = true;
            }
        }(1, 0));
        lodash.templateSettings = {
            'escape': reEscape,
            'evaluate': reEvaluate,
            'interpolate': reInterpolate,
            'variable': '',
            'imports': { '_': lodash }
        };
        function LazyWrapper(value) {
            this.__wrapped__ = value;
            this.__actions__ = null;
            this.__dir__ = 1;
            this.__dropCount__ = 0;
            this.__filtered__ = false;
            this.__iteratees__ = null;
            this.__takeCount__ = POSITIVE_INFINITY;
            this.__views__ = null;
        }
        function lazyClone() {
            var actions = this.__actions__, iteratees = this.__iteratees__, views = this.__views__, result = new LazyWrapper(this.__wrapped__);
            result.__actions__ = actions ? arrayCopy(actions) : null;
            result.__dir__ = this.__dir__;
            result.__filtered__ = this.__filtered__;
            result.__iteratees__ = iteratees ? arrayCopy(iteratees) : null;
            result.__takeCount__ = this.__takeCount__;
            result.__views__ = views ? arrayCopy(views) : null;
            return result;
        }
        function lazyReverse() {
            if (this.__filtered__) {
                var result = new LazyWrapper(this);
                result.__dir__ = -1;
                result.__filtered__ = true;
            } else {
                result = this.clone();
                result.__dir__ *= -1;
            }
            return result;
        }
        function lazyValue() {
            var array = this.__wrapped__.value();
            if (!isArray(array)) {
                return baseWrapperValue(array, this.__actions__);
            }
            var dir = this.__dir__, isRight = dir < 0, view = getView(0, array.length, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, takeCount = nativeMin(length, this.__takeCount__), iteratees = this.__iteratees__, iterLength = iteratees ? iteratees.length : 0, resIndex = 0, result = [];
            outer:
                while (length-- && resIndex < takeCount) {
                    index += dir;
                    var iterIndex = -1, value = array[index];
                    while (++iterIndex < iterLength) {
                        var data = iteratees[iterIndex], iteratee = data.iteratee, type = data.type;
                        if (type == LAZY_DROP_WHILE_FLAG) {
                            if (data.done && (isRight ? index > data.index : index < data.index)) {
                                data.count = 0;
                                data.done = false;
                            }
                            data.index = index;
                            if (!data.done) {
                                var limit = data.limit;
                                if (!(data.done = limit > -1 ? data.count++ >= limit : !iteratee(value))) {
                                    continue outer;
                                }
                            }
                        } else {
                            var computed = iteratee(value);
                            if (type == LAZY_MAP_FLAG) {
                                value = computed;
                            } else if (!computed) {
                                if (type == LAZY_FILTER_FLAG) {
                                    continue outer;
                                } else {
                                    break outer;
                                }
                            }
                        }
                    }
                    result[resIndex++] = value;
                }
            return result;
        }
        function MapCache() {
            this.__data__ = {};
        }
        function mapDelete(key) {
            return this.has(key) && delete this.__data__[key];
        }
        function mapGet(key) {
            return key == '__proto__' ? undefined : this.__data__[key];
        }
        function mapHas(key) {
            return key != '__proto__' && hasOwnProperty.call(this.__data__, key);
        }
        function mapSet(key, value) {
            if (key != '__proto__') {
                this.__data__[key] = value;
            }
            return this;
        }
        function SetCache(values) {
            var length = values ? values.length : 0;
            this.data = {
                'hash': nativeCreate(null),
                'set': new Set()
            };
            while (length--) {
                this.push(values[length]);
            }
        }
        function cacheIndexOf(cache, value) {
            var data = cache.data, result = typeof value == 'string' || isObject(value) ? data.set.has(value) : data.hash[value];
            return result ? 0 : -1;
        }
        function cachePush(value) {
            var data = this.data;
            if (typeof value == 'string' || isObject(value)) {
                data.set.add(value);
            } else {
                data.hash[value] = true;
            }
        }
        function arrayCopy(source, array) {
            var index = -1, length = source.length;
            array || (array = Array(length));
            while (++index < length) {
                array[index] = source[index];
            }
            return array;
        }
        function arrayEach(array, iteratee) {
            var index = -1, length = array.length;
            while (++index < length) {
                if (iteratee(array[index], index, array) === false) {
                    break;
                }
            }
            return array;
        }
        function arrayEachRight(array, iteratee) {
            var length = array.length;
            while (length--) {
                if (iteratee(array[length], length, array) === false) {
                    break;
                }
            }
            return array;
        }
        function arrayEvery(array, predicate) {
            var index = -1, length = array.length;
            while (++index < length) {
                if (!predicate(array[index], index, array)) {
                    return false;
                }
            }
            return true;
        }
        function arrayFilter(array, predicate) {
            var index = -1, length = array.length, resIndex = -1, result = [];
            while (++index < length) {
                var value = array[index];
                if (predicate(value, index, array)) {
                    result[++resIndex] = value;
                }
            }
            return result;
        }
        function arrayMap(array, iteratee) {
            var index = -1, length = array.length, result = Array(length);
            while (++index < length) {
                result[index] = iteratee(array[index], index, array);
            }
            return result;
        }
        function arrayMax(array) {
            var index = -1, length = array.length, result = NEGATIVE_INFINITY;
            while (++index < length) {
                var value = array[index];
                if (value > result) {
                    result = value;
                }
            }
            return result;
        }
        function arrayMin(array) {
            var index = -1, length = array.length, result = POSITIVE_INFINITY;
            while (++index < length) {
                var value = array[index];
                if (value < result) {
                    result = value;
                }
            }
            return result;
        }
        function arrayReduce(array, iteratee, accumulator, initFromArray) {
            var index = -1, length = array.length;
            if (initFromArray && length) {
                accumulator = array[++index];
            }
            while (++index < length) {
                accumulator = iteratee(accumulator, array[index], index, array);
            }
            return accumulator;
        }
        function arrayReduceRight(array, iteratee, accumulator, initFromArray) {
            var length = array.length;
            if (initFromArray && length) {
                accumulator = array[--length];
            }
            while (length--) {
                accumulator = iteratee(accumulator, array[length], length, array);
            }
            return accumulator;
        }
        function arraySome(array, predicate) {
            var index = -1, length = array.length;
            while (++index < length) {
                if (predicate(array[index], index, array)) {
                    return true;
                }
            }
            return false;
        }
        function arraySum(array) {
            var length = array.length, result = 0;
            while (length--) {
                result += +array[length] || 0;
            }
            return result;
        }
        function assignDefaults(objectValue, sourceValue) {
            return objectValue === undefined ? sourceValue : objectValue;
        }
        function assignOwnDefaults(objectValue, sourceValue, key, object) {
            return objectValue === undefined || !hasOwnProperty.call(object, key) ? sourceValue : objectValue;
        }
        function assignWith(object, source, customizer) {
            var props = keys(source);
            push.apply(props, getSymbols(source));
            var index = -1, length = props.length;
            while (++index < length) {
                var key = props[index], value = object[key], result = customizer(value, source[key], key, object, source);
                if ((result === result ? result !== value : value === value) || value === undefined && !(key in object)) {
                    object[key] = result;
                }
            }
            return object;
        }
        var baseAssign = nativeAssign || function (object, source) {
            return source == null ? object : baseCopy(source, getSymbols(source), baseCopy(source, keys(source), object));
        };
        function baseAt(collection, props) {
            var index = -1, isNil = collection == null, isArr = !isNil && isArrayLike(collection), length = isArr && collection.length, propsLength = props.length, result = Array(propsLength);
            while (++index < propsLength) {
                var key = props[index];
                if (isArr) {
                    result[index] = isIndex(key, length) ? collection[key] : undefined;
                } else {
                    result[index] = isNil ? undefined : collection[key];
                }
            }
            return result;
        }
        function baseCopy(source, props, object) {
            object || (object = {});
            var index = -1, length = props.length;
            while (++index < length) {
                var key = props[index];
                object[key] = source[key];
            }
            return object;
        }
        function baseCallback(func, thisArg, argCount) {
            var type = typeof func;
            if (type == 'function') {
                return thisArg === undefined ? func : bindCallback(func, thisArg, argCount);
            }
            if (func == null) {
                return identity;
            }
            if (type == 'object') {
                return baseMatches(func);
            }
            return thisArg === undefined ? property(func) : baseMatchesProperty(func, thisArg);
        }
        function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
            var result;
            if (customizer) {
                result = object ? customizer(value, key, object) : customizer(value);
            }
            if (result !== undefined) {
                return result;
            }
            if (!isObject(value)) {
                return value;
            }
            var isArr = isArray(value);
            if (isArr) {
                result = initCloneArray(value);
                if (!isDeep) {
                    return arrayCopy(value, result);
                }
            } else {
                var tag = objToString.call(value), isFunc = tag == funcTag;
                if (tag == objectTag || tag == argsTag || isFunc && !object) {
                    result = initCloneObject(isFunc ? {} : value);
                    if (!isDeep) {
                        return baseAssign(result, value);
                    }
                } else {
                    return cloneableTags[tag] ? initCloneByTag(value, tag, isDeep) : object ? value : {};
                }
            }
            stackA || (stackA = []);
            stackB || (stackB = []);
            var length = stackA.length;
            while (length--) {
                if (stackA[length] == value) {
                    return stackB[length];
                }
            }
            stackA.push(value);
            stackB.push(result);
            (isArr ? arrayEach : baseForOwn)(value, function (subValue, key) {
                result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
            });
            return result;
        }
        var baseCreate = function () {
            function Object() {
            }
            return function (prototype) {
                if (isObject(prototype)) {
                    Object.prototype = prototype;
                    var result = new Object();
                    Object.prototype = null;
                }
                return result || context.Object();
            };
        }();
        function baseDelay(func, wait, args) {
            if (typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            return setTimeout(function () {
                func.apply(undefined, args);
            }, wait);
        }
        function baseDifference(array, values) {
            var length = array ? array.length : 0, result = [];
            if (!length) {
                return result;
            }
            var index = -1, indexOf = getIndexOf(), isCommon = indexOf == baseIndexOf, cache = isCommon && values.length >= 200 ? createCache(values) : null, valuesLength = values.length;
            if (cache) {
                indexOf = cacheIndexOf;
                isCommon = false;
                values = cache;
            }
            outer:
                while (++index < length) {
                    var value = array[index];
                    if (isCommon && value === value) {
                        var valuesIndex = valuesLength;
                        while (valuesIndex--) {
                            if (values[valuesIndex] === value) {
                                continue outer;
                            }
                        }
                        result.push(value);
                    } else if (indexOf(values, value, 0) < 0) {
                        result.push(value);
                    }
                }
            return result;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
            var result = true;
            baseEach(collection, function (value, index, collection) {
                result = !!predicate(value, index, collection);
                return result;
            });
            return result;
        }
        function baseFill(array, value, start, end) {
            var length = array.length;
            start = start == null ? 0 : +start || 0;
            if (start < 0) {
                start = -start > length ? 0 : length + start;
            }
            end = end === undefined || end > length ? length : +end || 0;
            if (end < 0) {
                end += length;
            }
            length = start > end ? 0 : end >>> 0;
            start >>>= 0;
            while (start < length) {
                array[start++] = value;
            }
            return array;
        }
        function baseFilter(collection, predicate) {
            var result = [];
            baseEach(collection, function (value, index, collection) {
                if (predicate(value, index, collection)) {
                    result.push(value);
                }
            });
            return result;
        }
        function baseFind(collection, predicate, eachFunc, retKey) {
            var result;
            eachFunc(collection, function (value, key, collection) {
                if (predicate(value, key, collection)) {
                    result = retKey ? key : value;
                    return false;
                }
            });
            return result;
        }
        function baseFlatten(array, isDeep, isStrict) {
            var index = -1, length = array.length, resIndex = -1, result = [];
            while (++index < length) {
                var value = array[index];
                if (isObjectLike(value) && isArrayLike(value) && (isStrict || isArray(value) || isArguments(value))) {
                    if (isDeep) {
                        value = baseFlatten(value, isDeep, isStrict);
                    }
                    var valIndex = -1, valLength = value.length;
                    while (++valIndex < valLength) {
                        result[++resIndex] = value[valIndex];
                    }
                } else if (!isStrict) {
                    result[++resIndex] = value;
                }
            }
            return result;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForIn(object, iteratee) {
            return baseFor(object, iteratee, keysIn);
        }
        function baseForOwn(object, iteratee) {
            return baseFor(object, iteratee, keys);
        }
        function baseForOwnRight(object, iteratee) {
            return baseForRight(object, iteratee, keys);
        }
        function baseFunctions(object, props) {
            var index = -1, length = props.length, resIndex = -1, result = [];
            while (++index < length) {
                var key = props[index];
                if (isFunction(object[key])) {
                    result[++resIndex] = key;
                }
            }
            return result;
        }
        function baseGet(object, path, pathKey) {
            if (object == null) {
                return;
            }
            if (pathKey !== undefined && pathKey in toObject(object)) {
                path = [pathKey];
            }
            var index = -1, length = path.length;
            while (object != null && ++index < length) {
                object = object[path[index]];
            }
            return index && index == length ? object : undefined;
        }
        function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
            if (value === other) {
                return true;
            }
            var valType = typeof value, othType = typeof other;
            if (valType != 'function' && valType != 'object' && othType != 'function' && othType != 'object' || value == null || other == null) {
                return value !== value && other !== other;
            }
            return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
        }
        function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
            var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
            if (!objIsArr) {
                objTag = objToString.call(object);
                if (objTag == argsTag) {
                    objTag = objectTag;
                } else if (objTag != objectTag) {
                    objIsArr = isTypedArray(object);
                }
            }
            if (!othIsArr) {
                othTag = objToString.call(other);
                if (othTag == argsTag) {
                    othTag = objectTag;
                } else if (othTag != objectTag) {
                    othIsArr = isTypedArray(other);
                }
            }
            var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
            if (isSameTag && !(objIsArr || objIsObj)) {
                return equalByTag(object, other, objTag);
            }
            if (!isLoose) {
                var valWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'), othWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
                if (valWrapped || othWrapped) {
                    return equalFunc(valWrapped ? object.value() : object, othWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
                }
            }
            if (!isSameTag) {
                return false;
            }
            stackA || (stackA = []);
            stackB || (stackB = []);
            var length = stackA.length;
            while (length--) {
                if (stackA[length] == object) {
                    return stackB[length] == other;
                }
            }
            stackA.push(object);
            stackB.push(other);
            var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);
            stackA.pop();
            stackB.pop();
            return result;
        }
        function baseIsMatch(object, props, values, strictCompareFlags, customizer) {
            var index = -1, length = props.length, noCustomizer = !customizer;
            while (++index < length) {
                if (noCustomizer && strictCompareFlags[index] ? values[index] !== object[props[index]] : !(props[index] in object)) {
                    return false;
                }
            }
            index = -1;
            while (++index < length) {
                var key = props[index], objValue = object[key], srcValue = values[index];
                if (noCustomizer && strictCompareFlags[index]) {
                    var result = objValue !== undefined || key in object;
                } else {
                    result = customizer ? customizer(objValue, srcValue, key) : undefined;
                    if (result === undefined) {
                        result = baseIsEqual(srcValue, objValue, customizer, true);
                    }
                }
                if (!result) {
                    return false;
                }
            }
            return true;
        }
        function baseMap(collection, iteratee) {
            var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
            baseEach(collection, function (value, key, collection) {
                result[++index] = iteratee(value, key, collection);
            });
            return result;
        }
        function baseMatches(source) {
            var props = keys(source), length = props.length;
            if (!length) {
                return constant(true);
            }
            if (length == 1) {
                var key = props[0], value = source[key];
                if (isStrictComparable(value)) {
                    return function (object) {
                        if (object == null) {
                            return false;
                        }
                        return object[key] === value && (value !== undefined || key in toObject(object));
                    };
                }
            }
            var values = Array(length), strictCompareFlags = Array(length);
            while (length--) {
                value = source[props[length]];
                values[length] = value;
                strictCompareFlags[length] = isStrictComparable(value);
            }
            return function (object) {
                return object != null && baseIsMatch(toObject(object), props, values, strictCompareFlags);
            };
        }
        function baseMatchesProperty(path, value) {
            var isArr = isArray(path), isCommon = isKey(path) && isStrictComparable(value), pathKey = path + '';
            path = toPath(path);
            return function (object) {
                if (object == null) {
                    return false;
                }
                var key = pathKey;
                object = toObject(object);
                if ((isArr || !isCommon) && !(key in object)) {
                    object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
                    if (object == null) {
                        return false;
                    }
                    key = last(path);
                    object = toObject(object);
                }
                return object[key] === value ? value !== undefined || key in object : baseIsEqual(value, object[key], null, true);
            };
        }
        function baseMerge(object, source, customizer, stackA, stackB) {
            if (!isObject(object)) {
                return object;
            }
            var isSrcArr = isArrayLike(source) && (isArray(source) || isTypedArray(source));
            if (!isSrcArr) {
                var props = keys(source);
                push.apply(props, getSymbols(source));
            }
            arrayEach(props || source, function (srcValue, key) {
                if (props) {
                    key = srcValue;
                    srcValue = source[key];
                }
                if (isObjectLike(srcValue)) {
                    stackA || (stackA = []);
                    stackB || (stackB = []);
                    baseMergeDeep(object, source, key, baseMerge, customizer, stackA, stackB);
                } else {
                    var value = object[key], result = customizer ? customizer(value, srcValue, key, object, source) : undefined, isCommon = result === undefined;
                    if (isCommon) {
                        result = srcValue;
                    }
                    if ((isSrcArr || result !== undefined) && (isCommon || (result === result ? result !== value : value === value))) {
                        object[key] = result;
                    }
                }
            });
            return object;
        }
        function baseMergeDeep(object, source, key, mergeFunc, customizer, stackA, stackB) {
            var length = stackA.length, srcValue = source[key];
            while (length--) {
                if (stackA[length] == srcValue) {
                    object[key] = stackB[length];
                    return;
                }
            }
            var value = object[key], result = customizer ? customizer(value, srcValue, key, object, source) : undefined, isCommon = result === undefined;
            if (isCommon) {
                result = srcValue;
                if (isArrayLike(srcValue) && (isArray(srcValue) || isTypedArray(srcValue))) {
                    result = isArray(value) ? value : isArrayLike(value) ? arrayCopy(value) : [];
                } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                    result = isArguments(value) ? toPlainObject(value) : isPlainObject(value) ? value : {};
                } else {
                    isCommon = false;
                }
            }
            stackA.push(srcValue);
            stackB.push(result);
            if (isCommon) {
                object[key] = mergeFunc(result, srcValue, customizer, stackA, stackB);
            } else if (result === result ? result !== value : value === value) {
                object[key] = result;
            }
        }
        function baseProperty(key) {
            return function (object) {
                return object == null ? undefined : object[key];
            };
        }
        function basePropertyDeep(path) {
            var pathKey = path + '';
            path = toPath(path);
            return function (object) {
                return baseGet(object, path, pathKey);
            };
        }
        function basePullAt(array, indexes) {
            var length = array ? indexes.length : 0;
            while (length--) {
                var index = parseFloat(indexes[length]);
                if (index != previous && isIndex(index)) {
                    var previous = index;
                    splice.call(array, index, 1);
                }
            }
            return array;
        }
        function baseRandom(min, max) {
            return min + floor(nativeRandom() * (max - min + 1));
        }
        function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
            eachFunc(collection, function (value, index, collection) {
                accumulator = initFromCollection ? (initFromCollection = false, value) : iteratee(accumulator, value, index, collection);
            });
            return accumulator;
        }
        var baseSetData = !metaMap ? identity : function (func, data) {
            metaMap.set(func, data);
            return func;
        };
        function baseSlice(array, start, end) {
            var index = -1, length = array.length;
            start = start == null ? 0 : +start || 0;
            if (start < 0) {
                start = -start > length ? 0 : length + start;
            }
            end = end === undefined || end > length ? length : +end || 0;
            if (end < 0) {
                end += length;
            }
            length = start > end ? 0 : end - start >>> 0;
            start >>>= 0;
            var result = Array(length);
            while (++index < length) {
                result[index] = array[index + start];
            }
            return result;
        }
        function baseSome(collection, predicate) {
            var result;
            baseEach(collection, function (value, index, collection) {
                result = predicate(value, index, collection);
                return !result;
            });
            return !!result;
        }
        function baseSortBy(array, comparer) {
            var length = array.length;
            array.sort(comparer);
            while (length--) {
                array[length] = array[length].value;
            }
            return array;
        }
        function baseSortByOrder(collection, iteratees, orders) {
            var callback = getCallback(), index = -1;
            iteratees = arrayMap(iteratees, function (iteratee) {
                return callback(iteratee);
            });
            var result = baseMap(collection, function (value) {
                var criteria = arrayMap(iteratees, function (iteratee) {
                    return iteratee(value);
                });
                return {
                    'criteria': criteria,
                    'index': ++index,
                    'value': value
                };
            });
            return baseSortBy(result, function (object, other) {
                return compareMultiple(object, other, orders);
            });
        }
        function baseSum(collection, iteratee) {
            var result = 0;
            baseEach(collection, function (value, index, collection) {
                result += +iteratee(value, index, collection) || 0;
            });
            return result;
        }
        function baseUniq(array, iteratee) {
            var index = -1, indexOf = getIndexOf(), length = array.length, isCommon = indexOf == baseIndexOf, isLarge = isCommon && length >= 200, seen = isLarge ? createCache() : null, result = [];
            if (seen) {
                indexOf = cacheIndexOf;
                isCommon = false;
            } else {
                isLarge = false;
                seen = iteratee ? [] : result;
            }
            outer:
                while (++index < length) {
                    var value = array[index], computed = iteratee ? iteratee(value, index, array) : value;
                    if (isCommon && value === value) {
                        var seenIndex = seen.length;
                        while (seenIndex--) {
                            if (seen[seenIndex] === computed) {
                                continue outer;
                            }
                        }
                        if (iteratee) {
                            seen.push(computed);
                        }
                        result.push(value);
                    } else if (indexOf(seen, computed, 0) < 0) {
                        if (iteratee || isLarge) {
                            seen.push(computed);
                        }
                        result.push(value);
                    }
                }
            return result;
        }
        function baseValues(object, props) {
            var index = -1, length = props.length, result = Array(length);
            while (++index < length) {
                result[index] = object[props[index]];
            }
            return result;
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
            var length = array.length, index = fromRight ? length : -1;
            while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
            }
            return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
            var result = value;
            if (result instanceof LazyWrapper) {
                result = result.value();
            }
            var index = -1, length = actions.length;
            while (++index < length) {
                var args = [result], action = actions[index];
                push.apply(args, action.args);
                result = action.func.apply(action.thisArg, args);
            }
            return result;
        }
        function binaryIndex(array, value, retHighest) {
            var low = 0, high = array ? array.length : low;
            if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
                while (low < high) {
                    var mid = low + high >>> 1, computed = array[mid];
                    if (retHighest ? computed <= value : computed < value) {
                        low = mid + 1;
                    } else {
                        high = mid;
                    }
                }
                return high;
            }
            return binaryIndexBy(array, value, identity, retHighest);
        }
        function binaryIndexBy(array, value, iteratee, retHighest) {
            value = iteratee(value);
            var low = 0, high = array ? array.length : 0, valIsNaN = value !== value, valIsUndef = value === undefined;
            while (low < high) {
                var mid = floor((low + high) / 2), computed = iteratee(array[mid]), isReflexive = computed === computed;
                if (valIsNaN) {
                    var setLow = isReflexive || retHighest;
                } else if (valIsUndef) {
                    setLow = isReflexive && (retHighest || computed !== undefined);
                } else {
                    setLow = retHighest ? computed <= value : computed < value;
                }
                if (setLow) {
                    low = mid + 1;
                } else {
                    high = mid;
                }
            }
            return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function bindCallback(func, thisArg, argCount) {
            if (typeof func != 'function') {
                return identity;
            }
            if (thisArg === undefined) {
                return func;
            }
            switch (argCount) {
            case 1:
                return function (value) {
                    return func.call(thisArg, value);
                };
            case 3:
                return function (value, index, collection) {
                    return func.call(thisArg, value, index, collection);
                };
            case 4:
                return function (accumulator, value, index, collection) {
                    return func.call(thisArg, accumulator, value, index, collection);
                };
            case 5:
                return function (value, other, key, object, source) {
                    return func.call(thisArg, value, other, key, object, source);
                };
            }
            return function () {
                return func.apply(thisArg, arguments);
            };
        }
        function bufferClone(buffer) {
            return bufferSlice.call(buffer, 0);
        }
        if (!bufferSlice) {
            bufferClone = !(ArrayBuffer && Uint8Array) ? constant(null) : function (buffer) {
                var byteLength = buffer.byteLength, floatLength = Float64Array ? floor(byteLength / FLOAT64_BYTES_PER_ELEMENT) : 0, offset = floatLength * FLOAT64_BYTES_PER_ELEMENT, result = new ArrayBuffer(byteLength);
                if (floatLength) {
                    var view = new Float64Array(result, 0, floatLength);
                    view.set(new Float64Array(buffer, 0, floatLength));
                }
                if (byteLength != offset) {
                    view = new Uint8Array(result, offset);
                    view.set(new Uint8Array(buffer, offset));
                }
                return result;
            };
        }
        function composeArgs(args, partials, holders) {
            var holdersLength = holders.length, argsIndex = -1, argsLength = nativeMax(args.length - holdersLength, 0), leftIndex = -1, leftLength = partials.length, result = Array(argsLength + leftLength);
            while (++leftIndex < leftLength) {
                result[leftIndex] = partials[leftIndex];
            }
            while (++argsIndex < holdersLength) {
                result[holders[argsIndex]] = args[argsIndex];
            }
            while (argsLength--) {
                result[leftIndex++] = args[argsIndex++];
            }
            return result;
        }
        function composeArgsRight(args, partials, holders) {
            var holdersIndex = -1, holdersLength = holders.length, argsIndex = -1, argsLength = nativeMax(args.length - holdersLength, 0), rightIndex = -1, rightLength = partials.length, result = Array(argsLength + rightLength);
            while (++argsIndex < argsLength) {
                result[argsIndex] = args[argsIndex];
            }
            var offset = argsIndex;
            while (++rightIndex < rightLength) {
                result[offset + rightIndex] = partials[rightIndex];
            }
            while (++holdersIndex < holdersLength) {
                result[offset + holders[holdersIndex]] = args[argsIndex++];
            }
            return result;
        }
        function createAggregator(setter, initializer) {
            return function (collection, iteratee, thisArg) {
                var result = initializer ? initializer() : {};
                iteratee = getCallback(iteratee, thisArg, 3);
                if (isArray(collection)) {
                    var index = -1, length = collection.length;
                    while (++index < length) {
                        var value = collection[index];
                        setter(result, value, iteratee(value, index, collection), collection);
                    }
                } else {
                    baseEach(collection, function (value, key, collection) {
                        setter(result, value, iteratee(value, key, collection), collection);
                    });
                }
                return result;
            };
        }
        function createAssigner(assigner) {
            return restParam(function (object, sources) {
                var index = -1, length = object == null ? 0 : sources.length, customizer = length > 2 && sources[length - 2], guard = length > 2 && sources[2], thisArg = length > 1 && sources[length - 1];
                if (typeof customizer == 'function') {
                    customizer = bindCallback(customizer, thisArg, 5);
                    length -= 2;
                } else {
                    customizer = typeof thisArg == 'function' ? thisArg : null;
                    length -= customizer ? 1 : 0;
                }
                if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                    customizer = length < 3 ? null : customizer;
                    length = 1;
                }
                while (++index < length) {
                    var source = sources[index];
                    if (source) {
                        assigner(object, source, customizer);
                    }
                }
                return object;
            });
        }
        function createBaseEach(eachFunc, fromRight) {
            return function (collection, iteratee) {
                var length = collection ? getLength(collection) : 0;
                if (!isLength(length)) {
                    return eachFunc(collection, iteratee);
                }
                var index = fromRight ? length : -1, iterable = toObject(collection);
                while (fromRight ? index-- : ++index < length) {
                    if (iteratee(iterable[index], index, iterable) === false) {
                        break;
                    }
                }
                return collection;
            };
        }
        function createBaseFor(fromRight) {
            return function (object, iteratee, keysFunc) {
                var iterable = toObject(object), props = keysFunc(object), length = props.length, index = fromRight ? length : -1;
                while (fromRight ? index-- : ++index < length) {
                    var key = props[index];
                    if (iteratee(iterable[key], key, iterable) === false) {
                        break;
                    }
                }
                return object;
            };
        }
        function createBindWrapper(func, thisArg) {
            var Ctor = createCtorWrapper(func);
            function wrapper() {
                var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                return fn.apply(thisArg, arguments);
            }
            return wrapper;
        }
        var createCache = !(nativeCreate && Set) ? constant(null) : function (values) {
            return new SetCache(values);
        };
        function createCompounder(callback) {
            return function (string) {
                var index = -1, array = words(deburr(string)), length = array.length, result = '';
                while (++index < length) {
                    result = callback(result, array[index], index);
                }
                return result;
            };
        }
        function createCtorWrapper(Ctor) {
            return function () {
                var thisBinding = baseCreate(Ctor.prototype), result = Ctor.apply(thisBinding, arguments);
                return isObject(result) ? result : thisBinding;
            };
        }
        function createCurry(flag) {
            function curryFunc(func, arity, guard) {
                if (guard && isIterateeCall(func, arity, guard)) {
                    arity = null;
                }
                var result = createWrapper(func, flag, null, null, null, null, null, arity);
                result.placeholder = curryFunc.placeholder;
                return result;
            }
            return curryFunc;
        }
        function createExtremum(arrayFunc, isMin) {
            return function (collection, iteratee, thisArg) {
                if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
                    iteratee = null;
                }
                var func = getCallback(), noIteratee = iteratee == null;
                if (!(func === baseCallback && noIteratee)) {
                    noIteratee = false;
                    iteratee = func(iteratee, thisArg, 3);
                }
                if (noIteratee) {
                    var isArr = isArray(collection);
                    if (!isArr && isString(collection)) {
                        iteratee = charAtCallback;
                    } else {
                        return arrayFunc(isArr ? collection : toIterable(collection));
                    }
                }
                return extremumBy(collection, iteratee, isMin);
            };
        }
        function createFind(eachFunc, fromRight) {
            return function (collection, predicate, thisArg) {
                predicate = getCallback(predicate, thisArg, 3);
                if (isArray(collection)) {
                    var index = baseFindIndex(collection, predicate, fromRight);
                    return index > -1 ? collection[index] : undefined;
                }
                return baseFind(collection, predicate, eachFunc);
            };
        }
        function createFindIndex(fromRight) {
            return function (array, predicate, thisArg) {
                if (!(array && array.length)) {
                    return -1;
                }
                predicate = getCallback(predicate, thisArg, 3);
                return baseFindIndex(array, predicate, fromRight);
            };
        }
        function createFindKey(objectFunc) {
            return function (object, predicate, thisArg) {
                predicate = getCallback(predicate, thisArg, 3);
                return baseFind(object, predicate, objectFunc, true);
            };
        }
        function createFlow(fromRight) {
            return function () {
                var length = arguments.length;
                if (!length) {
                    return function () {
                        return arguments[0];
                    };
                }
                var wrapper, index = fromRight ? length : -1, leftIndex = 0, funcs = Array(length);
                while (fromRight ? index-- : ++index < length) {
                    var func = funcs[leftIndex++] = arguments[index];
                    if (typeof func != 'function') {
                        throw new TypeError(FUNC_ERROR_TEXT);
                    }
                    var funcName = wrapper ? '' : getFuncName(func);
                    wrapper = funcName == 'wrapper' ? new LodashWrapper([]) : wrapper;
                }
                index = wrapper ? -1 : length;
                while (++index < length) {
                    func = funcs[index];
                    funcName = getFuncName(func);
                    var data = funcName == 'wrapper' ? getData(func) : null;
                    if (data && isLaziable(data[0]) && data[1] == (ARY_FLAG | CURRY_FLAG | PARTIAL_FLAG | REARG_FLAG) && !data[4].length && data[9] == 1) {
                        wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                    } else {
                        wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                    }
                }
                return function () {
                    var args = arguments;
                    if (wrapper && args.length == 1 && isArray(args[0])) {
                        return wrapper.plant(args[0]).value();
                    }
                    var index = 0, result = funcs[index].apply(this, args);
                    while (++index < length) {
                        result = funcs[index].call(this, result);
                    }
                    return result;
                };
            };
        }
        function createForEach(arrayFunc, eachFunc) {
            return function (collection, iteratee, thisArg) {
                return typeof iteratee == 'function' && thisArg === undefined && isArray(collection) ? arrayFunc(collection, iteratee) : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
            };
        }
        function createForIn(objectFunc) {
            return function (object, iteratee, thisArg) {
                if (typeof iteratee != 'function' || thisArg !== undefined) {
                    iteratee = bindCallback(iteratee, thisArg, 3);
                }
                return objectFunc(object, iteratee, keysIn);
            };
        }
        function createForOwn(objectFunc) {
            return function (object, iteratee, thisArg) {
                if (typeof iteratee != 'function' || thisArg !== undefined) {
                    iteratee = bindCallback(iteratee, thisArg, 3);
                }
                return objectFunc(object, iteratee);
            };
        }
        function createObjectMapper(isMapKeys) {
            return function (object, iteratee, thisArg) {
                var result = {};
                iteratee = getCallback(iteratee, thisArg, 3);
                baseForOwn(object, function (value, key, object) {
                    var mapped = iteratee(value, key, object);
                    key = isMapKeys ? mapped : key;
                    value = isMapKeys ? value : mapped;
                    result[key] = value;
                });
                return result;
            };
        }
        function createPadDir(fromRight) {
            return function (string, length, chars) {
                string = baseToString(string);
                return (fromRight ? string : '') + createPadding(string, length, chars) + (fromRight ? '' : string);
            };
        }
        function createPartial(flag) {
            var partialFunc = restParam(function (func, partials) {
                var holders = replaceHolders(partials, partialFunc.placeholder);
                return createWrapper(func, flag, null, partials, holders);
            });
            return partialFunc;
        }
        function createReduce(arrayFunc, eachFunc) {
            return function (collection, iteratee, accumulator, thisArg) {
                var initFromArray = arguments.length < 3;
                return typeof iteratee == 'function' && thisArg === undefined && isArray(collection) ? arrayFunc(collection, iteratee, accumulator, initFromArray) : baseReduce(collection, getCallback(iteratee, thisArg, 4), accumulator, initFromArray, eachFunc);
            };
        }
        function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
            var isAry = bitmask & ARY_FLAG, isBind = bitmask & BIND_FLAG, isBindKey = bitmask & BIND_KEY_FLAG, isCurry = bitmask & CURRY_FLAG, isCurryBound = bitmask & CURRY_BOUND_FLAG, isCurryRight = bitmask & CURRY_RIGHT_FLAG;
            var Ctor = !isBindKey && createCtorWrapper(func), key = func;
            function wrapper() {
                var length = arguments.length, index = length, args = Array(length);
                while (index--) {
                    args[index] = arguments[index];
                }
                if (partials) {
                    args = composeArgs(args, partials, holders);
                }
                if (partialsRight) {
                    args = composeArgsRight(args, partialsRight, holdersRight);
                }
                if (isCurry || isCurryRight) {
                    var placeholder = wrapper.placeholder, argsHolders = replaceHolders(args, placeholder);
                    length -= argsHolders.length;
                    if (length < arity) {
                        var newArgPos = argPos ? arrayCopy(argPos) : null, newArity = nativeMax(arity - length, 0), newsHolders = isCurry ? argsHolders : null, newHoldersRight = isCurry ? null : argsHolders, newPartials = isCurry ? args : null, newPartialsRight = isCurry ? null : args;
                        bitmask |= isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG;
                        bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);
                        if (!isCurryBound) {
                            bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
                        }
                        var newData = [
                                func,
                                bitmask,
                                thisArg,
                                newPartials,
                                newsHolders,
                                newPartialsRight,
                                newHoldersRight,
                                newArgPos,
                                ary,
                                newArity
                            ], result = createHybridWrapper.apply(undefined, newData);
                        if (isLaziable(func)) {
                            setData(result, newData);
                        }
                        result.placeholder = placeholder;
                        return result;
                    }
                }
                var thisBinding = isBind ? thisArg : this;
                if (isBindKey) {
                    func = thisBinding[key];
                }
                if (argPos) {
                    args = reorder(args, argPos);
                }
                if (isAry && ary < args.length) {
                    args.length = ary;
                }
                var fn = this && this !== root && this instanceof wrapper ? Ctor || createCtorWrapper(func) : func;
                return fn.apply(thisBinding, args);
            }
            return wrapper;
        }
        function createPadding(string, length, chars) {
            var strLength = string.length;
            length = +length;
            if (strLength >= length || !nativeIsFinite(length)) {
                return '';
            }
            var padLength = length - strLength;
            chars = chars == null ? ' ' : chars + '';
            return repeat(chars, ceil(padLength / chars.length)).slice(0, padLength);
        }
        function createPartialWrapper(func, bitmask, thisArg, partials) {
            var isBind = bitmask & BIND_FLAG, Ctor = createCtorWrapper(func);
            function wrapper() {
                var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(argsLength + leftLength);
                while (++leftIndex < leftLength) {
                    args[leftIndex] = partials[leftIndex];
                }
                while (argsLength--) {
                    args[leftIndex++] = arguments[++argsIndex];
                }
                var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                return fn.apply(isBind ? thisArg : this, args);
            }
            return wrapper;
        }
        function createSortedIndex(retHighest) {
            return function (array, value, iteratee, thisArg) {
                var func = getCallback(iteratee);
                return func === baseCallback && iteratee == null ? binaryIndex(array, value, retHighest) : binaryIndexBy(array, value, func(iteratee, thisArg, 1), retHighest);
            };
        }
        function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
            var isBindKey = bitmask & BIND_KEY_FLAG;
            if (!isBindKey && typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            var length = partials ? partials.length : 0;
            if (!length) {
                bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
                partials = holders = null;
            }
            length -= holders ? holders.length : 0;
            if (bitmask & PARTIAL_RIGHT_FLAG) {
                var partialsRight = partials, holdersRight = holders;
                partials = holders = null;
            }
            var data = isBindKey ? null : getData(func), newData = [
                    func,
                    bitmask,
                    thisArg,
                    partials,
                    holders,
                    partialsRight,
                    holdersRight,
                    argPos,
                    ary,
                    arity
                ];
            if (data) {
                mergeData(newData, data);
                bitmask = newData[1];
                arity = newData[9];
            }
            newData[9] = arity == null ? isBindKey ? 0 : func.length : nativeMax(arity - length, 0) || 0;
            if (bitmask == BIND_FLAG) {
                var result = createBindWrapper(newData[0], newData[2]);
            } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
                result = createPartialWrapper.apply(undefined, newData);
            } else {
                result = createHybridWrapper.apply(undefined, newData);
            }
            var setter = data ? baseSetData : setData;
            return setter(result, newData);
        }
        function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
            var index = -1, arrLength = array.length, othLength = other.length, result = true;
            if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
                return false;
            }
            while (result && ++index < arrLength) {
                var arrValue = array[index], othValue = other[index];
                result = undefined;
                if (customizer) {
                    result = isLoose ? customizer(othValue, arrValue, index) : customizer(arrValue, othValue, index);
                }
                if (result === undefined) {
                    if (isLoose) {
                        var othIndex = othLength;
                        while (othIndex--) {
                            othValue = other[othIndex];
                            result = arrValue && arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
                            if (result) {
                                break;
                            }
                        }
                    } else {
                        result = arrValue && arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
                    }
                }
            }
            return !!result;
        }
        function equalByTag(object, other, tag) {
            switch (tag) {
            case boolTag:
            case dateTag:
                return +object == +other;
            case errorTag:
                return object.name == other.name && object.message == other.message;
            case numberTag:
                return object != +object ? other != +other : object == +other;
            case regexpTag:
            case stringTag:
                return object == other + '';
            }
            return false;
        }
        function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
            var objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
            if (objLength != othLength && !isLoose) {
                return false;
            }
            var skipCtor = isLoose, index = -1;
            while (++index < objLength) {
                var key = objProps[index], result = isLoose ? key in other : hasOwnProperty.call(other, key);
                if (result) {
                    var objValue = object[key], othValue = other[key];
                    result = undefined;
                    if (customizer) {
                        result = isLoose ? customizer(othValue, objValue, key) : customizer(objValue, othValue, key);
                    }
                    if (result === undefined) {
                        result = objValue && objValue === othValue || equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB);
                    }
                }
                if (!result) {
                    return false;
                }
                skipCtor || (skipCtor = key == 'constructor');
            }
            if (!skipCtor) {
                var objCtor = object.constructor, othCtor = other.constructor;
                if (objCtor != othCtor && ('constructor' in object && 'constructor' in other) && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
                    return false;
                }
            }
            return true;
        }
        function extremumBy(collection, iteratee, isMin) {
            var exValue = isMin ? POSITIVE_INFINITY : NEGATIVE_INFINITY, computed = exValue, result = computed;
            baseEach(collection, function (value, index, collection) {
                var current = iteratee(value, index, collection);
                if ((isMin ? current < computed : current > computed) || current === exValue && current === result) {
                    computed = current;
                    result = value;
                }
            });
            return result;
        }
        function getCallback(func, thisArg, argCount) {
            var result = lodash.callback || callback;
            result = result === callback ? baseCallback : result;
            return argCount ? result(func, thisArg, argCount) : result;
        }
        var getData = !metaMap ? noop : function (func) {
            return metaMap.get(func);
        };
        var getFuncName = function () {
            if (!support.funcNames) {
                return constant('');
            }
            if (constant.name == 'constant') {
                return baseProperty('name');
            }
            return function (func) {
                var result = func.name, array = realNames[result], length = array ? array.length : 0;
                while (length--) {
                    var data = array[length], otherFunc = data.func;
                    if (otherFunc == null || otherFunc == func) {
                        return data.name;
                    }
                }
                return result;
            };
        }();
        function getIndexOf(collection, target, fromIndex) {
            var result = lodash.indexOf || indexOf;
            result = result === indexOf ? baseIndexOf : result;
            return collection ? result(collection, target, fromIndex) : result;
        }
        var getLength = baseProperty('length');
        var getSymbols = !getOwnPropertySymbols ? constant([]) : function (object) {
            return getOwnPropertySymbols(toObject(object));
        };
        function getView(start, end, transforms) {
            var index = -1, length = transforms ? transforms.length : 0;
            while (++index < length) {
                var data = transforms[index], size = data.size;
                switch (data.type) {
                case 'drop':
                    start += size;
                    break;
                case 'dropRight':
                    end -= size;
                    break;
                case 'take':
                    end = nativeMin(end, start + size);
                    break;
                case 'takeRight':
                    start = nativeMax(start, end - size);
                    break;
                }
            }
            return {
                'start': start,
                'end': end
            };
        }
        function initCloneArray(array) {
            var length = array.length, result = new array.constructor(length);
            if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
                result.index = array.index;
                result.input = array.input;
            }
            return result;
        }
        function initCloneObject(object) {
            var Ctor = object.constructor;
            if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
                Ctor = Object;
            }
            return new Ctor();
        }
        function initCloneByTag(object, tag, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
            case arrayBufferTag:
                return bufferClone(object);
            case boolTag:
            case dateTag:
                return new Ctor(+object);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
                var buffer = object.buffer;
                return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);
            case numberTag:
            case stringTag:
                return new Ctor(object);
            case regexpTag:
                var result = new Ctor(object.source, reFlags.exec(object));
                result.lastIndex = object.lastIndex;
            }
            return result;
        }
        function invokePath(object, path, args) {
            if (object != null && !isKey(path, object)) {
                path = toPath(path);
                object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
                path = last(path);
            }
            var func = object == null ? object : object[path];
            return func == null ? undefined : func.apply(object, args);
        }
        function isArrayLike(value) {
            return value != null && isLength(getLength(value));
        }
        function isIndex(value, length) {
            value = +value;
            length = length == null ? MAX_SAFE_INTEGER : length;
            return value > -1 && value % 1 == 0 && value < length;
        }
        function isIterateeCall(value, index, object) {
            if (!isObject(object)) {
                return false;
            }
            var type = typeof index;
            if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
                var other = object[index];
                return value === value ? value === other : other !== other;
            }
            return false;
        }
        function isKey(value, object) {
            var type = typeof value;
            if (type == 'string' && reIsPlainProp.test(value) || type == 'number') {
                return true;
            }
            if (isArray(value)) {
                return false;
            }
            var result = !reIsDeepProp.test(value);
            return result || object != null && value in toObject(object);
        }
        function isLaziable(func) {
            var funcName = getFuncName(func);
            return !!funcName && func === lodash[funcName] && funcName in LazyWrapper.prototype;
        }
        function isLength(value) {
            return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isStrictComparable(value) {
            return value === value && !isObject(value);
        }
        function mergeData(data, source) {
            var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < ARY_FLAG;
            var isCombo = srcBitmask == ARY_FLAG && bitmask == CURRY_FLAG || srcBitmask == ARY_FLAG && bitmask == REARG_FLAG && data[7].length <= source[8] || srcBitmask == (ARY_FLAG | REARG_FLAG) && bitmask == CURRY_FLAG;
            if (!(isCommon || isCombo)) {
                return data;
            }
            if (srcBitmask & BIND_FLAG) {
                data[2] = source[2];
                newBitmask |= bitmask & BIND_FLAG ? 0 : CURRY_BOUND_FLAG;
            }
            var value = source[3];
            if (value) {
                var partials = data[3];
                data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
                data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
            }
            value = source[5];
            if (value) {
                partials = data[5];
                data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
                data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
            }
            value = source[7];
            if (value) {
                data[7] = arrayCopy(value);
            }
            if (srcBitmask & ARY_FLAG) {
                data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
            }
            if (data[9] == null) {
                data[9] = source[9];
            }
            data[0] = source[0];
            data[1] = newBitmask;
            return data;
        }
        function pickByArray(object, props) {
            object = toObject(object);
            var index = -1, length = props.length, result = {};
            while (++index < length) {
                var key = props[index];
                if (key in object) {
                    result[key] = object[key];
                }
            }
            return result;
        }
        function pickByCallback(object, predicate) {
            var result = {};
            baseForIn(object, function (value, key, object) {
                if (predicate(value, key, object)) {
                    result[key] = value;
                }
            });
            return result;
        }
        function reorder(array, indexes) {
            var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = arrayCopy(array);
            while (length--) {
                var index = indexes[length];
                array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
            }
            return array;
        }
        var setData = function () {
            var count = 0, lastCalled = 0;
            return function (key, value) {
                var stamp = now(), remaining = HOT_SPAN - (stamp - lastCalled);
                lastCalled = stamp;
                if (remaining > 0) {
                    if (++count >= HOT_COUNT) {
                        return key;
                    }
                } else {
                    count = 0;
                }
                return baseSetData(key, value);
            };
        }();
        function shimIsPlainObject(value) {
            var Ctor, support = lodash.support;
            if (!(isObjectLike(value) && objToString.call(value) == objectTag) || !hasOwnProperty.call(value, 'constructor') && (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor))) {
                return false;
            }
            var result;
            baseForIn(value, function (subValue, key) {
                result = key;
            });
            return result === undefined || hasOwnProperty.call(value, result);
        }
        function shimKeys(object) {
            var props = keysIn(object), propsLength = props.length, length = propsLength && object.length, support = lodash.support;
            var allowIndexes = length && isLength(length) && (isArray(object) || support.nonEnumArgs && isArguments(object));
            var index = -1, result = [];
            while (++index < propsLength) {
                var key = props[index];
                if (allowIndexes && isIndex(key, length) || hasOwnProperty.call(object, key)) {
                    result.push(key);
                }
            }
            return result;
        }
        function toIterable(value) {
            if (value == null) {
                return [];
            }
            if (!isArrayLike(value)) {
                return values(value);
            }
            return isObject(value) ? value : Object(value);
        }
        function toObject(value) {
            return isObject(value) ? value : Object(value);
        }
        function toPath(value) {
            if (isArray(value)) {
                return value;
            }
            var result = [];
            baseToString(value).replace(rePropName, function (match, number, quote, string) {
                result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
            });
            return result;
        }
        function wrapperClone(wrapper) {
            return wrapper instanceof LazyWrapper ? wrapper.clone() : new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__, arrayCopy(wrapper.__actions__));
        }
        function chunk(array, size, guard) {
            if (guard ? isIterateeCall(array, size, guard) : size == null) {
                size = 1;
            } else {
                size = nativeMax(+size || 1, 1);
            }
            var index = 0, length = array ? array.length : 0, resIndex = -1, result = Array(ceil(length / size));
            while (index < length) {
                result[++resIndex] = baseSlice(array, index, index += size);
            }
            return result;
        }
        function compact(array) {
            var index = -1, length = array ? array.length : 0, resIndex = -1, result = [];
            while (++index < length) {
                var value = array[index];
                if (value) {
                    result[++resIndex] = value;
                }
            }
            return result;
        }
        var difference = restParam(function (array, values) {
            return isArrayLike(array) ? baseDifference(array, baseFlatten(values, false, true)) : [];
        });
        function drop(array, n, guard) {
            var length = array ? array.length : 0;
            if (!length) {
                return [];
            }
            if (guard ? isIterateeCall(array, n, guard) : n == null) {
                n = 1;
            }
            return baseSlice(array, n < 0 ? 0 : n);
        }
        function dropRight(array, n, guard) {
            var length = array ? array.length : 0;
            if (!length) {
                return [];
            }
            if (guard ? isIterateeCall(array, n, guard) : n == null) {
                n = 1;
            }
            n = length - (+n || 0);
            return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate, thisArg) {
            return array && array.length ? baseWhile(array, getCallback(predicate, thisArg, 3), true, true) : [];
        }
        function dropWhile(array, predicate, thisArg) {
            return array && array.length ? baseWhile(array, getCallback(predicate, thisArg, 3), true) : [];
        }
        function fill(array, value, start, end) {
            var length = array ? array.length : 0;
            if (!length) {
                return [];
            }
            if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
                start = 0;
                end = length;
            }
            return baseFill(array, value, start, end);
        }
        var findIndex = createFindIndex();
        var findLastIndex = createFindIndex(true);
        function first(array) {
            return array ? array[0] : undefined;
        }
        function flatten(array, isDeep, guard) {
            var length = array ? array.length : 0;
            if (guard && isIterateeCall(array, isDeep, guard)) {
                isDeep = false;
            }
            return length ? baseFlatten(array, isDeep) : [];
        }
        function flattenDeep(array) {
            var length = array ? array.length : 0;
            return length ? baseFlatten(array, true) : [];
        }
        function indexOf(array, value, fromIndex) {
            var length = array ? array.length : 0;
            if (!length) {
                return -1;
            }
            if (typeof fromIndex == 'number') {
                fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
            } else if (fromIndex) {
                var index = binaryIndex(array, value), other = array[index];
                if (value === value ? value === other : other !== other) {
                    return index;
                }
                return -1;
            }
            return baseIndexOf(array, value, fromIndex || 0);
        }
        function initial(array) {
            return dropRight(array, 1);
        }
        function intersection() {
            var args = [], argsIndex = -1, argsLength = arguments.length, caches = [], indexOf = getIndexOf(), isCommon = indexOf == baseIndexOf, result = [];
            while (++argsIndex < argsLength) {
                var value = arguments[argsIndex];
                if (isArrayLike(value)) {
                    args.push(value);
                    caches.push(isCommon && value.length >= 120 ? createCache(argsIndex && value) : null);
                }
            }
            argsLength = args.length;
            if (argsLength < 2) {
                return result;
            }
            var array = args[0], index = -1, length = array ? array.length : 0, seen = caches[0];
            outer:
                while (++index < length) {
                    value = array[index];
                    if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
                        argsIndex = argsLength;
                        while (--argsIndex) {
                            var cache = caches[argsIndex];
                            if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value, 0)) < 0) {
                                continue outer;
                            }
                        }
                        if (seen) {
                            seen.push(value);
                        }
                        result.push(value);
                    }
                }
            return result;
        }
        function last(array) {
            var length = array ? array.length : 0;
            return length ? array[length - 1] : undefined;
        }
        function lastIndexOf(array, value, fromIndex) {
            var length = array ? array.length : 0;
            if (!length) {
                return -1;
            }
            var index = length;
            if (typeof fromIndex == 'number') {
                index = (fromIndex < 0 ? nativeMax(length + fromIndex, 0) : nativeMin(fromIndex || 0, length - 1)) + 1;
            } else if (fromIndex) {
                index = binaryIndex(array, value, true) - 1;
                var other = array[index];
                if (value === value ? value === other : other !== other) {
                    return index;
                }
                return -1;
            }
            if (value !== value) {
                return indexOfNaN(array, index, true);
            }
            while (index--) {
                if (array[index] === value) {
                    return index;
                }
            }
            return -1;
        }
        function pull() {
            var args = arguments, array = args[0];
            if (!(array && array.length)) {
                return array;
            }
            var index = 0, indexOf = getIndexOf(), length = args.length;
            while (++index < length) {
                var fromIndex = 0, value = args[index];
                while ((fromIndex = indexOf(array, value, fromIndex)) > -1) {
                    splice.call(array, fromIndex, 1);
                }
            }
            return array;
        }
        var pullAt = restParam(function (array, indexes) {
            indexes = baseFlatten(indexes);
            var result = baseAt(array, indexes);
            basePullAt(array, indexes.sort(baseCompareAscending));
            return result;
        });
        function remove(array, predicate, thisArg) {
            var result = [];
            if (!(array && array.length)) {
                return result;
            }
            var index = -1, indexes = [], length = array.length;
            predicate = getCallback(predicate, thisArg, 3);
            while (++index < length) {
                var value = array[index];
                if (predicate(value, index, array)) {
                    result.push(value);
                    indexes.push(index);
                }
            }
            basePullAt(array, indexes);
            return result;
        }
        function rest(array) {
            return drop(array, 1);
        }
        function slice(array, start, end) {
            var length = array ? array.length : 0;
            if (!length) {
                return [];
            }
            if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
                start = 0;
                end = length;
            }
            return baseSlice(array, start, end);
        }
        var sortedIndex = createSortedIndex();
        var sortedLastIndex = createSortedIndex(true);
        function take(array, n, guard) {
            var length = array ? array.length : 0;
            if (!length) {
                return [];
            }
            if (guard ? isIterateeCall(array, n, guard) : n == null) {
                n = 1;
            }
            return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
            var length = array ? array.length : 0;
            if (!length) {
                return [];
            }
            if (guard ? isIterateeCall(array, n, guard) : n == null) {
                n = 1;
            }
            n = length - (+n || 0);
            return baseSlice(array, n < 0 ? 0 : n);
        }
        function takeRightWhile(array, predicate, thisArg) {
            return array && array.length ? baseWhile(array, getCallback(predicate, thisArg, 3), false, true) : [];
        }
        function takeWhile(array, predicate, thisArg) {
            return array && array.length ? baseWhile(array, getCallback(predicate, thisArg, 3)) : [];
        }
        var union = restParam(function (arrays) {
            return baseUniq(baseFlatten(arrays, false, true));
        });
        function uniq(array, isSorted, iteratee, thisArg) {
            var length = array ? array.length : 0;
            if (!length) {
                return [];
            }
            if (isSorted != null && typeof isSorted != 'boolean') {
                thisArg = iteratee;
                iteratee = isIterateeCall(array, isSorted, thisArg) ? null : isSorted;
                isSorted = false;
            }
            var func = getCallback();
            if (!(func === baseCallback && iteratee == null)) {
                iteratee = func(iteratee, thisArg, 3);
            }
            return isSorted && getIndexOf() == baseIndexOf ? sortedUniq(array, iteratee) : baseUniq(array, iteratee);
        }
        function unzip(array) {
            if (!(array && array.length)) {
                return [];
            }
            var index = -1, length = 0;
            array = arrayFilter(array, function (group) {
                if (isArrayLike(group)) {
                    length = nativeMax(group.length, length);
                    return true;
                }
            });
            var result = Array(length);
            while (++index < length) {
                result[index] = arrayMap(array, baseProperty(index));
            }
            return result;
        }
        function unzipWith(array, iteratee, thisArg) {
            var length = array ? array.length : 0;
            if (!length) {
                return [];
            }
            var result = unzip(array);
            if (iteratee == null) {
                return result;
            }
            iteratee = bindCallback(iteratee, thisArg, 4);
            return arrayMap(result, function (group) {
                return arrayReduce(group, iteratee, undefined, true);
            });
        }
        var without = restParam(function (array, values) {
            return isArrayLike(array) ? baseDifference(array, values) : [];
        });
        function xor() {
            var index = -1, length = arguments.length;
            while (++index < length) {
                var array = arguments[index];
                if (isArrayLike(array)) {
                    var result = result ? baseDifference(result, array).concat(baseDifference(array, result)) : array;
                }
            }
            return result ? baseUniq(result) : [];
        }
        var zip = restParam(unzip);
        function zipObject(props, values) {
            var index = -1, length = props ? props.length : 0, result = {};
            if (length && !values && !isArray(props[0])) {
                values = [];
            }
            while (++index < length) {
                var key = props[index];
                if (values) {
                    result[key] = values[index];
                } else if (key) {
                    result[key[0]] = key[1];
                }
            }
            return result;
        }
        var zipWith = restParam(function (arrays) {
            var length = arrays.length, iteratee = arrays[length - 2], thisArg = arrays[length - 1];
            if (length > 2 && typeof iteratee == 'function') {
                length -= 2;
            } else {
                iteratee = length > 1 && typeof thisArg == 'function' ? (--length, thisArg) : undefined;
                thisArg = undefined;
            }
            arrays.length = length;
            return unzipWith(arrays, iteratee, thisArg);
        });
        function chain(value) {
            var result = lodash(value);
            result.__chain__ = true;
            return result;
        }
        function tap(value, interceptor, thisArg) {
            interceptor.call(thisArg, value);
            return value;
        }
        function thru(value, interceptor, thisArg) {
            return interceptor.call(thisArg, value);
        }
        function wrapperChain() {
            return chain(this);
        }
        function wrapperCommit() {
            return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperPlant(value) {
            var result, parent = this;
            while (parent instanceof baseLodash) {
                var clone = wrapperClone(parent);
                if (result) {
                    previous.__wrapped__ = clone;
                } else {
                    result = clone;
                }
                var previous = clone;
                parent = parent.__wrapped__;
            }
            previous.__wrapped__ = value;
            return result;
        }
        function wrapperReverse() {
            var value = this.__wrapped__;
            if (value instanceof LazyWrapper) {
                if (this.__actions__.length) {
                    value = new LazyWrapper(this);
                }
                return new LodashWrapper(value.reverse(), this.__chain__);
            }
            return this.thru(function (value) {
                return value.reverse();
            });
        }
        function wrapperToString() {
            return this.value() + '';
        }
        function wrapperValue() {
            return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var at = restParam(function (collection, props) {
            return baseAt(collection, baseFlatten(props));
        });
        var countBy = createAggregator(function (result, value, key) {
            hasOwnProperty.call(result, key) ? ++result[key] : result[key] = 1;
        });
        function every(collection, predicate, thisArg) {
            var func = isArray(collection) ? arrayEvery : baseEvery;
            if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
                predicate = null;
            }
            if (typeof predicate != 'function' || thisArg !== undefined) {
                predicate = getCallback(predicate, thisArg, 3);
            }
            return func(collection, predicate);
        }
        function filter(collection, predicate, thisArg) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            predicate = getCallback(predicate, thisArg, 3);
            return func(collection, predicate);
        }
        var find = createFind(baseEach);
        var findLast = createFind(baseEachRight, true);
        function findWhere(collection, source) {
            return find(collection, baseMatches(source));
        }
        var forEach = createForEach(arrayEach, baseEach);
        var forEachRight = createForEach(arrayEachRight, baseEachRight);
        var groupBy = createAggregator(function (result, value, key) {
            if (hasOwnProperty.call(result, key)) {
                result[key].push(value);
            } else {
                result[key] = [value];
            }
        });
        function includes(collection, target, fromIndex, guard) {
            var length = collection ? getLength(collection) : 0;
            if (!isLength(length)) {
                collection = values(collection);
                length = collection.length;
            }
            if (!length) {
                return false;
            }
            if (typeof fromIndex != 'number' || guard && isIterateeCall(target, fromIndex, guard)) {
                fromIndex = 0;
            } else {
                fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex || 0;
            }
            return typeof collection == 'string' || !isArray(collection) && isString(collection) ? fromIndex < length && collection.indexOf(target, fromIndex) > -1 : getIndexOf(collection, target, fromIndex) > -1;
        }
        var indexBy = createAggregator(function (result, value, key) {
            result[key] = value;
        });
        var invoke = restParam(function (collection, path, args) {
            var index = -1, isFunc = typeof path == 'function', isProp = isKey(path), result = isArrayLike(collection) ? Array(collection.length) : [];
            baseEach(collection, function (value) {
                var func = isFunc ? path : isProp && value != null && value[path];
                result[++index] = func ? func.apply(value, args) : invokePath(value, path, args);
            });
            return result;
        });
        function map(collection, iteratee, thisArg) {
            var func = isArray(collection) ? arrayMap : baseMap;
            iteratee = getCallback(iteratee, thisArg, 3);
            return func(collection, iteratee);
        }
        var partition = createAggregator(function (result, value, key) {
            result[key ? 0 : 1].push(value);
        }, function () {
            return [
                [],
                []
            ];
        });
        function pluck(collection, path) {
            return map(collection, property(path));
        }
        var reduce = createReduce(arrayReduce, baseEach);
        var reduceRight = createReduce(arrayReduceRight, baseEachRight);
        function reject(collection, predicate, thisArg) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            predicate = getCallback(predicate, thisArg, 3);
            return func(collection, function (value, index, collection) {
                return !predicate(value, index, collection);
            });
        }
        function sample(collection, n, guard) {
            if (guard ? isIterateeCall(collection, n, guard) : n == null) {
                collection = toIterable(collection);
                var length = collection.length;
                return length > 0 ? collection[baseRandom(0, length - 1)] : undefined;
            }
            var result = shuffle(collection);
            result.length = nativeMin(n < 0 ? 0 : +n || 0, result.length);
            return result;
        }
        function shuffle(collection) {
            collection = toIterable(collection);
            var index = -1, length = collection.length, result = Array(length);
            while (++index < length) {
                var rand = baseRandom(0, index);
                if (index != rand) {
                    result[index] = result[rand];
                }
                result[rand] = collection[index];
            }
            return result;
        }
        function size(collection) {
            var length = collection ? getLength(collection) : 0;
            return isLength(length) ? length : keys(collection).length;
        }
        function some(collection, predicate, thisArg) {
            var func = isArray(collection) ? arraySome : baseSome;
            if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
                predicate = null;
            }
            if (typeof predicate != 'function' || thisArg !== undefined) {
                predicate = getCallback(predicate, thisArg, 3);
            }
            return func(collection, predicate);
        }
        function sortBy(collection, iteratee, thisArg) {
            if (collection == null) {
                return [];
            }
            if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
                iteratee = null;
            }
            var index = -1;
            iteratee = getCallback(iteratee, thisArg, 3);
            var result = baseMap(collection, function (value, key, collection) {
                return {
                    'criteria': iteratee(value, key, collection),
                    'index': ++index,
                    'value': value
                };
            });
            return baseSortBy(result, compareAscending);
        }
        var sortByAll = restParam(function (collection, iteratees) {
            if (collection == null) {
                return [];
            }
            var guard = iteratees[2];
            if (guard && isIterateeCall(iteratees[0], iteratees[1], guard)) {
                iteratees.length = 1;
            }
            return baseSortByOrder(collection, baseFlatten(iteratees), []);
        });
        function sortByOrder(collection, iteratees, orders, guard) {
            if (collection == null) {
                return [];
            }
            if (guard && isIterateeCall(iteratees, orders, guard)) {
                orders = null;
            }
            if (!isArray(iteratees)) {
                iteratees = iteratees == null ? [] : [iteratees];
            }
            if (!isArray(orders)) {
                orders = orders == null ? [] : [orders];
            }
            return baseSortByOrder(collection, iteratees, orders);
        }
        function where(collection, source) {
            return filter(collection, baseMatches(source));
        }
        var now = nativeNow || function () {
            return new Date().getTime();
        };
        function after(n, func) {
            if (typeof func != 'function') {
                if (typeof n == 'function') {
                    var temp = n;
                    n = func;
                    func = temp;
                } else {
                    throw new TypeError(FUNC_ERROR_TEXT);
                }
            }
            n = nativeIsFinite(n = +n) ? n : 0;
            return function () {
                if (--n < 1) {
                    return func.apply(this, arguments);
                }
            };
        }
        function ary(func, n, guard) {
            if (guard && isIterateeCall(func, n, guard)) {
                n = null;
            }
            n = func && n == null ? func.length : nativeMax(+n || 0, 0);
            return createWrapper(func, ARY_FLAG, null, null, null, null, n);
        }
        function before(n, func) {
            var result;
            if (typeof func != 'function') {
                if (typeof n == 'function') {
                    var temp = n;
                    n = func;
                    func = temp;
                } else {
                    throw new TypeError(FUNC_ERROR_TEXT);
                }
            }
            return function () {
                if (--n > 0) {
                    result = func.apply(this, arguments);
                }
                if (n <= 1) {
                    func = null;
                }
                return result;
            };
        }
        var bind = restParam(function (func, thisArg, partials) {
            var bitmask = BIND_FLAG;
            if (partials.length) {
                var holders = replaceHolders(partials, bind.placeholder);
                bitmask |= PARTIAL_FLAG;
            }
            return createWrapper(func, bitmask, thisArg, partials, holders);
        });
        var bindAll = restParam(function (object, methodNames) {
            methodNames = methodNames.length ? baseFlatten(methodNames) : functions(object);
            var index = -1, length = methodNames.length;
            while (++index < length) {
                var key = methodNames[index];
                object[key] = createWrapper(object[key], BIND_FLAG, object);
            }
            return object;
        });
        var bindKey = restParam(function (object, key, partials) {
            var bitmask = BIND_FLAG | BIND_KEY_FLAG;
            if (partials.length) {
                var holders = replaceHolders(partials, bindKey.placeholder);
                bitmask |= PARTIAL_FLAG;
            }
            return createWrapper(key, bitmask, object, partials, holders);
        });
        var curry = createCurry(CURRY_FLAG);
        var curryRight = createCurry(CURRY_RIGHT_FLAG);
        function debounce(func, wait, options) {
            var args, maxTimeoutId, result, stamp, thisArg, timeoutId, trailingCall, lastCalled = 0, maxWait = false, trailing = true;
            if (typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            wait = wait < 0 ? 0 : +wait || 0;
            if (options === true) {
                var leading = true;
                trailing = false;
            } else if (isObject(options)) {
                leading = options.leading;
                maxWait = 'maxWait' in options && nativeMax(+options.maxWait || 0, wait);
                trailing = 'trailing' in options ? options.trailing : trailing;
            }
            function cancel() {
                if (timeoutId) {
                    clearTimeout(timeoutId);
                }
                if (maxTimeoutId) {
                    clearTimeout(maxTimeoutId);
                }
                maxTimeoutId = timeoutId = trailingCall = undefined;
            }
            function delayed() {
                var remaining = wait - (now() - stamp);
                if (remaining <= 0 || remaining > wait) {
                    if (maxTimeoutId) {
                        clearTimeout(maxTimeoutId);
                    }
                    var isCalled = trailingCall;
                    maxTimeoutId = timeoutId = trailingCall = undefined;
                    if (isCalled) {
                        lastCalled = now();
                        result = func.apply(thisArg, args);
                        if (!timeoutId && !maxTimeoutId) {
                            args = thisArg = null;
                        }
                    }
                } else {
                    timeoutId = setTimeout(delayed, remaining);
                }
            }
            function maxDelayed() {
                if (timeoutId) {
                    clearTimeout(timeoutId);
                }
                maxTimeoutId = timeoutId = trailingCall = undefined;
                if (trailing || maxWait !== wait) {
                    lastCalled = now();
                    result = func.apply(thisArg, args);
                    if (!timeoutId && !maxTimeoutId) {
                        args = thisArg = null;
                    }
                }
            }
            function debounced() {
                args = arguments;
                stamp = now();
                thisArg = this;
                trailingCall = trailing && (timeoutId || !leading);
                if (maxWait === false) {
                    var leadingCall = leading && !timeoutId;
                } else {
                    if (!maxTimeoutId && !leading) {
                        lastCalled = stamp;
                    }
                    var remaining = maxWait - (stamp - lastCalled), isCalled = remaining <= 0 || remaining > maxWait;
                    if (isCalled) {
                        if (maxTimeoutId) {
                            maxTimeoutId = clearTimeout(maxTimeoutId);
                        }
                        lastCalled = stamp;
                        result = func.apply(thisArg, args);
                    } else if (!maxTimeoutId) {
                        maxTimeoutId = setTimeout(maxDelayed, remaining);
                    }
                }
                if (isCalled && timeoutId) {
                    timeoutId = clearTimeout(timeoutId);
                } else if (!timeoutId && wait !== maxWait) {
                    timeoutId = setTimeout(delayed, wait);
                }
                if (leadingCall) {
                    isCalled = true;
                    result = func.apply(thisArg, args);
                }
                if (isCalled && !timeoutId && !maxTimeoutId) {
                    args = thisArg = null;
                }
                return result;
            }
            debounced.cancel = cancel;
            return debounced;
        }
        var defer = restParam(function (func, args) {
            return baseDelay(func, 1, args);
        });
        var delay = restParam(function (func, wait, args) {
            return baseDelay(func, wait, args);
        });
        var flow = createFlow();
        var flowRight = createFlow(true);
        function memoize(func, resolver) {
            if (typeof func != 'function' || resolver && typeof resolver != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            var memoized = function () {
                var args = arguments, cache = memoized.cache, key = resolver ? resolver.apply(this, args) : args[0];
                if (cache.has(key)) {
                    return cache.get(key);
                }
                var result = func.apply(this, args);
                cache.set(key, result);
                return result;
            };
            memoized.cache = new memoize.Cache();
            return memoized;
        }
        function negate(predicate) {
            if (typeof predicate != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            return function () {
                return !predicate.apply(this, arguments);
            };
        }
        function once(func) {
            return before(2, func);
        }
        var partial = createPartial(PARTIAL_FLAG);
        var partialRight = createPartial(PARTIAL_RIGHT_FLAG);
        var rearg = restParam(function (func, indexes) {
            return createWrapper(func, REARG_FLAG, null, null, null, baseFlatten(indexes));
        });
        function restParam(func, start) {
            if (typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            start = nativeMax(start === undefined ? func.length - 1 : +start || 0, 0);
            return function () {
                var args = arguments, index = -1, length = nativeMax(args.length - start, 0), rest = Array(length);
                while (++index < length) {
                    rest[index] = args[start + index];
                }
                switch (start) {
                case 0:
                    return func.call(this, rest);
                case 1:
                    return func.call(this, args[0], rest);
                case 2:
                    return func.call(this, args[0], args[1], rest);
                }
                var otherArgs = Array(start + 1);
                index = -1;
                while (++index < start) {
                    otherArgs[index] = args[index];
                }
                otherArgs[start] = rest;
                return func.apply(this, otherArgs);
            };
        }
        function spread(func) {
            if (typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            return function (array) {
                return func.apply(this, array);
            };
        }
        function throttle(func, wait, options) {
            var leading = true, trailing = true;
            if (typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            if (options === false) {
                leading = false;
            } else if (isObject(options)) {
                leading = 'leading' in options ? !!options.leading : leading;
                trailing = 'trailing' in options ? !!options.trailing : trailing;
            }
            debounceOptions.leading = leading;
            debounceOptions.maxWait = +wait;
            debounceOptions.trailing = trailing;
            return debounce(func, wait, debounceOptions);
        }
        function wrap(value, wrapper) {
            wrapper = wrapper == null ? identity : wrapper;
            return createWrapper(wrapper, PARTIAL_FLAG, null, [value], []);
        }
        function clone(value, isDeep, customizer, thisArg) {
            if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
                isDeep = false;
            } else if (typeof isDeep == 'function') {
                thisArg = customizer;
                customizer = isDeep;
                isDeep = false;
            }
            customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);
            return baseClone(value, isDeep, customizer);
        }
        function cloneDeep(value, customizer, thisArg) {
            customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);
            return baseClone(value, true, customizer);
        }
        function isArguments(value) {
            return isObjectLike(value) && isArrayLike(value) && objToString.call(value) == argsTag;
        }
        var isArray = nativeIsArray || function (value) {
            return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
        };
        function isBoolean(value) {
            return value === true || value === false || isObjectLike(value) && objToString.call(value) == boolTag;
        }
        function isDate(value) {
            return isObjectLike(value) && objToString.call(value) == dateTag;
        }
        function isElement(value) {
            return !!value && value.nodeType === 1 && isObjectLike(value) && objToString.call(value).indexOf('Element') > -1;
        }
        if (!support.dom) {
            isElement = function (value) {
                return !!value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value);
            };
        }
        function isEmpty(value) {
            if (value == null) {
                return true;
            }
            if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) || isObjectLike(value) && isFunction(value.splice))) {
                return !value.length;
            }
            return !keys(value).length;
        }
        function isEqual(value, other, customizer, thisArg) {
            customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 3);
            if (!customizer && isStrictComparable(value) && isStrictComparable(other)) {
                return value === other;
            }
            var result = customizer ? customizer(value, other) : undefined;
            return result === undefined ? baseIsEqual(value, other, customizer) : !!result;
        }
        function isError(value) {
            return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;
        }
        var isFinite = nativeNumIsFinite || function (value) {
            return typeof value == 'number' && nativeIsFinite(value);
        };
        var isFunction = !(baseIsFunction(/x/) || Uint8Array && !baseIsFunction(Uint8Array)) ? baseIsFunction : function (value) {
            return objToString.call(value) == funcTag;
        };
        function isObject(value) {
            var type = typeof value;
            return type == 'function' || !!value && type == 'object';
        }
        function isMatch(object, source, customizer, thisArg) {
            var props = keys(source), length = props.length;
            if (!length) {
                return true;
            }
            if (object == null) {
                return false;
            }
            customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 3);
            object = toObject(object);
            if (!customizer && length == 1) {
                var key = props[0], value = source[key];
                if (isStrictComparable(value)) {
                    return value === object[key] && (value !== undefined || key in object);
                }
            }
            var values = Array(length), strictCompareFlags = Array(length);
            while (length--) {
                value = values[length] = source[props[length]];
                strictCompareFlags[length] = isStrictComparable(value);
            }
            return baseIsMatch(object, props, values, strictCompareFlags, customizer);
        }
        function isNaN(value) {
            return isNumber(value) && value != +value;
        }
        function isNative(value) {
            if (value == null) {
                return false;
            }
            if (objToString.call(value) == funcTag) {
                return reIsNative.test(fnToString.call(value));
            }
            return isObjectLike(value) && reIsHostCtor.test(value);
        }
        function isNull(value) {
            return value === null;
        }
        function isNumber(value) {
            return typeof value == 'number' || isObjectLike(value) && objToString.call(value) == numberTag;
        }
        var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function (value) {
            if (!(value && objToString.call(value) == objectTag)) {
                return false;
            }
            var valueOf = value.valueOf, objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
            return objProto ? value == objProto || getPrototypeOf(value) == objProto : shimIsPlainObject(value);
        };
        function isRegExp(value) {
            return isObjectLike(value) && objToString.call(value) == regexpTag;
        }
        function isString(value) {
            return typeof value == 'string' || isObjectLike(value) && objToString.call(value) == stringTag;
        }
        function isTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
        }
        function isUndefined(value) {
            return value === undefined;
        }
        function toArray(value) {
            var length = value ? getLength(value) : 0;
            if (!isLength(length)) {
                return values(value);
            }
            if (!length) {
                return [];
            }
            return arrayCopy(value);
        }
        function toPlainObject(value) {
            return baseCopy(value, keysIn(value));
        }
        var assign = createAssigner(function (object, source, customizer) {
            return customizer ? assignWith(object, source, customizer) : baseAssign(object, source);
        });
        function create(prototype, properties, guard) {
            var result = baseCreate(prototype);
            if (guard && isIterateeCall(prototype, properties, guard)) {
                properties = null;
            }
            return properties ? baseAssign(result, properties) : result;
        }
        var defaults = restParam(function (args) {
            var object = args[0];
            if (object == null) {
                return object;
            }
            args.push(assignDefaults);
            return assign.apply(undefined, args);
        });
        var findKey = createFindKey(baseForOwn);
        var findLastKey = createFindKey(baseForOwnRight);
        var forIn = createForIn(baseFor);
        var forInRight = createForIn(baseForRight);
        var forOwn = createForOwn(baseForOwn);
        var forOwnRight = createForOwn(baseForOwnRight);
        function functions(object) {
            return baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
            var result = object == null ? undefined : baseGet(object, toPath(path), path + '');
            return result === undefined ? defaultValue : result;
        }
        function has(object, path) {
            if (object == null) {
                return false;
            }
            var result = hasOwnProperty.call(object, path);
            if (!result && !isKey(path)) {
                path = toPath(path);
                object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
                path = last(path);
                result = object != null && hasOwnProperty.call(object, path);
            }
            return result;
        }
        function invert(object, multiValue, guard) {
            if (guard && isIterateeCall(object, multiValue, guard)) {
                multiValue = null;
            }
            var index = -1, props = keys(object), length = props.length, result = {};
            while (++index < length) {
                var key = props[index], value = object[key];
                if (multiValue) {
                    if (hasOwnProperty.call(result, value)) {
                        result[value].push(key);
                    } else {
                        result[value] = [key];
                    }
                } else {
                    result[value] = key;
                }
            }
            return result;
        }
        var keys = !nativeKeys ? shimKeys : function (object) {
            var Ctor = object != null && object.constructor;
            if (typeof Ctor == 'function' && Ctor.prototype === object || typeof object != 'function' && isArrayLike(object)) {
                return shimKeys(object);
            }
            return isObject(object) ? nativeKeys(object) : [];
        };
        function keysIn(object) {
            if (object == null) {
                return [];
            }
            if (!isObject(object)) {
                object = Object(object);
            }
            var length = object.length;
            length = length && isLength(length) && (isArray(object) || support.nonEnumArgs && isArguments(object)) && length || 0;
            var Ctor = object.constructor, index = -1, isProto = typeof Ctor == 'function' && Ctor.prototype === object, result = Array(length), skipIndexes = length > 0;
            while (++index < length) {
                result[index] = index + '';
            }
            for (var key in object) {
                if (!(skipIndexes && isIndex(key, length)) && !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
                    result.push(key);
                }
            }
            return result;
        }
        var mapKeys = createObjectMapper(true);
        var mapValues = createObjectMapper();
        var merge = createAssigner(baseMerge);
        var omit = restParam(function (object, props) {
            if (object == null) {
                return {};
            }
            if (typeof props[0] != 'function') {
                var props = arrayMap(baseFlatten(props), String);
                return pickByArray(object, baseDifference(keysIn(object), props));
            }
            var predicate = bindCallback(props[0], props[1], 3);
            return pickByCallback(object, function (value, key, object) {
                return !predicate(value, key, object);
            });
        });
        function pairs(object) {
            var index = -1, props = keys(object), length = props.length, result = Array(length);
            while (++index < length) {
                var key = props[index];
                result[index] = [
                    key,
                    object[key]
                ];
            }
            return result;
        }
        var pick = restParam(function (object, props) {
            if (object == null) {
                return {};
            }
            return typeof props[0] == 'function' ? pickByCallback(object, bindCallback(props[0], props[1], 3)) : pickByArray(object, baseFlatten(props));
        });
        function result(object, path, defaultValue) {
            var result = object == null ? undefined : object[path];
            if (result === undefined) {
                if (object != null && !isKey(path, object)) {
                    path = toPath(path);
                    object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
                    result = object == null ? undefined : object[last(path)];
                }
                result = result === undefined ? defaultValue : result;
            }
            return isFunction(result) ? result.call(object) : result;
        }
        function set(object, path, value) {
            if (object == null) {
                return object;
            }
            var pathKey = path + '';
            path = object[pathKey] != null || isKey(path, object) ? [pathKey] : toPath(path);
            var index = -1, length = path.length, endIndex = length - 1, nested = object;
            while (nested != null && ++index < length) {
                var key = path[index];
                if (isObject(nested)) {
                    if (index == endIndex) {
                        nested[key] = value;
                    } else if (nested[key] == null) {
                        nested[key] = isIndex(path[index + 1]) ? [] : {};
                    }
                }
                nested = nested[key];
            }
            return object;
        }
        function transform(object, iteratee, accumulator, thisArg) {
            var isArr = isArray(object) || isTypedArray(object);
            iteratee = getCallback(iteratee, thisArg, 4);
            if (accumulator == null) {
                if (isArr || isObject(object)) {
                    var Ctor = object.constructor;
                    if (isArr) {
                        accumulator = isArray(object) ? new Ctor() : [];
                    } else {
                        accumulator = baseCreate(isFunction(Ctor) && Ctor.prototype);
                    }
                } else {
                    accumulator = {};
                }
            }
            (isArr ? arrayEach : baseForOwn)(object, function (value, index, object) {
                return iteratee(accumulator, value, index, object);
            });
            return accumulator;
        }
        function values(object) {
            return baseValues(object, keys(object));
        }
        function valuesIn(object) {
            return baseValues(object, keysIn(object));
        }
        function inRange(value, start, end) {
            start = +start || 0;
            if (typeof end === 'undefined') {
                end = start;
                start = 0;
            } else {
                end = +end || 0;
            }
            return value >= nativeMin(start, end) && value < nativeMax(start, end);
        }
        function random(min, max, floating) {
            if (floating && isIterateeCall(min, max, floating)) {
                max = floating = null;
            }
            var noMin = min == null, noMax = max == null;
            if (floating == null) {
                if (noMax && typeof min == 'boolean') {
                    floating = min;
                    min = 1;
                } else if (typeof max == 'boolean') {
                    floating = max;
                    noMax = true;
                }
            }
            if (noMin && noMax) {
                max = 1;
                noMax = false;
            }
            min = +min || 0;
            if (noMax) {
                max = min;
                min = 0;
            } else {
                max = +max || 0;
            }
            if (floating || min % 1 || max % 1) {
                var rand = nativeRandom();
                return nativeMin(min + rand * (max - min + parseFloat('1e-' + ((rand + '').length - 1))), max);
            }
            return baseRandom(min, max);
        }
        var camelCase = createCompounder(function (result, word, index) {
            word = word.toLowerCase();
            return result + (index ? word.charAt(0).toUpperCase() + word.slice(1) : word);
        });
        function capitalize(string) {
            string = baseToString(string);
            return string && string.charAt(0).toUpperCase() + string.slice(1);
        }
        function deburr(string) {
            string = baseToString(string);
            return string && string.replace(reLatin1, deburrLetter).replace(reComboMark, '');
        }
        function endsWith(string, target, position) {
            string = baseToString(string);
            target = target + '';
            var length = string.length;
            position = position === undefined ? length : nativeMin(position < 0 ? 0 : +position || 0, length);
            position -= target.length;
            return position >= 0 && string.indexOf(target, position) == position;
        }
        function escape(string) {
            string = baseToString(string);
            return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
            string = baseToString(string);
            return string && reHasRegExpChars.test(string) ? string.replace(reRegExpChars, '\\$&') : string;
        }
        var kebabCase = createCompounder(function (result, word, index) {
            return result + (index ? '-' : '') + word.toLowerCase();
        });
        function pad(string, length, chars) {
            string = baseToString(string);
            length = +length;
            var strLength = string.length;
            if (strLength >= length || !nativeIsFinite(length)) {
                return string;
            }
            var mid = (length - strLength) / 2, leftLength = floor(mid), rightLength = ceil(mid);
            chars = createPadding('', rightLength, chars);
            return chars.slice(0, leftLength) + string + chars;
        }
        var padLeft = createPadDir();
        var padRight = createPadDir(true);
        function parseInt(string, radix, guard) {
            if (guard && isIterateeCall(string, radix, guard)) {
                radix = 0;
            }
            return nativeParseInt(string, radix);
        }
        if (nativeParseInt(whitespace + '08') != 8) {
            parseInt = function (string, radix, guard) {
                if (guard ? isIterateeCall(string, radix, guard) : radix == null) {
                    radix = 0;
                } else if (radix) {
                    radix = +radix;
                }
                string = trim(string);
                return nativeParseInt(string, radix || (reHasHexPrefix.test(string) ? 16 : 10));
            };
        }
        function repeat(string, n) {
            var result = '';
            string = baseToString(string);
            n = +n;
            if (n < 1 || !string || !nativeIsFinite(n)) {
                return result;
            }
            do {
                if (n % 2) {
                    result += string;
                }
                n = floor(n / 2);
                string += string;
            } while (n);
            return result;
        }
        var snakeCase = createCompounder(function (result, word, index) {
            return result + (index ? '_' : '') + word.toLowerCase();
        });
        var startCase = createCompounder(function (result, word, index) {
            return result + (index ? ' ' : '') + (word.charAt(0).toUpperCase() + word.slice(1));
        });
        function startsWith(string, target, position) {
            string = baseToString(string);
            position = position == null ? 0 : nativeMin(position < 0 ? 0 : +position || 0, string.length);
            return string.lastIndexOf(target, position) == position;
        }
        function template(string, options, otherOptions) {
            var settings = lodash.templateSettings;
            if (otherOptions && isIterateeCall(string, options, otherOptions)) {
                options = otherOptions = null;
            }
            string = baseToString(string);
            options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);
            var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
            var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = '__p += \'';
            var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g');
            var sourceURL = '//# sourceURL=' + ('sourceURL' in options ? options.sourceURL : 'lodash.templateSources[' + ++templateCounter + ']') + '\n';
            string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                interpolateValue || (interpolateValue = esTemplateValue);
                source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
                if (escapeValue) {
                    isEscaping = true;
                    source += '\' +\n__e(' + escapeValue + ') +\n\'';
                }
                if (evaluateValue) {
                    isEvaluating = true;
                    source += '\';\n' + evaluateValue + ';\n__p += \'';
                }
                if (interpolateValue) {
                    source += '\' +\n((__t = (' + interpolateValue + ')) == null ? \'\' : __t) +\n\'';
                }
                index = offset + match.length;
                return match;
            });
            source += '\';\n';
            var variable = options.variable;
            if (!variable) {
                source = 'with (obj) {\n' + source + '\n}\n';
            }
            source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;');
            source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + 'var __t, __p = \'\'' + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ', __j = Array.prototype.join;\n' + 'function print() { __p += __j.call(arguments, \'\') }\n' : ';\n') + source + 'return __p\n}';
            var result = attempt(function () {
                return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
            });
            result.source = source;
            if (isError(result)) {
                throw result;
            }
            return result;
        }
        function trim(string, chars, guard) {
            var value = string;
            string = baseToString(string);
            if (!string) {
                return string;
            }
            if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
                return string.slice(trimmedLeftIndex(string), trimmedRightIndex(string) + 1);
            }
            chars = chars + '';
            return string.slice(charsLeftIndex(string, chars), charsRightIndex(string, chars) + 1);
        }
        function trimLeft(string, chars, guard) {
            var value = string;
            string = baseToString(string);
            if (!string) {
                return string;
            }
            if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
                return string.slice(trimmedLeftIndex(string));
            }
            return string.slice(charsLeftIndex(string, chars + ''));
        }
        function trimRight(string, chars, guard) {
            var value = string;
            string = baseToString(string);
            if (!string) {
                return string;
            }
            if (guard ? isIterateeCall(value, chars, guard) : chars == null) {
                return string.slice(0, trimmedRightIndex(string) + 1);
            }
            return string.slice(0, charsRightIndex(string, chars + '') + 1);
        }
        function trunc(string, options, guard) {
            if (guard && isIterateeCall(string, options, guard)) {
                options = null;
            }
            var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
            if (options != null) {
                if (isObject(options)) {
                    var separator = 'separator' in options ? options.separator : separator;
                    length = 'length' in options ? +options.length || 0 : length;
                    omission = 'omission' in options ? baseToString(options.omission) : omission;
                } else {
                    length = +options || 0;
                }
            }
            string = baseToString(string);
            if (length >= string.length) {
                return string;
            }
            var end = length - omission.length;
            if (end < 1) {
                return omission;
            }
            var result = string.slice(0, end);
            if (separator == null) {
                return result + omission;
            }
            if (isRegExp(separator)) {
                if (string.slice(end).search(separator)) {
                    var match, newEnd, substring = string.slice(0, end);
                    if (!separator.global) {
                        separator = RegExp(separator.source, (reFlags.exec(separator) || '') + 'g');
                    }
                    separator.lastIndex = 0;
                    while (match = separator.exec(substring)) {
                        newEnd = match.index;
                    }
                    result = result.slice(0, newEnd == null ? end : newEnd);
                }
            } else if (string.indexOf(separator, end) != end) {
                var index = result.lastIndexOf(separator);
                if (index > -1) {
                    result = result.slice(0, index);
                }
            }
            return result + omission;
        }
        function unescape(string) {
            string = baseToString(string);
            return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        function words(string, pattern, guard) {
            if (guard && isIterateeCall(string, pattern, guard)) {
                pattern = null;
            }
            string = baseToString(string);
            return string.match(pattern || reWords) || [];
        }
        var attempt = restParam(function (func, args) {
            try {
                return func.apply(undefined, args);
            } catch (e) {
                return isError(e) ? e : new Error(e);
            }
        });
        function callback(func, thisArg, guard) {
            if (guard && isIterateeCall(func, thisArg, guard)) {
                thisArg = null;
            }
            return isObjectLike(func) ? matches(func) : baseCallback(func, thisArg);
        }
        function constant(value) {
            return function () {
                return value;
            };
        }
        function identity(value) {
            return value;
        }
        function matches(source) {
            return baseMatches(baseClone(source, true));
        }
        function matchesProperty(path, value) {
            return baseMatchesProperty(path, baseClone(value, true));
        }
        var method = restParam(function (path, args) {
            return function (object) {
                return invokePath(object, path, args);
            };
        });
        var methodOf = restParam(function (object, args) {
            return function (path) {
                return invokePath(object, path, args);
            };
        });
        function mixin(object, source, options) {
            if (options == null) {
                var isObj = isObject(source), props = isObj && keys(source), methodNames = props && props.length && baseFunctions(source, props);
                if (!(methodNames ? methodNames.length : isObj)) {
                    methodNames = false;
                    options = source;
                    source = object;
                    object = this;
                }
            }
            if (!methodNames) {
                methodNames = baseFunctions(source, keys(source));
            }
            var chain = true, index = -1, isFunc = isFunction(object), length = methodNames.length;
            if (options === false) {
                chain = false;
            } else if (isObject(options) && 'chain' in options) {
                chain = options.chain;
            }
            while (++index < length) {
                var methodName = methodNames[index], func = source[methodName];
                object[methodName] = func;
                if (isFunc) {
                    object.prototype[methodName] = function (func) {
                        return function () {
                            var chainAll = this.__chain__;
                            if (chain || chainAll) {
                                var result = object(this.__wrapped__), actions = result.__actions__ = arrayCopy(this.__actions__);
                                actions.push({
                                    'func': func,
                                    'args': arguments,
                                    'thisArg': object
                                });
                                result.__chain__ = chainAll;
                                return result;
                            }
                            var args = [this.value()];
                            push.apply(args, arguments);
                            return func.apply(object, args);
                        };
                    }(func);
                }
            }
            return object;
        }
        function noConflict() {
            context._ = oldDash;
            return this;
        }
        function noop() {
        }
        function property(path) {
            return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
        }
        function propertyOf(object) {
            return function (path) {
                return baseGet(object, toPath(path), path + '');
            };
        }
        function range(start, end, step) {
            if (step && isIterateeCall(start, end, step)) {
                end = step = null;
            }
            start = +start || 0;
            step = step == null ? 1 : +step || 0;
            if (end == null) {
                end = start;
                start = 0;
            } else {
                end = +end || 0;
            }
            var index = -1, length = nativeMax(ceil((end - start) / (step || 1)), 0), result = Array(length);
            while (++index < length) {
                result[index] = start;
                start += step;
            }
            return result;
        }
        function times(n, iteratee, thisArg) {
            n = floor(n);
            if (n < 1 || !nativeIsFinite(n)) {
                return [];
            }
            var index = -1, result = Array(nativeMin(n, MAX_ARRAY_LENGTH));
            iteratee = bindCallback(iteratee, thisArg, 1);
            while (++index < n) {
                if (index < MAX_ARRAY_LENGTH) {
                    result[index] = iteratee(index);
                } else {
                    iteratee(index);
                }
            }
            return result;
        }
        function uniqueId(prefix) {
            var id = ++idCounter;
            return baseToString(prefix) + id;
        }
        function add(augend, addend) {
            return (+augend || 0) + (+addend || 0);
        }
        var max = createExtremum(arrayMax);
        var min = createExtremum(arrayMin, true);
        function sum(collection, iteratee, thisArg) {
            if (thisArg && isIterateeCall(collection, iteratee, thisArg)) {
                iteratee = null;
            }
            var func = getCallback(), noIteratee = iteratee == null;
            if (!(func === baseCallback && noIteratee)) {
                noIteratee = false;
                iteratee = func(iteratee, thisArg, 3);
            }
            return noIteratee ? arraySum(isArray(collection) ? collection : toIterable(collection)) : baseSum(collection, iteratee);
        }
        lodash.prototype = baseLodash.prototype;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        MapCache.prototype['delete'] = mapDelete;
        MapCache.prototype.get = mapGet;
        MapCache.prototype.has = mapHas;
        MapCache.prototype.set = mapSet;
        SetCache.prototype.push = cachePush;
        memoize.Cache = MapCache;
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.callback = callback;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.functions = functions;
        lodash.groupBy = groupBy;
        lodash.indexBy = indexBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.invert = invert;
        lodash.invoke = invoke;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.omit = omit;
        lodash.once = once;
        lodash.pairs = pairs;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pluck = pluck;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.restParam = restParam;
        lodash.set = set;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortByAll = sortByAll;
        lodash.sortByOrder = sortByOrder;
        lodash.spread = spread;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.times = times;
        lodash.toArray = toArray;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.union = union;
        lodash.uniq = uniq;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.where = where;
        lodash.without = without;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipWith = zipWith;
        lodash.backflow = flowRight;
        lodash.collect = map;
        lodash.compose = flowRight;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.extend = assign;
        lodash.iteratee = callback;
        lodash.methods = functions;
        lodash.object = zipObject;
        lodash.select = filter;
        lodash.tail = rest;
        lodash.unique = uniq;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.deburr = deburr;
        lodash.endsWith = endsWith;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.findWhere = findWhere;
        lodash.first = first;
        lodash.get = get;
        lodash.has = has;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isBoolean = isBoolean;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isError = isError;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isMatch = isMatch;
        lodash.isNaN = isNaN;
        lodash.isNative = isNative;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isString = isString;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.max = max;
        lodash.min = min;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padLeft = padLeft;
        lodash.padRight = padRight;
        lodash.parseInt = parseInt;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.result = result;
        lodash.runInContext = runInContext;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.sum = sum;
        lodash.template = template;
        lodash.trim = trim;
        lodash.trimLeft = trimLeft;
        lodash.trimRight = trimRight;
        lodash.trunc = trunc;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.words = words;
        lodash.all = every;
        lodash.any = some;
        lodash.contains = includes;
        lodash.detect = find;
        lodash.foldl = reduce;
        lodash.foldr = reduceRight;
        lodash.head = first;
        lodash.include = includes;
        lodash.inject = reduce;
        mixin(lodash, function () {
            var source = {};
            baseForOwn(lodash, function (func, methodName) {
                if (!lodash.prototype[methodName]) {
                    source[methodName] = func;
                }
            });
            return source;
        }(), false);
        lodash.sample = sample;
        lodash.prototype.sample = function (n) {
            if (!this.__chain__ && n == null) {
                return sample(this.value());
            }
            return this.thru(function (value) {
                return sample(value, n);
            });
        };
        lodash.VERSION = VERSION;
        arrayEach([
            'bind',
            'bindKey',
            'curry',
            'curryRight',
            'partial',
            'partialRight'
        ], function (methodName) {
            lodash[methodName].placeholder = lodash;
        });
        arrayEach([
            'dropWhile',
            'filter',
            'map',
            'takeWhile'
        ], function (methodName, type) {
            var isFilter = type != LAZY_MAP_FLAG, isDropWhile = type == LAZY_DROP_WHILE_FLAG;
            LazyWrapper.prototype[methodName] = function (iteratee, thisArg) {
                var filtered = this.__filtered__, result = filtered && isDropWhile ? new LazyWrapper(this) : this.clone(), iteratees = result.__iteratees__ || (result.__iteratees__ = []);
                iteratees.push({
                    'done': false,
                    'count': 0,
                    'index': 0,
                    'iteratee': getCallback(iteratee, thisArg, 1),
                    'limit': -1,
                    'type': type
                });
                result.__filtered__ = filtered || isFilter;
                return result;
            };
        });
        arrayEach([
            'drop',
            'take'
        ], function (methodName, index) {
            var whileName = methodName + 'While';
            LazyWrapper.prototype[methodName] = function (n) {
                var filtered = this.__filtered__, result = filtered && !index ? this.dropWhile() : this.clone();
                n = n == null ? 1 : nativeMax(floor(n) || 0, 0);
                if (filtered) {
                    if (index) {
                        result.__takeCount__ = nativeMin(result.__takeCount__, n);
                    } else {
                        last(result.__iteratees__).limit = n;
                    }
                } else {
                    var views = result.__views__ || (result.__views__ = []);
                    views.push({
                        'size': n,
                        'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
                    });
                }
                return result;
            };
            LazyWrapper.prototype[methodName + 'Right'] = function (n) {
                return this.reverse()[methodName](n).reverse();
            };
            LazyWrapper.prototype[methodName + 'RightWhile'] = function (predicate, thisArg) {
                return this.reverse()[whileName](predicate, thisArg).reverse();
            };
        });
        arrayEach([
            'first',
            'last'
        ], function (methodName, index) {
            var takeName = 'take' + (index ? 'Right' : '');
            LazyWrapper.prototype[methodName] = function () {
                return this[takeName](1).value()[0];
            };
        });
        arrayEach([
            'initial',
            'rest'
        ], function (methodName, index) {
            var dropName = 'drop' + (index ? '' : 'Right');
            LazyWrapper.prototype[methodName] = function () {
                return this[dropName](1);
            };
        });
        arrayEach([
            'pluck',
            'where'
        ], function (methodName, index) {
            var operationName = index ? 'filter' : 'map', createCallback = index ? baseMatches : property;
            LazyWrapper.prototype[methodName] = function (value) {
                return this[operationName](createCallback(value));
            };
        });
        LazyWrapper.prototype.compact = function () {
            return this.filter(identity);
        };
        LazyWrapper.prototype.reject = function (predicate, thisArg) {
            predicate = getCallback(predicate, thisArg, 1);
            return this.filter(function (value) {
                return !predicate(value);
            });
        };
        LazyWrapper.prototype.slice = function (start, end) {
            start = start == null ? 0 : +start || 0;
            var result = this;
            if (start < 0) {
                result = this.takeRight(-start);
            } else if (start) {
                result = this.drop(start);
            }
            if (end !== undefined) {
                end = +end || 0;
                result = end < 0 ? result.dropRight(-end) : result.take(end - start);
            }
            return result;
        };
        LazyWrapper.prototype.toArray = function () {
            return this.drop(0);
        };
        baseForOwn(LazyWrapper.prototype, function (func, methodName) {
            var lodashFunc = lodash[methodName];
            if (!lodashFunc) {
                return;
            }
            var checkIteratee = /^(?:filter|map|reject)|While$/.test(methodName), retUnwrapped = /^(?:first|last)$/.test(methodName);
            lodash.prototype[methodName] = function () {
                var args = arguments, chainAll = this.__chain__, value = this.__wrapped__, isHybrid = !!this.__actions__.length, isLazy = value instanceof LazyWrapper, iteratee = args[0], useLazy = isLazy || isArray(value);
                if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
                    isLazy = useLazy = false;
                }
                var onlyLazy = isLazy && !isHybrid;
                if (retUnwrapped && !chainAll) {
                    return onlyLazy ? func.call(value) : lodashFunc.call(lodash, this.value());
                }
                var interceptor = function (value) {
                    var otherArgs = [value];
                    push.apply(otherArgs, args);
                    return lodashFunc.apply(lodash, otherArgs);
                };
                if (useLazy) {
                    var wrapper = onlyLazy ? value : new LazyWrapper(this), result = func.apply(wrapper, args);
                    if (!retUnwrapped && (isHybrid || result.__actions__)) {
                        var actions = result.__actions__ || (result.__actions__ = []);
                        actions.push({
                            'func': thru,
                            'args': [interceptor],
                            'thisArg': lodash
                        });
                    }
                    return new LodashWrapper(result, chainAll);
                }
                return this.thru(interceptor);
            };
        });
        arrayEach([
            'concat',
            'join',
            'pop',
            'push',
            'replace',
            'shift',
            'sort',
            'splice',
            'split',
            'unshift'
        ], function (methodName) {
            var func = (/^(?:replace|split)$/.test(methodName) ? stringProto : arrayProto)[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru', retUnwrapped = /^(?:join|pop|replace|shift)$/.test(methodName);
            lodash.prototype[methodName] = function () {
                var args = arguments;
                if (retUnwrapped && !this.__chain__) {
                    return func.apply(this.value(), args);
                }
                return this[chainName](function (value) {
                    return func.apply(value, args);
                });
            };
        });
        baseForOwn(LazyWrapper.prototype, function (func, methodName) {
            var lodashFunc = lodash[methodName];
            if (lodashFunc) {
                var key = lodashFunc.name, names = realNames[key] || (realNames[key] = []);
                names.push({
                    'name': methodName,
                    'func': lodashFunc
                });
            }
        });
        realNames[createHybridWrapper(null, BIND_KEY_FLAG).name] = [{
                'name': 'wrapper',
                'func': null
            }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toString = wrapperToString;
        lodash.prototype.run = lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.collect = lodash.prototype.map;
        lodash.prototype.head = lodash.prototype.first;
        lodash.prototype.select = lodash.prototype.filter;
        lodash.prototype.tail = lodash.prototype.rest;
        return lodash;
    }
    var _ = runInContext();
    if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
        root._ = _;
        define('lodash', [], function () {
            return _;
        });
    } else if (freeExports && freeModule) {
        if (moduleExports) {
            (freeModule.exports = _)._ = _;
        } else {
            freeExports._ = _;
        }
    } else {
        root._ = _;
    }
}.call(this));
define('chiasm', [
    'model',
    'lodash',
    'require'
], function (Model, _, require) {
    var ErrorMessages = {
        missingDefault: 'Default value for public property \'${ property }\' ' + 'not specified for component with alias \'${ alias }\'.',
        componentTimeout: 'Component with alias \'${ alias }\' does not exist ' + 'after timeout of ${ seconds } seconds exceeded.'
    };
    function createError(type, values) {
        return Error(_.template(ErrorMessages[type])(values));
    }
    var Action = {
        create: function (alias, plugin) {
            return {
                method: 'create',
                alias: alias,
                plugin: plugin
            };
        },
        destroy: function (alias) {
            return {
                method: 'destroy',
                alias: alias
            };
        },
        set: function (alias, property, value) {
            return {
                method: 'set',
                alias: alias,
                property: property,
                value: value
            };
        },
        unset: function (alias, property) {
            return {
                method: 'unset',
                alias: alias,
                property: property
            };
        },
        toString: function (action) {
            return [
                action.method + '(',
                action.alias,
                action.property !== undefined ? ', ' + action.property : '',
                action.value !== undefined ? ', ' + action.value : '',
                action.plugin !== undefined ? ', ' + action.plugin : '',
                ')'
            ].join('');
        }
    };
    function configDiff(oldConfig, newConfig) {
        var actions = [], newAliases = _.keys(newConfig), oldAliases = _.keys(oldConfig);
        _.difference(oldAliases, newAliases).forEach(function (alias) {
            actions.push(Action.destroy(alias));
        });
        newAliases.forEach(function (alias) {
            var oldModel = alias in oldConfig ? oldConfig[alias].state || {} : null, newModel = newConfig[alias].state || {}, oldProperties = oldModel ? _.keys(oldModel) : [], newProperties = _.keys(newModel), oldPlugin = alias in oldConfig ? oldConfig[alias].plugin : null, newPlugin = newConfig[alias].plugin;
            if (oldModel && oldPlugin !== newPlugin) {
                actions.push(Action.destroy(alias));
                oldModel = null;
                oldProperties = [];
            }
            if (!oldModel) {
                actions.push(Action.create(alias, newConfig[alias].plugin));
            }
            _.difference(newProperties, oldProperties).forEach(function (property) {
                actions.push(Action.set(alias, property, newModel[property]));
            });
            _.difference(oldProperties, newProperties).forEach(function (property) {
                actions.push(Action.unset(alias, property));
            });
            _.intersection(newProperties, oldProperties).forEach(function (property) {
                if (!_.isEqual(oldModel[property], newModel[property])) {
                    actions.push(Action.set(alias, property, newModel[property]));
                }
            });
        });
        return actions;
    }
    function Queue(process) {
        var ready = Promise.resolve(null);
        return function (items) {
            return new Promise(function (resolve, reject) {
                items.forEach(function (item) {
                    ready = ready.then(function () {
                        return process(item);
                    });
                });
                ready = ready.then(resolve, reject);
            });
        };
    }
    function Chiasm(container) {
        var chiasm = Model({
            plugins: {},
            config: {},
            timeout: 10000,
            container: container
        });
        var components = {};
        var defaults = {};
        var methods = {
            create: function (action) {
                return create(action.alias, action.plugin);
            },
            destroy: function (action) {
                return destroy(action.alias);
            },
            set: function (action) {
                return set(action.alias, action.property, action.value);
            },
            unset: function (action) {
                return unset(action.alias, action.property);
            }
        };
        var queue = Queue(function (action) {
            return methods[action.method](action);
        });
        var callbacks = {};
        var settingProperty = false;
        var settingConfig = false;
        function getComponent(alias) {
            var startTime = Date.now();
            return new Promise(function (resolve, reject) {
                (function poll() {
                    if (alias in components) {
                        resolve(components[alias]);
                    } else if (Date.now() - startTime < chiasm.timeout) {
                        setTimeout(poll, 1);
                    } else {
                        reject(createError('componentTimeout', {
                            alias: alias,
                            seconds: chiasm.timeout / 1000
                        }));
                    }
                }());
            });
        }
        function loadPlugin(plugin) {
            return new Promise(function (resolve, reject) {
                if (plugin in chiasm.plugins) {
                    resolve(chiasm.plugins[plugin]);
                } else {
                    require([plugin], resolve, reject);
                }
            });
        }
        function create(alias, plugin) {
            return new Promise(function (resolve, reject) {
                loadPlugin(plugin).then(function (constructor) {
                    try {
                        var component = constructor(chiasm);
                        components[alias] = component;
                        defaults[alias] = {};
                        if ('publicProperties' in component) {
                            component.publicProperties.forEach(function (property) {
                                if (component[property] === undefined) {
                                    throw createError('missingDefault', {
                                        property: property,
                                        alias: alias
                                    });
                                }
                                defaults[alias][property] = component[property];
                            });
                            callbacks[alias] = component.publicProperties.map(function (property) {
                                var callback = function (newValue) {
                                    if (!settingProperty) {
                                        if (!('state' in chiasm.config[alias])) {
                                            chiasm.config[alias].state = {};
                                        }
                                        chiasm.config[alias].state[property] = newValue;
                                        chiasm.config = chiasm.config;
                                    }
                                };
                                component.on(property, callback);
                                return {
                                    property: property,
                                    callback: callback
                                };
                            });
                        }
                        resolve();
                    } catch (err) {
                        reject(err);
                    }
                }, reject);
            });
        }
        function destroy(alias) {
            return new Promise(function (resolve, reject) {
                getComponent(alias).then(function (component) {
                    if (alias in callbacks) {
                        callbacks[alias].forEach(function (cb) {
                            component.off(cb.property, cb.callback);
                        });
                        delete callbacks[alias];
                    }
                    if ('destroy' in component) {
                        component.destroy();
                    }
                    delete components[alias];
                    delete defaults[alias];
                    resolve();
                }, reject);
            });
        }
        function set(alias, property, value) {
            return new Promise(function (resolve, reject) {
                getComponent(alias).then(function (component) {
                    if (defaults[alias] && defaults[alias][property] !== undefined) {
                        settingProperty = true;
                        component[property] = value;
                        settingProperty = false;
                        resolve();
                    } else {
                        reject(createError('missingDefault', {
                            property: property,
                            alias: alias
                        }));
                    }
                }, reject);
            });
        }
        function unset(alias, property, callback) {
            return new Promise(function (resolve, reject) {
                getComponent(alias).then(function (component) {
                    settingProperty = true;
                    component[property] = defaults[alias][property];
                    settingProperty = false;
                    resolve();
                }, reject);
            });
        }
        chiasm.on('config', function (newConfig, oldConfig) {
            if (!settingConfig) {
                setConfig(newConfig, oldConfig);
            }
        });
        function setConfig(newConfig, oldConfig) {
            oldConfig = oldConfig || chiasm.config;
            var actions = configDiff(oldConfig, newConfig);
            if (actions.length > 0) {
                settingConfig = true;
                chiasm.config = _.cloneDeep(newConfig);
                settingConfig = false;
                return queue(actions);
            } else {
                return Promise.resolve(null);
            }
        }
        chiasm.getComponent = getComponent;
        chiasm.setConfig = setConfig;
        chiasm.componentExists = function (alias) {
            return alias in components;
        };
        return chiasm;
    }
    Chiasm.configDiff = configDiff;
    Chiasm.Action = Action;
    return Chiasm;
});
!function () {
    var d3 = { version: '3.5.5' };
    var d3_arraySlice = [].slice, d3_array = function (list) {
            return d3_arraySlice.call(list);
        };
    var d3_document = this.document;
    function d3_documentElement(node) {
        return node && (node.ownerDocument || node.document || node).documentElement;
    }
    function d3_window(node) {
        return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
    }
    if (d3_document) {
        try {
            d3_array(d3_document.documentElement.childNodes)[0].nodeType;
        } catch (e) {
            d3_array = function (list) {
                var i = list.length, array = new Array(i);
                while (i--)
                    array[i] = list[i];
                return array;
            };
        }
    }
    if (!Date.now)
        Date.now = function () {
            return +new Date();
        };
    if (d3_document) {
        try {
            d3_document.createElement('DIV').style.setProperty('opacity', 0, '');
        } catch (error) {
            var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
            d3_element_prototype.setAttribute = function (name, value) {
                d3_element_setAttribute.call(this, name, value + '');
            };
            d3_element_prototype.setAttributeNS = function (space, local, value) {
                d3_element_setAttributeNS.call(this, space, local, value + '');
            };
            d3_style_prototype.setProperty = function (name, value, priority) {
                d3_style_setProperty.call(this, name, value + '', priority);
            };
        }
    }
    d3.ascending = d3_ascending;
    function d3_ascending(a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }
    d3.descending = function (a, b) {
        return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
    };
    d3.min = function (array, f) {
        var i = -1, n = array.length, a, b;
        if (arguments.length === 1) {
            while (++i < n)
                if ((b = array[i]) != null && b >= b) {
                    a = b;
                    break;
                }
            while (++i < n)
                if ((b = array[i]) != null && a > b)
                    a = b;
        } else {
            while (++i < n)
                if ((b = f.call(array, array[i], i)) != null && b >= b) {
                    a = b;
                    break;
                }
            while (++i < n)
                if ((b = f.call(array, array[i], i)) != null && a > b)
                    a = b;
        }
        return a;
    };
    d3.max = function (array, f) {
        var i = -1, n = array.length, a, b;
        if (arguments.length === 1) {
            while (++i < n)
                if ((b = array[i]) != null && b >= b) {
                    a = b;
                    break;
                }
            while (++i < n)
                if ((b = array[i]) != null && b > a)
                    a = b;
        } else {
            while (++i < n)
                if ((b = f.call(array, array[i], i)) != null && b >= b) {
                    a = b;
                    break;
                }
            while (++i < n)
                if ((b = f.call(array, array[i], i)) != null && b > a)
                    a = b;
        }
        return a;
    };
    d3.extent = function (array, f) {
        var i = -1, n = array.length, a, b, c;
        if (arguments.length === 1) {
            while (++i < n)
                if ((b = array[i]) != null && b >= b) {
                    a = c = b;
                    break;
                }
            while (++i < n)
                if ((b = array[i]) != null) {
                    if (a > b)
                        a = b;
                    if (c < b)
                        c = b;
                }
        } else {
            while (++i < n)
                if ((b = f.call(array, array[i], i)) != null && b >= b) {
                    a = c = b;
                    break;
                }
            while (++i < n)
                if ((b = f.call(array, array[i], i)) != null) {
                    if (a > b)
                        a = b;
                    if (c < b)
                        c = b;
                }
        }
        return [
            a,
            c
        ];
    };
    function d3_number(x) {
        return x === null ? NaN : +x;
    }
    function d3_numeric(x) {
        return !isNaN(x);
    }
    d3.sum = function (array, f) {
        var s = 0, n = array.length, a, i = -1;
        if (arguments.length === 1) {
            while (++i < n)
                if (d3_numeric(a = +array[i]))
                    s += a;
        } else {
            while (++i < n)
                if (d3_numeric(a = +f.call(array, array[i], i)))
                    s += a;
        }
        return s;
    };
    d3.mean = function (array, f) {
        var s = 0, n = array.length, a, i = -1, j = n;
        if (arguments.length === 1) {
            while (++i < n)
                if (d3_numeric(a = d3_number(array[i])))
                    s += a;
                else
                    --j;
        } else {
            while (++i < n)
                if (d3_numeric(a = d3_number(f.call(array, array[i], i))))
                    s += a;
                else
                    --j;
        }
        if (j)
            return s / j;
    };
    d3.quantile = function (values, p) {
        var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
        return e ? v + e * (values[h] - v) : v;
    };
    d3.median = function (array, f) {
        var numbers = [], n = array.length, a, i = -1;
        if (arguments.length === 1) {
            while (++i < n)
                if (d3_numeric(a = d3_number(array[i])))
                    numbers.push(a);
        } else {
            while (++i < n)
                if (d3_numeric(a = d3_number(f.call(array, array[i], i))))
                    numbers.push(a);
        }
        if (numbers.length)
            return d3.quantile(numbers.sort(d3_ascending), 0.5);
    };
    d3.variance = function (array, f) {
        var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;
        if (arguments.length === 1) {
            while (++i < n) {
                if (d3_numeric(a = d3_number(array[i]))) {
                    d = a - m;
                    m += d / ++j;
                    s += d * (a - m);
                }
            }
        } else {
            while (++i < n) {
                if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {
                    d = a - m;
                    m += d / ++j;
                    s += d * (a - m);
                }
            }
        }
        if (j > 1)
            return s / (j - 1);
    };
    d3.deviation = function () {
        var v = d3.variance.apply(this, arguments);
        return v ? Math.sqrt(v) : v;
    };
    function d3_bisector(compare) {
        return {
            left: function (a, x, lo, hi) {
                if (arguments.length < 3)
                    lo = 0;
                if (arguments.length < 4)
                    hi = a.length;
                while (lo < hi) {
                    var mid = lo + hi >>> 1;
                    if (compare(a[mid], x) < 0)
                        lo = mid + 1;
                    else
                        hi = mid;
                }
                return lo;
            },
            right: function (a, x, lo, hi) {
                if (arguments.length < 3)
                    lo = 0;
                if (arguments.length < 4)
                    hi = a.length;
                while (lo < hi) {
                    var mid = lo + hi >>> 1;
                    if (compare(a[mid], x) > 0)
                        hi = mid;
                    else
                        lo = mid + 1;
                }
                return lo;
            }
        };
    }
    var d3_bisect = d3_bisector(d3_ascending);
    d3.bisectLeft = d3_bisect.left;
    d3.bisect = d3.bisectRight = d3_bisect.right;
    d3.bisector = function (f) {
        return d3_bisector(f.length === 1 ? function (d, x) {
            return d3_ascending(f(d), x);
        } : f);
    };
    d3.shuffle = function (array, i0, i1) {
        if ((m = arguments.length) < 3) {
            i1 = array.length;
            if (m < 2)
                i0 = 0;
        }
        var m = i1 - i0, t, i;
        while (m) {
            i = Math.random() * m-- | 0;
            t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
        }
        return array;
    };
    d3.permute = function (array, indexes) {
        var i = indexes.length, permutes = new Array(i);
        while (i--)
            permutes[i] = array[indexes[i]];
        return permutes;
    };
    d3.pairs = function (array) {
        var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);
        while (i < n)
            pairs[i] = [
                p0 = p1,
                p1 = array[++i]
            ];
        return pairs;
    };
    d3.zip = function () {
        if (!(n = arguments.length))
            return [];
        for (var i = -1, m = d3.min(arguments, d3_zipLength), zips = new Array(m); ++i < m;) {
            for (var j = -1, n, zip = zips[i] = new Array(n); ++j < n;) {
                zip[j] = arguments[j][i];
            }
        }
        return zips;
    };
    function d3_zipLength(d) {
        return d.length;
    }
    d3.transpose = function (matrix) {
        return d3.zip.apply(d3, matrix);
    };
    d3.keys = function (map) {
        var keys = [];
        for (var key in map)
            keys.push(key);
        return keys;
    };
    d3.values = function (map) {
        var values = [];
        for (var key in map)
            values.push(map[key]);
        return values;
    };
    d3.entries = function (map) {
        var entries = [];
        for (var key in map)
            entries.push({
                key: key,
                value: map[key]
            });
        return entries;
    };
    d3.merge = function (arrays) {
        var n = arrays.length, m, i = -1, j = 0, merged, array;
        while (++i < n)
            j += arrays[i].length;
        merged = new Array(j);
        while (--n >= 0) {
            array = arrays[n];
            m = array.length;
            while (--m >= 0) {
                merged[--j] = array[m];
            }
        }
        return merged;
    };
    var abs = Math.abs;
    d3.range = function (start, stop, step) {
        if (arguments.length < 3) {
            step = 1;
            if (arguments.length < 2) {
                stop = start;
                start = 0;
            }
        }
        if ((stop - start) / step === Infinity)
            throw new Error('infinite range');
        var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
        start *= k, stop *= k, step *= k;
        if (step < 0)
            while ((j = start + step * ++i) > stop)
                range.push(j / k);
        else
            while ((j = start + step * ++i) < stop)
                range.push(j / k);
        return range;
    };
    function d3_range_integerScale(x) {
        var k = 1;
        while (x * k % 1)
            k *= 10;
        return k;
    }
    function d3_class(ctor, properties) {
        for (var key in properties) {
            Object.defineProperty(ctor.prototype, key, {
                value: properties[key],
                enumerable: false
            });
        }
    }
    d3.map = function (object, f) {
        var map = new d3_Map();
        if (object instanceof d3_Map) {
            object.forEach(function (key, value) {
                map.set(key, value);
            });
        } else if (Array.isArray(object)) {
            var i = -1, n = object.length, o;
            if (arguments.length === 1)
                while (++i < n)
                    map.set(i, object[i]);
            else
                while (++i < n)
                    map.set(f.call(object, o = object[i], i), o);
        } else {
            for (var key in object)
                map.set(key, object[key]);
        }
        return map;
    };
    function d3_Map() {
        this._ = Object.create(null);
    }
    var d3_map_proto = '__proto__', d3_map_zero = '\0';
    d3_class(d3_Map, {
        has: d3_map_has,
        get: function (key) {
            return this._[d3_map_escape(key)];
        },
        set: function (key, value) {
            return this._[d3_map_escape(key)] = value;
        },
        remove: d3_map_remove,
        keys: d3_map_keys,
        values: function () {
            var values = [];
            for (var key in this._)
                values.push(this._[key]);
            return values;
        },
        entries: function () {
            var entries = [];
            for (var key in this._)
                entries.push({
                    key: d3_map_unescape(key),
                    value: this._[key]
                });
            return entries;
        },
        size: d3_map_size,
        empty: d3_map_empty,
        forEach: function (f) {
            for (var key in this._)
                f.call(this, d3_map_unescape(key), this._[key]);
        }
    });
    function d3_map_escape(key) {
        return (key += '') === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
    }
    function d3_map_unescape(key) {
        return (key += '')[0] === d3_map_zero ? key.slice(1) : key;
    }
    function d3_map_has(key) {
        return d3_map_escape(key) in this._;
    }
    function d3_map_remove(key) {
        return (key = d3_map_escape(key)) in this._ && delete this._[key];
    }
    function d3_map_keys() {
        var keys = [];
        for (var key in this._)
            keys.push(d3_map_unescape(key));
        return keys;
    }
    function d3_map_size() {
        var size = 0;
        for (var key in this._)
            ++size;
        return size;
    }
    function d3_map_empty() {
        for (var key in this._)
            return false;
        return true;
    }
    d3.nest = function () {
        var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
        function map(mapType, array, depth) {
            if (depth >= keys.length)
                return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
            var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
            while (++i < n) {
                if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
                    values.push(object);
                } else {
                    valuesByKey.set(keyValue, [object]);
                }
            }
            if (mapType) {
                object = mapType();
                setter = function (keyValue, values) {
                    object.set(keyValue, map(mapType, values, depth));
                };
            } else {
                object = {};
                setter = function (keyValue, values) {
                    object[keyValue] = map(mapType, values, depth);
                };
            }
            valuesByKey.forEach(setter);
            return object;
        }
        function entries(map, depth) {
            if (depth >= keys.length)
                return map;
            var array = [], sortKey = sortKeys[depth++];
            map.forEach(function (key, keyMap) {
                array.push({
                    key: key,
                    values: entries(keyMap, depth)
                });
            });
            return sortKey ? array.sort(function (a, b) {
                return sortKey(a.key, b.key);
            }) : array;
        }
        nest.map = function (array, mapType) {
            return map(mapType, array, 0);
        };
        nest.entries = function (array) {
            return entries(map(d3.map, array, 0), 0);
        };
        nest.key = function (d) {
            keys.push(d);
            return nest;
        };
        nest.sortKeys = function (order) {
            sortKeys[keys.length - 1] = order;
            return nest;
        };
        nest.sortValues = function (order) {
            sortValues = order;
            return nest;
        };
        nest.rollup = function (f) {
            rollup = f;
            return nest;
        };
        return nest;
    };
    d3.set = function (array) {
        var set = new d3_Set();
        if (array)
            for (var i = 0, n = array.length; i < n; ++i)
                set.add(array[i]);
        return set;
    };
    function d3_Set() {
        this._ = Object.create(null);
    }
    d3_class(d3_Set, {
        has: d3_map_has,
        add: function (key) {
            this._[d3_map_escape(key += '')] = true;
            return key;
        },
        remove: d3_map_remove,
        values: d3_map_keys,
        size: d3_map_size,
        empty: d3_map_empty,
        forEach: function (f) {
            for (var key in this._)
                f.call(this, d3_map_unescape(key));
        }
    });
    d3.behavior = {};
    function d3_identity(d) {
        return d;
    }
    d3.rebind = function (target, source) {
        var i = 1, n = arguments.length, method;
        while (++i < n)
            target[method = arguments[i]] = d3_rebind(target, source, source[method]);
        return target;
    };
    function d3_rebind(target, source, method) {
        return function () {
            var value = method.apply(source, arguments);
            return value === source ? target : value;
        };
    }
    function d3_vendorSymbol(object, name) {
        if (name in object)
            return name;
        name = name.charAt(0).toUpperCase() + name.slice(1);
        for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
            var prefixName = d3_vendorPrefixes[i] + name;
            if (prefixName in object)
                return prefixName;
        }
    }
    var d3_vendorPrefixes = [
        'webkit',
        'ms',
        'moz',
        'Moz',
        'o',
        'O'
    ];
    function d3_noop() {
    }
    d3.dispatch = function () {
        var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
        while (++i < n)
            dispatch[arguments[i]] = d3_dispatch_event(dispatch);
        return dispatch;
    };
    function d3_dispatch() {
    }
    d3_dispatch.prototype.on = function (type, listener) {
        var i = type.indexOf('.'), name = '';
        if (i >= 0) {
            name = type.slice(i + 1);
            type = type.slice(0, i);
        }
        if (type)
            return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
        if (arguments.length === 2) {
            if (listener == null)
                for (type in this) {
                    if (this.hasOwnProperty(type))
                        this[type].on(name, null);
                }
            return this;
        }
    };
    function d3_dispatch_event(dispatch) {
        var listeners = [], listenerByName = new d3_Map();
        function event() {
            var z = listeners, i = -1, n = z.length, l;
            while (++i < n)
                if (l = z[i].on)
                    l.apply(this, arguments);
            return dispatch;
        }
        event.on = function (name, listener) {
            var l = listenerByName.get(name), i;
            if (arguments.length < 2)
                return l && l.on;
            if (l) {
                l.on = null;
                listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
                listenerByName.remove(name);
            }
            if (listener)
                listeners.push(listenerByName.set(name, { on: listener }));
            return dispatch;
        };
        return event;
    }
    d3.event = null;
    function d3_eventPreventDefault() {
        d3.event.preventDefault();
    }
    function d3_eventSource() {
        var e = d3.event, s;
        while (s = e.sourceEvent)
            e = s;
        return e;
    }
    function d3_eventDispatch(target) {
        var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
        while (++i < n)
            dispatch[arguments[i]] = d3_dispatch_event(dispatch);
        dispatch.of = function (thiz, argumentz) {
            return function (e1) {
                try {
                    var e0 = e1.sourceEvent = d3.event;
                    e1.target = target;
                    d3.event = e1;
                    dispatch[e1.type].apply(thiz, argumentz);
                } finally {
                    d3.event = e0;
                }
            };
        };
        return dispatch;
    }
    d3.requote = function (s) {
        return s.replace(d3_requote_re, '\\$&');
    };
    var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
    var d3_subclass = {}.__proto__ ? function (object, prototype) {
        object.__proto__ = prototype;
    } : function (object, prototype) {
        for (var property in prototype)
            object[property] = prototype[property];
    };
    function d3_selection(groups) {
        d3_subclass(groups, d3_selectionPrototype);
        return groups;
    }
    var d3_select = function (s, n) {
            return n.querySelector(s);
        }, d3_selectAll = function (s, n) {
            return n.querySelectorAll(s);
        }, d3_selectMatches = function (n, s) {
            var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, 'matchesSelector')];
            d3_selectMatches = function (n, s) {
                return d3_selectMatcher.call(n, s);
            };
            return d3_selectMatches(n, s);
        };
    if (typeof Sizzle === 'function') {
        d3_select = function (s, n) {
            return Sizzle(s, n)[0] || null;
        };
        d3_selectAll = Sizzle;
        d3_selectMatches = Sizzle.matchesSelector;
    }
    d3.selection = function () {
        return d3.select(d3_document.documentElement);
    };
    var d3_selectionPrototype = d3.selection.prototype = [];
    d3_selectionPrototype.select = function (selector) {
        var subgroups = [], subgroup, subnode, group, node;
        selector = d3_selection_selector(selector);
        for (var j = -1, m = this.length; ++j < m;) {
            subgroups.push(subgroup = []);
            subgroup.parentNode = (group = this[j]).parentNode;
            for (var i = -1, n = group.length; ++i < n;) {
                if (node = group[i]) {
                    subgroup.push(subnode = selector.call(node, node.__data__, i, j));
                    if (subnode && '__data__' in node)
                        subnode.__data__ = node.__data__;
                } else {
                    subgroup.push(null);
                }
            }
        }
        return d3_selection(subgroups);
    };
    function d3_selection_selector(selector) {
        return typeof selector === 'function' ? selector : function () {
            return d3_select(selector, this);
        };
    }
    d3_selectionPrototype.selectAll = function (selector) {
        var subgroups = [], subgroup, node;
        selector = d3_selection_selectorAll(selector);
        for (var j = -1, m = this.length; ++j < m;) {
            for (var group = this[j], i = -1, n = group.length; ++i < n;) {
                if (node = group[i]) {
                    subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
                    subgroup.parentNode = node;
                }
            }
        }
        return d3_selection(subgroups);
    };
    function d3_selection_selectorAll(selector) {
        return typeof selector === 'function' ? selector : function () {
            return d3_selectAll(selector, this);
        };
    }
    var d3_nsPrefix = {
        svg: 'http://www.w3.org/2000/svg',
        xhtml: 'http://www.w3.org/1999/xhtml',
        xlink: 'http://www.w3.org/1999/xlink',
        xml: 'http://www.w3.org/XML/1998/namespace',
        xmlns: 'http://www.w3.org/2000/xmlns/'
    };
    d3.ns = {
        prefix: d3_nsPrefix,
        qualify: function (name) {
            var i = name.indexOf(':'), prefix = name;
            if (i >= 0) {
                prefix = name.slice(0, i);
                name = name.slice(i + 1);
            }
            return d3_nsPrefix.hasOwnProperty(prefix) ? {
                space: d3_nsPrefix[prefix],
                local: name
            } : name;
        }
    };
    d3_selectionPrototype.attr = function (name, value) {
        if (arguments.length < 2) {
            if (typeof name === 'string') {
                var node = this.node();
                name = d3.ns.qualify(name);
                return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
            }
            for (value in name)
                this.each(d3_selection_attr(value, name[value]));
            return this;
        }
        return this.each(d3_selection_attr(name, value));
    };
    function d3_selection_attr(name, value) {
        name = d3.ns.qualify(name);
        function attrNull() {
            this.removeAttribute(name);
        }
        function attrNullNS() {
            this.removeAttributeNS(name.space, name.local);
        }
        function attrConstant() {
            this.setAttribute(name, value);
        }
        function attrConstantNS() {
            this.setAttributeNS(name.space, name.local, value);
        }
        function attrFunction() {
            var x = value.apply(this, arguments);
            if (x == null)
                this.removeAttribute(name);
            else
                this.setAttribute(name, x);
        }
        function attrFunctionNS() {
            var x = value.apply(this, arguments);
            if (x == null)
                this.removeAttributeNS(name.space, name.local);
            else
                this.setAttributeNS(name.space, name.local, x);
        }
        return value == null ? name.local ? attrNullNS : attrNull : typeof value === 'function' ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
    }
    function d3_collapse(s) {
        return s.trim().replace(/\s+/g, ' ');
    }
    d3_selectionPrototype.classed = function (name, value) {
        if (arguments.length < 2) {
            if (typeof name === 'string') {
                var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;
                if (value = node.classList) {
                    while (++i < n)
                        if (!value.contains(name[i]))
                            return false;
                } else {
                    value = node.getAttribute('class');
                    while (++i < n)
                        if (!d3_selection_classedRe(name[i]).test(value))
                            return false;
                }
                return true;
            }
            for (value in name)
                this.each(d3_selection_classed(value, name[value]));
            return this;
        }
        return this.each(d3_selection_classed(name, value));
    };
    function d3_selection_classedRe(name) {
        return new RegExp('(?:^|\\s+)' + d3.requote(name) + '(?:\\s+|$)', 'g');
    }
    function d3_selection_classes(name) {
        return (name + '').trim().split(/^|\s+/);
    }
    function d3_selection_classed(name, value) {
        name = d3_selection_classes(name).map(d3_selection_classedName);
        var n = name.length;
        function classedConstant() {
            var i = -1;
            while (++i < n)
                name[i](this, value);
        }
        function classedFunction() {
            var i = -1, x = value.apply(this, arguments);
            while (++i < n)
                name[i](this, x);
        }
        return typeof value === 'function' ? classedFunction : classedConstant;
    }
    function d3_selection_classedName(name) {
        var re = d3_selection_classedRe(name);
        return function (node, value) {
            if (c = node.classList)
                return value ? c.add(name) : c.remove(name);
            var c = node.getAttribute('class') || '';
            if (value) {
                re.lastIndex = 0;
                if (!re.test(c))
                    node.setAttribute('class', d3_collapse(c + ' ' + name));
            } else {
                node.setAttribute('class', d3_collapse(c.replace(re, ' ')));
            }
        };
    }
    d3_selectionPrototype.style = function (name, value, priority) {
        var n = arguments.length;
        if (n < 3) {
            if (typeof name !== 'string') {
                if (n < 2)
                    value = '';
                for (priority in name)
                    this.each(d3_selection_style(priority, name[priority], value));
                return this;
            }
            if (n < 2) {
                var node = this.node();
                return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);
            }
            priority = '';
        }
        return this.each(d3_selection_style(name, value, priority));
    };
    function d3_selection_style(name, value, priority) {
        function styleNull() {
            this.style.removeProperty(name);
        }
        function styleConstant() {
            this.style.setProperty(name, value, priority);
        }
        function styleFunction() {
            var x = value.apply(this, arguments);
            if (x == null)
                this.style.removeProperty(name);
            else
                this.style.setProperty(name, x, priority);
        }
        return value == null ? styleNull : typeof value === 'function' ? styleFunction : styleConstant;
    }
    d3_selectionPrototype.property = function (name, value) {
        if (arguments.length < 2) {
            if (typeof name === 'string')
                return this.node()[name];
            for (value in name)
                this.each(d3_selection_property(value, name[value]));
            return this;
        }
        return this.each(d3_selection_property(name, value));
    };
    function d3_selection_property(name, value) {
        function propertyNull() {
            delete this[name];
        }
        function propertyConstant() {
            this[name] = value;
        }
        function propertyFunction() {
            var x = value.apply(this, arguments);
            if (x == null)
                delete this[name];
            else
                this[name] = x;
        }
        return value == null ? propertyNull : typeof value === 'function' ? propertyFunction : propertyConstant;
    }
    d3_selectionPrototype.text = function (value) {
        return arguments.length ? this.each(typeof value === 'function' ? function () {
            var v = value.apply(this, arguments);
            this.textContent = v == null ? '' : v;
        } : value == null ? function () {
            this.textContent = '';
        } : function () {
            this.textContent = value;
        }) : this.node().textContent;
    };
    d3_selectionPrototype.html = function (value) {
        return arguments.length ? this.each(typeof value === 'function' ? function () {
            var v = value.apply(this, arguments);
            this.innerHTML = v == null ? '' : v;
        } : value == null ? function () {
            this.innerHTML = '';
        } : function () {
            this.innerHTML = value;
        }) : this.node().innerHTML;
    };
    d3_selectionPrototype.append = function (name) {
        name = d3_selection_creator(name);
        return this.select(function () {
            return this.appendChild(name.apply(this, arguments));
        });
    };
    function d3_selection_creator(name) {
        function create() {
            var document = this.ownerDocument, namespace = this.namespaceURI;
            return namespace ? document.createElementNS(namespace, name) : document.createElement(name);
        }
        function createNS() {
            return this.ownerDocument.createElementNS(name.space, name.local);
        }
        return typeof name === 'function' ? name : (name = d3.ns.qualify(name)).local ? createNS : create;
    }
    d3_selectionPrototype.insert = function (name, before) {
        name = d3_selection_creator(name);
        before = d3_selection_selector(before);
        return this.select(function () {
            return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
        });
    };
    d3_selectionPrototype.remove = function () {
        return this.each(d3_selectionRemove);
    };
    function d3_selectionRemove() {
        var parent = this.parentNode;
        if (parent)
            parent.removeChild(this);
    }
    d3_selectionPrototype.data = function (value, key) {
        var i = -1, n = this.length, group, node;
        if (!arguments.length) {
            value = new Array(n = (group = this[0]).length);
            while (++i < n) {
                if (node = group[i]) {
                    value[i] = node.__data__;
                }
            }
            return value;
        }
        function bind(group, groupData) {
            var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
            if (key) {
                var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;
                for (i = -1; ++i < n;) {
                    if (nodeByKeyValue.has(keyValue = key.call(node = group[i], node.__data__, i))) {
                        exitNodes[i] = node;
                    } else {
                        nodeByKeyValue.set(keyValue, node);
                    }
                    keyValues[i] = keyValue;
                }
                for (i = -1; ++i < m;) {
                    if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {
                        enterNodes[i] = d3_selection_dataNode(nodeData);
                    } else if (node !== true) {
                        updateNodes[i] = node;
                        node.__data__ = nodeData;
                    }
                    nodeByKeyValue.set(keyValue, true);
                }
                for (i = -1; ++i < n;) {
                    if (nodeByKeyValue.get(keyValues[i]) !== true) {
                        exitNodes[i] = group[i];
                    }
                }
            } else {
                for (i = -1; ++i < n0;) {
                    node = group[i];
                    nodeData = groupData[i];
                    if (node) {
                        node.__data__ = nodeData;
                        updateNodes[i] = node;
                    } else {
                        enterNodes[i] = d3_selection_dataNode(nodeData);
                    }
                }
                for (; i < m; ++i) {
                    enterNodes[i] = d3_selection_dataNode(groupData[i]);
                }
                for (; i < n; ++i) {
                    exitNodes[i] = group[i];
                }
            }
            enterNodes.update = updateNodes;
            enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
            enter.push(enterNodes);
            update.push(updateNodes);
            exit.push(exitNodes);
        }
        var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
        if (typeof value === 'function') {
            while (++i < n) {
                bind(group = this[i], value.call(group, group.parentNode.__data__, i));
            }
        } else {
            while (++i < n) {
                bind(group = this[i], value);
            }
        }
        update.enter = function () {
            return enter;
        };
        update.exit = function () {
            return exit;
        };
        return update;
    };
    function d3_selection_dataNode(data) {
        return { __data__: data };
    }
    d3_selectionPrototype.datum = function (value) {
        return arguments.length ? this.property('__data__', value) : this.property('__data__');
    };
    d3_selectionPrototype.filter = function (filter) {
        var subgroups = [], subgroup, group, node;
        if (typeof filter !== 'function')
            filter = d3_selection_filter(filter);
        for (var j = 0, m = this.length; j < m; j++) {
            subgroups.push(subgroup = []);
            subgroup.parentNode = (group = this[j]).parentNode;
            for (var i = 0, n = group.length; i < n; i++) {
                if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
                    subgroup.push(node);
                }
            }
        }
        return d3_selection(subgroups);
    };
    function d3_selection_filter(selector) {
        return function () {
            return d3_selectMatches(this, selector);
        };
    }
    d3_selectionPrototype.order = function () {
        for (var j = -1, m = this.length; ++j < m;) {
            for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
                if (node = group[i]) {
                    if (next && next !== node.nextSibling)
                        next.parentNode.insertBefore(node, next);
                    next = node;
                }
            }
        }
        return this;
    };
    d3_selectionPrototype.sort = function (comparator) {
        comparator = d3_selection_sortComparator.apply(this, arguments);
        for (var j = -1, m = this.length; ++j < m;)
            this[j].sort(comparator);
        return this.order();
    };
    function d3_selection_sortComparator(comparator) {
        if (!arguments.length)
            comparator = d3_ascending;
        return function (a, b) {
            return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
        };
    }
    d3_selectionPrototype.each = function (callback) {
        return d3_selection_each(this, function (node, i, j) {
            callback.call(node, node.__data__, i, j);
        });
    };
    function d3_selection_each(groups, callback) {
        for (var j = 0, m = groups.length; j < m; j++) {
            for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
                if (node = group[i])
                    callback(node, i, j);
            }
        }
        return groups;
    }
    d3_selectionPrototype.call = function (callback) {
        var args = d3_array(arguments);
        callback.apply(args[0] = this, args);
        return this;
    };
    d3_selectionPrototype.empty = function () {
        return !this.node();
    };
    d3_selectionPrototype.node = function () {
        for (var j = 0, m = this.length; j < m; j++) {
            for (var group = this[j], i = 0, n = group.length; i < n; i++) {
                var node = group[i];
                if (node)
                    return node;
            }
        }
        return null;
    };
    d3_selectionPrototype.size = function () {
        var n = 0;
        d3_selection_each(this, function () {
            ++n;
        });
        return n;
    };
    function d3_selection_enter(selection) {
        d3_subclass(selection, d3_selection_enterPrototype);
        return selection;
    }
    var d3_selection_enterPrototype = [];
    d3.selection.enter = d3_selection_enter;
    d3.selection.enter.prototype = d3_selection_enterPrototype;
    d3_selection_enterPrototype.append = d3_selectionPrototype.append;
    d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
    d3_selection_enterPrototype.node = d3_selectionPrototype.node;
    d3_selection_enterPrototype.call = d3_selectionPrototype.call;
    d3_selection_enterPrototype.size = d3_selectionPrototype.size;
    d3_selection_enterPrototype.select = function (selector) {
        var subgroups = [], subgroup, subnode, upgroup, group, node;
        for (var j = -1, m = this.length; ++j < m;) {
            upgroup = (group = this[j]).update;
            subgroups.push(subgroup = []);
            subgroup.parentNode = group.parentNode;
            for (var i = -1, n = group.length; ++i < n;) {
                if (node = group[i]) {
                    subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
                    subnode.__data__ = node.__data__;
                } else {
                    subgroup.push(null);
                }
            }
        }
        return d3_selection(subgroups);
    };
    d3_selection_enterPrototype.insert = function (name, before) {
        if (arguments.length < 2)
            before = d3_selection_enterInsertBefore(this);
        return d3_selectionPrototype.insert.call(this, name, before);
    };
    function d3_selection_enterInsertBefore(enter) {
        var i0, j0;
        return function (d, i, j) {
            var group = enter[j].update, n = group.length, node;
            if (j != j0)
                j0 = j, i0 = 0;
            if (i >= i0)
                i0 = i + 1;
            while (!(node = group[i0]) && ++i0 < n);
            return node;
        };
    }
    d3.select = function (node) {
        var group;
        if (typeof node === 'string') {
            group = [d3_select(node, d3_document)];
            group.parentNode = d3_document.documentElement;
        } else {
            group = [node];
            group.parentNode = d3_documentElement(node);
        }
        return d3_selection([group]);
    };
    d3.selectAll = function (nodes) {
        var group;
        if (typeof nodes === 'string') {
            group = d3_array(d3_selectAll(nodes, d3_document));
            group.parentNode = d3_document.documentElement;
        } else {
            group = nodes;
            group.parentNode = null;
        }
        return d3_selection([group]);
    };
    d3_selectionPrototype.on = function (type, listener, capture) {
        var n = arguments.length;
        if (n < 3) {
            if (typeof type !== 'string') {
                if (n < 2)
                    listener = false;
                for (capture in type)
                    this.each(d3_selection_on(capture, type[capture], listener));
                return this;
            }
            if (n < 2)
                return (n = this.node()['__on' + type]) && n._;
            capture = false;
        }
        return this.each(d3_selection_on(type, listener, capture));
    };
    function d3_selection_on(type, listener, capture) {
        var name = '__on' + type, i = type.indexOf('.'), wrap = d3_selection_onListener;
        if (i > 0)
            type = type.slice(0, i);
        var filter = d3_selection_onFilters.get(type);
        if (filter)
            type = filter, wrap = d3_selection_onFilter;
        function onRemove() {
            var l = this[name];
            if (l) {
                this.removeEventListener(type, l, l.$);
                delete this[name];
            }
        }
        function onAdd() {
            var l = wrap(listener, d3_array(arguments));
            onRemove.call(this);
            this.addEventListener(type, this[name] = l, l.$ = capture);
            l._ = listener;
        }
        function removeAll() {
            var re = new RegExp('^__on([^.]+)' + d3.requote(type) + '$'), match;
            for (var name in this) {
                if (match = name.match(re)) {
                    var l = this[name];
                    this.removeEventListener(match[1], l, l.$);
                    delete this[name];
                }
            }
        }
        return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
    }
    var d3_selection_onFilters = d3.map({
        mouseenter: 'mouseover',
        mouseleave: 'mouseout'
    });
    if (d3_document) {
        d3_selection_onFilters.forEach(function (k) {
            if ('on' + k in d3_document)
                d3_selection_onFilters.remove(k);
        });
    }
    function d3_selection_onListener(listener, argumentz) {
        return function (e) {
            var o = d3.event;
            d3.event = e;
            argumentz[0] = this.__data__;
            try {
                listener.apply(this, argumentz);
            } finally {
                d3.event = o;
            }
        };
    }
    function d3_selection_onFilter(listener, argumentz) {
        var l = d3_selection_onListener(listener, argumentz);
        return function (e) {
            var target = this, related = e.relatedTarget;
            if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
                l.call(target, e);
            }
        };
    }
    var d3_event_dragSelect, d3_event_dragId = 0;
    function d3_event_dragSuppress(node) {
        var name = '.dragsuppress-' + ++d3_event_dragId, click = 'click' + name, w = d3.select(d3_window(node)).on('touchmove' + name, d3_eventPreventDefault).on('dragstart' + name, d3_eventPreventDefault).on('selectstart' + name, d3_eventPreventDefault);
        if (d3_event_dragSelect == null) {
            d3_event_dragSelect = 'onselectstart' in node ? false : d3_vendorSymbol(node.style, 'userSelect');
        }
        if (d3_event_dragSelect) {
            var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];
            style[d3_event_dragSelect] = 'none';
        }
        return function (suppressClick) {
            w.on(name, null);
            if (d3_event_dragSelect)
                style[d3_event_dragSelect] = select;
            if (suppressClick) {
                var off = function () {
                    w.on(click, null);
                };
                w.on(click, function () {
                    d3_eventPreventDefault();
                    off();
                }, true);
                setTimeout(off, 0);
            }
        };
    }
    d3.mouse = function (container) {
        return d3_mousePoint(container, d3_eventSource());
    };
    var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
    function d3_mousePoint(container, e) {
        if (e.changedTouches)
            e = e.changedTouches[0];
        var svg = container.ownerSVGElement || container;
        if (svg.createSVGPoint) {
            var point = svg.createSVGPoint();
            if (d3_mouse_bug44083 < 0) {
                var window = d3_window(container);
                if (window.scrollX || window.scrollY) {
                    svg = d3.select('body').append('svg').style({
                        position: 'absolute',
                        top: 0,
                        left: 0,
                        margin: 0,
                        padding: 0,
                        border: 'none'
                    }, 'important');
                    var ctm = svg[0][0].getScreenCTM();
                    d3_mouse_bug44083 = !(ctm.f || ctm.e);
                    svg.remove();
                }
            }
            if (d3_mouse_bug44083)
                point.x = e.pageX, point.y = e.pageY;
            else
                point.x = e.clientX, point.y = e.clientY;
            point = point.matrixTransform(container.getScreenCTM().inverse());
            return [
                point.x,
                point.y
            ];
        }
        var rect = container.getBoundingClientRect();
        return [
            e.clientX - rect.left - container.clientLeft,
            e.clientY - rect.top - container.clientTop
        ];
    }
    d3.touch = function (container, touches, identifier) {
        if (arguments.length < 3)
            identifier = touches, touches = d3_eventSource().changedTouches;
        if (touches)
            for (var i = 0, n = touches.length, touch; i < n; ++i) {
                if ((touch = touches[i]).identifier === identifier) {
                    return d3_mousePoint(container, touch);
                }
            }
    };
    d3.behavior.drag = function () {
        var event = d3_eventDispatch(drag, 'drag', 'dragstart', 'dragend'), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, 'mousemove', 'mouseup'), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, 'touchmove', 'touchend');
        function drag() {
            this.on('mousedown.drag', mousedown).on('touchstart.drag', touchstart);
        }
        function dragstart(id, position, subject, move, end) {
            return function () {
                var that = this, target = d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = '.drag' + (dragId == null ? '' : '-' + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);
                if (origin) {
                    dragOffset = origin.apply(that, arguments);
                    dragOffset = [
                        dragOffset.x - position0[0],
                        dragOffset.y - position0[1]
                    ];
                } else {
                    dragOffset = [
                        0,
                        0
                    ];
                }
                dispatch({ type: 'dragstart' });
                function moved() {
                    var position1 = position(parent, dragId), dx, dy;
                    if (!position1)
                        return;
                    dx = position1[0] - position0[0];
                    dy = position1[1] - position0[1];
                    dragged |= dx | dy;
                    position0 = position1;
                    dispatch({
                        type: 'drag',
                        x: position1[0] + dragOffset[0],
                        y: position1[1] + dragOffset[1],
                        dx: dx,
                        dy: dy
                    });
                }
                function ended() {
                    if (!position(parent, dragId))
                        return;
                    dragSubject.on(move + dragName, null).on(end + dragName, null);
                    dragRestore(dragged && d3.event.target === target);
                    dispatch({ type: 'dragend' });
                }
            };
        }
        drag.origin = function (x) {
            if (!arguments.length)
                return origin;
            origin = x;
            return drag;
        };
        return d3.rebind(drag, event, 'on');
    };
    function d3_behavior_dragTouchId() {
        return d3.event.changedTouches[0].identifier;
    }
    d3.touches = function (container, touches) {
        if (arguments.length < 2)
            touches = d3_eventSource().touches;
        return touches ? d3_array(touches).map(function (touch) {
            var point = d3_mousePoint(container, touch);
            point.identifier = touch.identifier;
            return point;
        }) : [];
    };
    var  = 0.000001, 2 =  * ,  = Math.PI,  = 2 * ,  =  - , half =  / 2, d3_radians =  / 180, d3_degrees = 180 / ;
    function d3_sgn(x) {
        return x > 0 ? 1 : x < 0 ? -1 : 0;
    }
    function d3_cross2d(a, b, c) {
        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
    }
    function d3_acos(x) {
        return x > 1 ? 0 : x < -1 ?  : Math.acos(x);
    }
    function d3_asin(x) {
        return x > 1 ? half : x < -1 ? -half : Math.asin(x);
    }
    function d3_sinh(x) {
        return ((x = Math.exp(x)) - 1 / x) / 2;
    }
    function d3_cosh(x) {
        return ((x = Math.exp(x)) + 1 / x) / 2;
    }
    function d3_tanh(x) {
        return ((x = Math.exp(2 * x)) - 1) / (x + 1);
    }
    function d3_haversin(x) {
        return (x = Math.sin(x / 2)) * x;
    }
    var  = Math.SQRT2, 2 = 2, 4 = 4;
    d3.interpolateZoom = function (p0, p1) {
        var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2];
        var dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + 4 * d2) / (2 * w0 * 2 * d1), b1 = (w1 * w1 - w0 * w0 - 4 * d2) / (2 * w1 * 2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1), dr = r1 - r0, S = (dr || Math.log(w1 / w0)) / ;
        function interpolate(t) {
            var s = t * S;
            if (dr) {
                var coshr0 = d3_cosh(r0), u = w0 / (2 * d1) * (coshr0 * d3_tanh( * s + r0) - d3_sinh(r0));
                return [
                    ux0 + u * dx,
                    uy0 + u * dy,
                    w0 * coshr0 / d3_cosh( * s + r0)
                ];
            }
            return [
                ux0 + t * dx,
                uy0 + t * dy,
                w0 * Math.exp( * s)
            ];
        }
        interpolate.duration = S * 1000;
        return interpolate;
    };
    d3.behavior.zoom = function () {
        var view = {
                x: 0,
                y: 0,
                k: 1
            }, translate0, center0, center, size = [
                960,
                500
            ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = 'mousedown.zoom', mousemove = 'mousemove.zoom', mouseup = 'mouseup.zoom', mousewheelTimer, touchstart = 'touchstart.zoom', touchtime, event = d3_eventDispatch(zoom, 'zoomstart', 'zoom', 'zoomend'), x0, x1, y0, y1;
        if (!d3_behavior_zoomWheel) {
            d3_behavior_zoomWheel = 'onwheel' in d3_document ? (d3_behavior_zoomDelta = function () {
                return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
            }, 'wheel') : 'onmousewheel' in d3_document ? (d3_behavior_zoomDelta = function () {
                return d3.event.wheelDelta;
            }, 'mousewheel') : (d3_behavior_zoomDelta = function () {
                return -d3.event.detail;
            }, 'MozMousePixelScroll');
        }
        function zoom(g) {
            g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + '.zoom', mousewheeled).on('dblclick.zoom', dblclicked).on(touchstart, touchstarted);
        }
        zoom.event = function (g) {
            g.each(function () {
                var dispatch = event.of(this, arguments), view1 = view;
                if (d3_transitionInheritId) {
                    d3.select(this).transition().each('start.zoom', function () {
                        view = this.__chart__ || {
                            x: 0,
                            y: 0,
                            k: 1
                        };
                        zoomstarted(dispatch);
                    }).tween('zoom:zoom', function () {
                        var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([
                                (cx - view.x) / view.k,
                                (cy - view.y) / view.k,
                                dx / view.k
                            ], [
                                (cx - view1.x) / view1.k,
                                (cy - view1.y) / view1.k,
                                dx / view1.k
                            ]);
                        return function (t) {
                            var l = i(t), k = dx / l[2];
                            this.__chart__ = view = {
                                x: cx - l[0] * k,
                                y: cy - l[1] * k,
                                k: k
                            };
                            zoomed(dispatch);
                        };
                    }).each('interrupt.zoom', function () {
                        zoomended(dispatch);
                    }).each('end.zoom', function () {
                        zoomended(dispatch);
                    });
                } else {
                    this.__chart__ = view;
                    zoomstarted(dispatch);
                    zoomed(dispatch);
                    zoomended(dispatch);
                }
            });
        };
        zoom.translate = function (_) {
            if (!arguments.length)
                return [
                    view.x,
                    view.y
                ];
            view = {
                x: +_[0],
                y: +_[1],
                k: view.k
            };
            rescale();
            return zoom;
        };
        zoom.scale = function (_) {
            if (!arguments.length)
                return view.k;
            view = {
                x: view.x,
                y: view.y,
                k: +_
            };
            rescale();
            return zoom;
        };
        zoom.scaleExtent = function (_) {
            if (!arguments.length)
                return scaleExtent;
            scaleExtent = _ == null ? d3_behavior_zoomInfinity : [
                +_[0],
                +_[1]
            ];
            return zoom;
        };
        zoom.center = function (_) {
            if (!arguments.length)
                return center;
            center = _ && [
                +_[0],
                +_[1]
            ];
            return zoom;
        };
        zoom.size = function (_) {
            if (!arguments.length)
                return size;
            size = _ && [
                +_[0],
                +_[1]
            ];
            return zoom;
        };
        zoom.duration = function (_) {
            if (!arguments.length)
                return duration;
            duration = +_;
            return zoom;
        };
        zoom.x = function (z) {
            if (!arguments.length)
                return x1;
            x1 = z;
            x0 = z.copy();
            view = {
                x: 0,
                y: 0,
                k: 1
            };
            return zoom;
        };
        zoom.y = function (z) {
            if (!arguments.length)
                return y1;
            y1 = z;
            y0 = z.copy();
            view = {
                x: 0,
                y: 0,
                k: 1
            };
            return zoom;
        };
        function location(p) {
            return [
                (p[0] - view.x) / view.k,
                (p[1] - view.y) / view.k
            ];
        }
        function point(l) {
            return [
                l[0] * view.k + view.x,
                l[1] * view.k + view.y
            ];
        }
        function scaleTo(s) {
            view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
        }
        function translateTo(p, l) {
            l = point(l);
            view.x += p[0] - l[0];
            view.y += p[1] - l[1];
        }
        function zoomTo(that, p, l, k) {
            that.__chart__ = {
                x: view.x,
                y: view.y,
                k: view.k
            };
            scaleTo(Math.pow(2, k));
            translateTo(center0 = p, l);
            that = d3.select(that);
            if (duration > 0)
                that = that.transition().duration(duration);
            that.call(zoom.event);
        }
        function rescale() {
            if (x1)
                x1.domain(x0.range().map(function (x) {
                    return (x - view.x) / view.k;
                }).map(x0.invert));
            if (y1)
                y1.domain(y0.range().map(function (y) {
                    return (y - view.y) / view.k;
                }).map(y0.invert));
        }
        function zoomstarted(dispatch) {
            if (!zooming++)
                dispatch({ type: 'zoomstart' });
        }
        function zoomed(dispatch) {
            rescale();
            dispatch({
                type: 'zoom',
                scale: view.k,
                translate: [
                    view.x,
                    view.y
                ]
            });
        }
        function zoomended(dispatch) {
            if (!--zooming)
                dispatch({ type: 'zoomend' });
            center0 = null;
        }
        function mousedowned() {
            var that = this, target = d3.event.target, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that);
            d3_selection_interrupt.call(that);
            zoomstarted(dispatch);
            function moved() {
                dragged = 1;
                translateTo(d3.mouse(that), location0);
                zoomed(dispatch);
            }
            function ended() {
                subject.on(mousemove, null).on(mouseup, null);
                dragRestore(dragged && d3.event.target === target);
                zoomended(dispatch);
            }
        }
        function touchstarted() {
            var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = '.zoom-' + d3.event.changedTouches[0].identifier, touchmove = 'touchmove' + zoomName, touchend = 'touchend' + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);
            started();
            zoomstarted(dispatch);
            subject.on(mousedown, null).on(touchstart, started);
            function relocate() {
                var touches = d3.touches(that);
                scale0 = view.k;
                touches.forEach(function (t) {
                    if (t.identifier in locations0)
                        locations0[t.identifier] = location(t);
                });
                return touches;
            }
            function started() {
                var target = d3.event.target;
                d3.select(target).on(touchmove, moved).on(touchend, ended);
                targets.push(target);
                var changed = d3.event.changedTouches;
                for (var i = 0, n = changed.length; i < n; ++i) {
                    locations0[changed[i].identifier] = null;
                }
                var touches = relocate(), now = Date.now();
                if (touches.length === 1) {
                    if (now - touchtime < 500) {
                        var p = touches[0];
                        zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
                        d3_eventPreventDefault();
                    }
                    touchtime = now;
                } else if (touches.length > 1) {
                    var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];
                    distance0 = dx * dx + dy * dy;
                }
            }
            function moved() {
                var touches = d3.touches(that), p0, l0, p1, l1;
                d3_selection_interrupt.call(that);
                for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
                    p1 = touches[i];
                    if (l1 = locations0[p1.identifier]) {
                        if (l0)
                            break;
                        p0 = p1, l0 = l1;
                    }
                }
                if (l1) {
                    var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
                    p0 = [
                        (p0[0] + p1[0]) / 2,
                        (p0[1] + p1[1]) / 2
                    ];
                    l0 = [
                        (l0[0] + l1[0]) / 2,
                        (l0[1] + l1[1]) / 2
                    ];
                    scaleTo(scale1 * scale0);
                }
                touchtime = null;
                translateTo(p0, l0);
                zoomed(dispatch);
            }
            function ended() {
                if (d3.event.touches.length) {
                    var changed = d3.event.changedTouches;
                    for (var i = 0, n = changed.length; i < n; ++i) {
                        delete locations0[changed[i].identifier];
                    }
                    for (var identifier in locations0) {
                        return void relocate();
                    }
                }
                d3.selectAll(targets).on(zoomName, null);
                subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
                dragRestore();
                zoomended(dispatch);
            }
        }
        function mousewheeled() {
            var dispatch = event.of(this, arguments);
            if (mousewheelTimer)
                clearTimeout(mousewheelTimer);
            else
                translate0 = location(center0 = center || d3.mouse(this)), d3_selection_interrupt.call(this), zoomstarted(dispatch);
            mousewheelTimer = setTimeout(function () {
                mousewheelTimer = null;
                zoomended(dispatch);
            }, 50);
            d3_eventPreventDefault();
            scaleTo(Math.pow(2, d3_behavior_zoomDelta() * 0.002) * view.k);
            translateTo(center0, translate0);
            zoomed(dispatch);
        }
        function dblclicked() {
            var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;
            zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
        }
        return d3.rebind(zoom, event, 'on');
    };
    var d3_behavior_zoomInfinity = [
            0,
            Infinity
        ], d3_behavior_zoomDelta, d3_behavior_zoomWheel;
    d3.color = d3_color;
    function d3_color() {
    }
    d3_color.prototype.toString = function () {
        return this.rgb() + '';
    };
    d3.hsl = d3_hsl;
    function d3_hsl(h, s, l) {
        return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse('' + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
    }
    var d3_hslPrototype = d3_hsl.prototype = new d3_color();
    d3_hslPrototype.brighter = function (k) {
        k = Math.pow(0.7, arguments.length ? k : 1);
        return new d3_hsl(this.h, this.s, this.l / k);
    };
    d3_hslPrototype.darker = function (k) {
        k = Math.pow(0.7, arguments.length ? k : 1);
        return new d3_hsl(this.h, this.s, k * this.l);
    };
    d3_hslPrototype.rgb = function () {
        return d3_hsl_rgb(this.h, this.s, this.l);
    };
    function d3_hsl_rgb(h, s, l) {
        var m1, m2;
        h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
        s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
        l = l < 0 ? 0 : l > 1 ? 1 : l;
        m2 = l <= 0.5 ? l * (1 + s) : l + s - l * s;
        m1 = 2 * l - m2;
        function v(h) {
            if (h > 360)
                h -= 360;
            else if (h < 0)
                h += 360;
            if (h < 60)
                return m1 + (m2 - m1) * h / 60;
            if (h < 180)
                return m2;
            if (h < 240)
                return m1 + (m2 - m1) * (240 - h) / 60;
            return m1;
        }
        function vv(h) {
            return Math.round(v(h) * 255);
        }
        return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
    }
    d3.hcl = d3_hcl;
    function d3_hcl(h, c, l) {
        return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
    }
    var d3_hclPrototype = d3_hcl.prototype = new d3_color();
    d3_hclPrototype.brighter = function (k) {
        return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
    };
    d3_hclPrototype.darker = function (k) {
        return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
    };
    d3_hclPrototype.rgb = function () {
        return d3_hcl_lab(this.h, this.c, this.l).rgb();
    };
    function d3_hcl_lab(h, c, l) {
        if (isNaN(h))
            h = 0;
        if (isNaN(c))
            c = 0;
        return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
    }
    d3.lab = d3_lab;
    function d3_lab(l, a, b) {
        return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
    }
    var d3_lab_K = 18;
    var d3_lab_X = 0.95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
    var d3_labPrototype = d3_lab.prototype = new d3_color();
    d3_labPrototype.brighter = function (k) {
        return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
    };
    d3_labPrototype.darker = function (k) {
        return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
    };
    d3_labPrototype.rgb = function () {
        return d3_lab_rgb(this.l, this.a, this.b);
    };
    function d3_lab_rgb(l, a, b) {
        var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
        x = d3_lab_xyz(x) * d3_lab_X;
        y = d3_lab_xyz(y) * d3_lab_Y;
        z = d3_lab_xyz(z) * d3_lab_Z;
        return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z), d3_xyz_rgb(-0.969266 * x + 1.8760108 * y + 0.041556 * z), d3_xyz_rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z));
    }
    function d3_lab_hcl(l, a, b) {
        return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
    }
    function d3_lab_xyz(x) {
        return x > 0.206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
    }
    function d3_xyz_lab(x) {
        return x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
    }
    function d3_xyz_rgb(r) {
        return Math.round(255 * (r <= 0.00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - 0.055));
    }
    d3.rgb = d3_rgb;
    function d3_rgb(r, g, b) {
        return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse('' + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
    }
    function d3_rgbNumber(value) {
        return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
    }
    function d3_rgbString(value) {
        return d3_rgbNumber(value) + '';
    }
    var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
    d3_rgbPrototype.brighter = function (k) {
        k = Math.pow(0.7, arguments.length ? k : 1);
        var r = this.r, g = this.g, b = this.b, i = 30;
        if (!r && !g && !b)
            return new d3_rgb(i, i, i);
        if (r && r < i)
            r = i;
        if (g && g < i)
            g = i;
        if (b && b < i)
            b = i;
        return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
    };
    d3_rgbPrototype.darker = function (k) {
        k = Math.pow(0.7, arguments.length ? k : 1);
        return new d3_rgb(k * this.r, k * this.g, k * this.b);
    };
    d3_rgbPrototype.hsl = function () {
        return d3_rgb_hsl(this.r, this.g, this.b);
    };
    d3_rgbPrototype.toString = function () {
        return '#' + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
    };
    function d3_rgb_hex(v) {
        return v < 16 ? '0' + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
    }
    function d3_rgb_parse(format, rgb, hsl) {
        var r = 0, g = 0, b = 0, m1, m2, color;
        m1 = /([a-z]+)\((.*)\)/i.exec(format);
        if (m1) {
            m2 = m1[2].split(',');
            switch (m1[1]) {
            case 'hsl': {
                    return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
                }
            case 'rgb': {
                    return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
                }
            }
        }
        if (color = d3_rgb_names.get(format.toLowerCase())) {
            return rgb(color.r, color.g, color.b);
        }
        if (format != null && format.charAt(0) === '#' && !isNaN(color = parseInt(format.slice(1), 16))) {
            if (format.length === 4) {
                r = (color & 3840) >> 4;
                r = r >> 4 | r;
                g = color & 240;
                g = g >> 4 | g;
                b = color & 15;
                b = b << 4 | b;
            } else if (format.length === 7) {
                r = (color & 16711680) >> 16;
                g = (color & 65280) >> 8;
                b = color & 255;
            }
        }
        return rgb(r, g, b);
    }
    function d3_rgb_hsl(r, g, b) {
        var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
        if (d) {
            s = l < 0.5 ? d / (max + min) : d / (2 - max - min);
            if (r == max)
                h = (g - b) / d + (g < b ? 6 : 0);
            else if (g == max)
                h = (b - r) / d + 2;
            else
                h = (r - g) / d + 4;
            h *= 60;
        } else {
            h = NaN;
            s = l > 0 && l < 1 ? 0 : h;
        }
        return new d3_hsl(h, s, l);
    }
    function d3_rgb_lab(r, g, b) {
        r = d3_rgb_xyz(r);
        g = d3_rgb_xyz(g);
        b = d3_rgb_xyz(b);
        var x = d3_xyz_lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / d3_lab_X), y = d3_xyz_lab((0.2126729 * r + 0.7151522 * g + 0.072175 * b) / d3_lab_Y), z = d3_xyz_lab((0.0193339 * r + 0.119192 * g + 0.9503041 * b) / d3_lab_Z);
        return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
    }
    function d3_rgb_xyz(r) {
        return (r /= 255) <= 0.04045 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
    }
    function d3_rgb_parseNumber(c) {
        var f = parseFloat(c);
        return c.charAt(c.length - 1) === '%' ? Math.round(f * 2.55) : f;
    }
    var d3_rgb_names = d3.map({
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    });
    d3_rgb_names.forEach(function (key, value) {
        d3_rgb_names.set(key, d3_rgbNumber(value));
    });
    function d3_functor(v) {
        return typeof v === 'function' ? v : function () {
            return v;
        };
    }
    d3.functor = d3_functor;
    d3.xhr = d3_xhrType(d3_identity);
    function d3_xhrType(response) {
        return function (url, mimeType, callback) {
            if (arguments.length === 2 && typeof mimeType === 'function')
                callback = mimeType, mimeType = null;
            return d3_xhr(url, mimeType, response, callback);
        };
    }
    function d3_xhr(url, mimeType, response, callback) {
        var xhr = {}, dispatch = d3.dispatch('beforesend', 'progress', 'load', 'error'), headers = {}, request = new XMLHttpRequest(), responseType = null;
        if (this.XDomainRequest && !('withCredentials' in request) && /^(http(s)?:)?\/\//.test(url))
            request = new XDomainRequest();
        'onload' in request ? request.onload = request.onerror = respond : request.onreadystatechange = function () {
            request.readyState > 3 && respond();
        };
        function respond() {
            var status = request.status, result;
            if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
                try {
                    result = response.call(xhr, request);
                } catch (e) {
                    dispatch.error.call(xhr, e);
                    return;
                }
                dispatch.load.call(xhr, result);
            } else {
                dispatch.error.call(xhr, request);
            }
        }
        request.onprogress = function (event) {
            var o = d3.event;
            d3.event = event;
            try {
                dispatch.progress.call(xhr, request);
            } finally {
                d3.event = o;
            }
        };
        xhr.header = function (name, value) {
            name = (name + '').toLowerCase();
            if (arguments.length < 2)
                return headers[name];
            if (value == null)
                delete headers[name];
            else
                headers[name] = value + '';
            return xhr;
        };
        xhr.mimeType = function (value) {
            if (!arguments.length)
                return mimeType;
            mimeType = value == null ? null : value + '';
            return xhr;
        };
        xhr.responseType = function (value) {
            if (!arguments.length)
                return responseType;
            responseType = value;
            return xhr;
        };
        xhr.response = function (value) {
            response = value;
            return xhr;
        };
        [
            'get',
            'post'
        ].forEach(function (method) {
            xhr[method] = function () {
                return xhr.send.apply(xhr, [method].concat(d3_array(arguments)));
            };
        });
        xhr.send = function (method, data, callback) {
            if (arguments.length === 2 && typeof data === 'function')
                callback = data, data = null;
            request.open(method, url, true);
            if (mimeType != null && !('accept' in headers))
                headers['accept'] = mimeType + ',*/*';
            if (request.setRequestHeader)
                for (var name in headers)
                    request.setRequestHeader(name, headers[name]);
            if (mimeType != null && request.overrideMimeType)
                request.overrideMimeType(mimeType);
            if (responseType != null)
                request.responseType = responseType;
            if (callback != null)
                xhr.on('error', callback).on('load', function (request) {
                    callback(null, request);
                });
            dispatch.beforesend.call(xhr, request);
            request.send(data == null ? null : data);
            return xhr;
        };
        xhr.abort = function () {
            request.abort();
            return xhr;
        };
        d3.rebind(xhr, dispatch, 'on');
        return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
    }
    function d3_xhr_fixCallback(callback) {
        return callback.length === 1 ? function (error, request) {
            callback(error == null ? request : null);
        } : callback;
    }
    function d3_xhrHasResponse(request) {
        var type = request.responseType;
        return type && type !== 'text' ? request.response : request.responseText;
    }
    d3.dsv = function (delimiter, mimeType) {
        var reFormat = new RegExp('["' + delimiter + '\n]'), delimiterCode = delimiter.charCodeAt(0);
        function dsv(url, row, callback) {
            if (arguments.length < 3)
                callback = row, row = null;
            var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
            xhr.row = function (_) {
                return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
            };
            return xhr;
        }
        function response(request) {
            return dsv.parse(request.responseText);
        }
        function typedResponse(f) {
            return function (request) {
                return dsv.parse(request.responseText, f);
            };
        }
        dsv.parse = function (text, f) {
            var o;
            return dsv.parseRows(text, function (row, i) {
                if (o)
                    return o(row, i - 1);
                var a = new Function('d', 'return {' + row.map(function (name, i) {
                    return JSON.stringify(name) + ': d[' + i + ']';
                }).join(',') + '}');
                o = f ? function (row, i) {
                    return f(a(row), i);
                } : a;
            });
        };
        dsv.parseRows = function (text, f) {
            var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
            function token() {
                if (I >= N)
                    return EOF;
                if (eol)
                    return eol = false, EOL;
                var j = I;
                if (text.charCodeAt(j) === 34) {
                    var i = j;
                    while (i++ < N) {
                        if (text.charCodeAt(i) === 34) {
                            if (text.charCodeAt(i + 1) !== 34)
                                break;
                            ++i;
                        }
                    }
                    I = i + 2;
                    var c = text.charCodeAt(i + 1);
                    if (c === 13) {
                        eol = true;
                        if (text.charCodeAt(i + 2) === 10)
                            ++I;
                    } else if (c === 10) {
                        eol = true;
                    }
                    return text.slice(j + 1, i).replace(/""/g, '"');
                }
                while (I < N) {
                    var c = text.charCodeAt(I++), k = 1;
                    if (c === 10)
                        eol = true;
                    else if (c === 13) {
                        eol = true;
                        if (text.charCodeAt(I) === 10)
                            ++I, ++k;
                    } else if (c !== delimiterCode)
                        continue;
                    return text.slice(j, I - k);
                }
                return text.slice(j);
            }
            while ((t = token()) !== EOF) {
                var a = [];
                while (t !== EOL && t !== EOF) {
                    a.push(t);
                    t = token();
                }
                if (f && (a = f(a, n++)) == null)
                    continue;
                rows.push(a);
            }
            return rows;
        };
        dsv.format = function (rows) {
            if (Array.isArray(rows[0]))
                return dsv.formatRows(rows);
            var fieldSet = new d3_Set(), fields = [];
            rows.forEach(function (row) {
                for (var field in row) {
                    if (!fieldSet.has(field)) {
                        fields.push(fieldSet.add(field));
                    }
                }
            });
            return [fields.map(formatValue).join(delimiter)].concat(rows.map(function (row) {
                return fields.map(function (field) {
                    return formatValue(row[field]);
                }).join(delimiter);
            })).join('\n');
        };
        dsv.formatRows = function (rows) {
            return rows.map(formatRow).join('\n');
        };
        function formatRow(row) {
            return row.map(formatValue).join(delimiter);
        }
        function formatValue(text) {
            return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
        }
        return dsv;
    };
    d3.csv = d3.dsv(',', 'text/csv');
    d3.tsv = d3.dsv('\t', 'text/tab-separated-values');
    var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_active, d3_timer_frame = this[d3_vendorSymbol(this, 'requestAnimationFrame')] || function (callback) {
            setTimeout(callback, 17);
        };
    d3.timer = function (callback, delay, then) {
        var n = arguments.length;
        if (n < 2)
            delay = 0;
        if (n < 3)
            then = Date.now();
        var time = then + delay, timer = {
                c: callback,
                t: time,
                f: false,
                n: null
            };
        if (d3_timer_queueTail)
            d3_timer_queueTail.n = timer;
        else
            d3_timer_queueHead = timer;
        d3_timer_queueTail = timer;
        if (!d3_timer_interval) {
            d3_timer_timeout = clearTimeout(d3_timer_timeout);
            d3_timer_interval = 1;
            d3_timer_frame(d3_timer_step);
        }
    };
    function d3_timer_step() {
        var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
        if (delay > 24) {
            if (isFinite(delay)) {
                clearTimeout(d3_timer_timeout);
                d3_timer_timeout = setTimeout(d3_timer_step, delay);
            }
            d3_timer_interval = 0;
        } else {
            d3_timer_interval = 1;
            d3_timer_frame(d3_timer_step);
        }
    }
    d3.timer.flush = function () {
        d3_timer_mark();
        d3_timer_sweep();
    };
    function d3_timer_mark() {
        var now = Date.now();
        d3_timer_active = d3_timer_queueHead;
        while (d3_timer_active) {
            if (now >= d3_timer_active.t)
                d3_timer_active.f = d3_timer_active.c(now - d3_timer_active.t);
            d3_timer_active = d3_timer_active.n;
        }
        return now;
    }
    function d3_timer_sweep() {
        var t0, t1 = d3_timer_queueHead, time = Infinity;
        while (t1) {
            if (t1.f) {
                t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
            } else {
                if (t1.t < time)
                    time = t1.t;
                t1 = (t0 = t1).n;
            }
        }
        d3_timer_queueTail = t0;
        return time;
    }
    function d3_format_precision(x, p) {
        return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
    }
    d3.round = function (x, n) {
        return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
    };
    var d3_formatPrefixes = [
        'y',
        'z',
        'a',
        'f',
        'p',
        'n',
        '\xB5',
        'm',
        '',
        'k',
        'M',
        'G',
        'T',
        'P',
        'E',
        'Z',
        'Y'
    ].map(d3_formatPrefix);
    d3.formatPrefix = function (value, precision) {
        var i = 0;
        if (value) {
            if (value < 0)
                value *= -1;
            if (precision)
                value = d3.round(value, d3_format_precision(value, precision));
            i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
            i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
        }
        return d3_formatPrefixes[8 + i / 3];
    };
    function d3_formatPrefix(d, i) {
        var k = Math.pow(10, abs(8 - i) * 3);
        return {
            scale: i > 8 ? function (d) {
                return d / k;
            } : function (d) {
                return d * k;
            },
            symbol: d
        };
    }
    function d3_locale_numberFormat(locale) {
        var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function (value, width) {
                var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0;
                while (i > 0 && g > 0) {
                    if (length + g + 1 > width)
                        g = Math.max(1, width - length);
                    t.push(value.substring(i -= g, i + g));
                    if ((length += g + 1) > width)
                        break;
                    g = locale_grouping[j = (j + 1) % locale_grouping.length];
                }
                return t.reverse().join(locale_thousands);
            } : d3_identity;
        return function (specifier) {
            var match = d3_format_re.exec(specifier), fill = match[1] || ' ', align = match[2] || '>', sign = match[3] || '-', symbol = match[4] || '', zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = '', suffix = '', integer = false, exponent = true;
            if (precision)
                precision = +precision.substring(1);
            if (zfill || fill === '0' && align === '=') {
                zfill = fill = '0';
                align = '=';
            }
            switch (type) {
            case 'n':
                comma = true;
                type = 'g';
                break;
            case '%':
                scale = 100;
                suffix = '%';
                type = 'f';
                break;
            case 'p':
                scale = 100;
                suffix = '%';
                type = 'r';
                break;
            case 'b':
            case 'o':
            case 'x':
            case 'X':
                if (symbol === '#')
                    prefix = '0' + type.toLowerCase();
            case 'c':
                exponent = false;
            case 'd':
                integer = true;
                precision = 0;
                break;
            case 's':
                scale = -1;
                type = 'r';
                break;
            }
            if (symbol === '$')
                prefix = locale_currency[0], suffix = locale_currency[1];
            if (type == 'r' && !precision)
                type = 'g';
            if (precision != null) {
                if (type == 'g')
                    precision = Math.max(1, Math.min(21, precision));
                else if (type == 'e' || type == 'f')
                    precision = Math.max(0, Math.min(20, precision));
            }
            type = d3_format_types.get(type) || d3_format_typeDefault;
            var zcomma = zfill && comma;
            return function (value) {
                var fullSuffix = suffix;
                if (integer && value % 1)
                    return '';
                var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, '-') : sign === '-' ? '' : sign;
                if (scale < 0) {
                    var unit = d3.formatPrefix(value, precision);
                    value = unit.scale(value);
                    fullSuffix = unit.symbol + suffix;
                } else {
                    value *= scale;
                }
                value = type(value, precision);
                var i = value.lastIndexOf('.'), before, after;
                if (i < 0) {
                    var j = exponent ? value.lastIndexOf('e') : -1;
                    if (j < 0)
                        before = value, after = '';
                    else
                        before = value.substring(0, j), after = value.substring(j);
                } else {
                    before = value.substring(0, i);
                    after = locale_decimal + value.substring(i + 1);
                }
                if (!zfill && comma)
                    before = formatGroup(before, Infinity);
                var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : '';
                if (zcomma)
                    before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);
                negative += prefix;
                value = before + after;
                return (align === '<' ? negative + value + padding : align === '>' ? padding + negative + value : align === '^' ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
            };
        };
    }
    var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
    var d3_format_types = d3.map({
        b: function (x) {
            return x.toString(2);
        },
        c: function (x) {
            return String.fromCharCode(x);
        },
        o: function (x) {
            return x.toString(8);
        },
        x: function (x) {
            return x.toString(16);
        },
        X: function (x) {
            return x.toString(16).toUpperCase();
        },
        g: function (x, p) {
            return x.toPrecision(p);
        },
        e: function (x, p) {
            return x.toExponential(p);
        },
        f: function (x, p) {
            return x.toFixed(p);
        },
        r: function (x, p) {
            return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
        }
    });
    function d3_format_typeDefault(x) {
        return x + '';
    }
    var d3_time = d3.time = {}, d3_date = Date;
    function d3_date_utc() {
        this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
    }
    d3_date_utc.prototype = {
        getDate: function () {
            return this._.getUTCDate();
        },
        getDay: function () {
            return this._.getUTCDay();
        },
        getFullYear: function () {
            return this._.getUTCFullYear();
        },
        getHours: function () {
            return this._.getUTCHours();
        },
        getMilliseconds: function () {
            return this._.getUTCMilliseconds();
        },
        getMinutes: function () {
            return this._.getUTCMinutes();
        },
        getMonth: function () {
            return this._.getUTCMonth();
        },
        getSeconds: function () {
            return this._.getUTCSeconds();
        },
        getTime: function () {
            return this._.getTime();
        },
        getTimezoneOffset: function () {
            return 0;
        },
        valueOf: function () {
            return this._.valueOf();
        },
        setDate: function () {
            d3_time_prototype.setUTCDate.apply(this._, arguments);
        },
        setDay: function () {
            d3_time_prototype.setUTCDay.apply(this._, arguments);
        },
        setFullYear: function () {
            d3_time_prototype.setUTCFullYear.apply(this._, arguments);
        },
        setHours: function () {
            d3_time_prototype.setUTCHours.apply(this._, arguments);
        },
        setMilliseconds: function () {
            d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
        },
        setMinutes: function () {
            d3_time_prototype.setUTCMinutes.apply(this._, arguments);
        },
        setMonth: function () {
            d3_time_prototype.setUTCMonth.apply(this._, arguments);
        },
        setSeconds: function () {
            d3_time_prototype.setUTCSeconds.apply(this._, arguments);
        },
        setTime: function () {
            d3_time_prototype.setTime.apply(this._, arguments);
        }
    };
    var d3_time_prototype = Date.prototype;
    function d3_time_interval(local, step, number) {
        function round(date) {
            var d0 = local(date), d1 = offset(d0, 1);
            return date - d0 < d1 - date ? d0 : d1;
        }
        function ceil(date) {
            step(date = local(new d3_date(date - 1)), 1);
            return date;
        }
        function offset(date, k) {
            step(date = new d3_date(+date), k);
            return date;
        }
        function range(t0, t1, dt) {
            var time = ceil(t0), times = [];
            if (dt > 1) {
                while (time < t1) {
                    if (!(number(time) % dt))
                        times.push(new Date(+time));
                    step(time, 1);
                }
            } else {
                while (time < t1)
                    times.push(new Date(+time)), step(time, 1);
            }
            return times;
        }
        function range_utc(t0, t1, dt) {
            try {
                d3_date = d3_date_utc;
                var utc = new d3_date_utc();
                utc._ = t0;
                return range(utc, t1, dt);
            } finally {
                d3_date = Date;
            }
        }
        local.floor = local;
        local.round = round;
        local.ceil = ceil;
        local.offset = offset;
        local.range = range;
        var utc = local.utc = d3_time_interval_utc(local);
        utc.floor = utc;
        utc.round = d3_time_interval_utc(round);
        utc.ceil = d3_time_interval_utc(ceil);
        utc.offset = d3_time_interval_utc(offset);
        utc.range = range_utc;
        return local;
    }
    function d3_time_interval_utc(method) {
        return function (date, k) {
            try {
                d3_date = d3_date_utc;
                var utc = new d3_date_utc();
                utc._ = date;
                return method(utc, k)._;
            } finally {
                d3_date = Date;
            }
        };
    }
    d3_time.year = d3_time_interval(function (date) {
        date = d3_time.day(date);
        date.setMonth(0, 1);
        return date;
    }, function (date, offset) {
        date.setFullYear(date.getFullYear() + offset);
    }, function (date) {
        return date.getFullYear();
    });
    d3_time.years = d3_time.year.range;
    d3_time.years.utc = d3_time.year.utc.range;
    d3_time.day = d3_time_interval(function (date) {
        var day = new d3_date(2000, 0);
        day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
        return day;
    }, function (date, offset) {
        date.setDate(date.getDate() + offset);
    }, function (date) {
        return date.getDate() - 1;
    });
    d3_time.days = d3_time.day.range;
    d3_time.days.utc = d3_time.day.utc.range;
    d3_time.dayOfYear = function (date) {
        var year = d3_time.year(date);
        return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 60000) / 86400000);
    };
    [
        'sunday',
        'monday',
        'tuesday',
        'wednesday',
        'thursday',
        'friday',
        'saturday'
    ].forEach(function (day, i) {
        i = 7 - i;
        var interval = d3_time[day] = d3_time_interval(function (date) {
            (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
            return date;
        }, function (date, offset) {
            date.setDate(date.getDate() + Math.floor(offset) * 7);
        }, function (date) {
            var day = d3_time.year(date).getDay();
            return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
        });
        d3_time[day + 's'] = interval.range;
        d3_time[day + 's'].utc = interval.utc.range;
        d3_time[day + 'OfYear'] = function (date) {
            var day = d3_time.year(date).getDay();
            return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
        };
    });
    d3_time.week = d3_time.sunday;
    d3_time.weeks = d3_time.sunday.range;
    d3_time.weeks.utc = d3_time.sunday.utc.range;
    d3_time.weekOfYear = d3_time.sundayOfYear;
    function d3_locale_timeFormat(locale) {
        var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;
        function d3_time_format(template) {
            var n = template.length;
            function format(date) {
                var string = [], i = -1, j = 0, c, p, f;
                while (++i < n) {
                    if (template.charCodeAt(i) === 37) {
                        string.push(template.slice(j, i));
                        if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null)
                            c = template.charAt(++i);
                        if (f = d3_time_formats[c])
                            c = f(date, p == null ? c === 'e' ? ' ' : '0' : p);
                        string.push(c);
                        j = i + 1;
                    }
                }
                string.push(template.slice(j, i));
                return string.join('');
            }
            format.parse = function (string) {
                var d = {
                        y: 1900,
                        m: 0,
                        d: 1,
                        H: 0,
                        M: 0,
                        S: 0,
                        L: 0,
                        Z: null
                    }, i = d3_time_parse(d, template, string, 0);
                if (i != string.length)
                    return null;
                if ('p' in d)
                    d.H = d.H % 12 + d.p * 12;
                var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();
                if ('j' in d)
                    date.setFullYear(d.y, 0, d.j);
                else if ('w' in d && ('W' in d || 'U' in d)) {
                    date.setFullYear(d.y, 0, 1);
                    date.setFullYear(d.y, 0, 'W' in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
                } else
                    date.setFullYear(d.y, d.m, d.d);
                date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);
                return localZ ? date._ : date;
            };
            format.toString = function () {
                return template;
            };
            return format;
        }
        function d3_time_parse(date, template, string, j) {
            var c, p, t, i = 0, n = template.length, m = string.length;
            while (i < n) {
                if (j >= m)
                    return -1;
                c = template.charCodeAt(i++);
                if (c === 37) {
                    t = template.charAt(i++);
                    p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
                    if (!p || (j = p(date, string, j)) < 0)
                        return -1;
                } else if (c != string.charCodeAt(j++)) {
                    return -1;
                }
            }
            return j;
        }
        d3_time_format.utc = function (template) {
            var local = d3_time_format(template);
            function format(date) {
                try {
                    d3_date = d3_date_utc;
                    var utc = new d3_date();
                    utc._ = date;
                    return local(utc);
                } finally {
                    d3_date = Date;
                }
            }
            format.parse = function (string) {
                try {
                    d3_date = d3_date_utc;
                    var date = local.parse(string);
                    return date && date._;
                } finally {
                    d3_date = Date;
                }
            };
            format.toString = local.toString;
            return format;
        };
        d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
        var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
        locale_periods.forEach(function (p, i) {
            d3_time_periodLookup.set(p.toLowerCase(), i);
        });
        var d3_time_formats = {
            a: function (d) {
                return locale_shortDays[d.getDay()];
            },
            A: function (d) {
                return locale_days[d.getDay()];
            },
            b: function (d) {
                return locale_shortMonths[d.getMonth()];
            },
            B: function (d) {
                return locale_months[d.getMonth()];
            },
            c: d3_time_format(locale_dateTime),
            d: function (d, p) {
                return d3_time_formatPad(d.getDate(), p, 2);
            },
            e: function (d, p) {
                return d3_time_formatPad(d.getDate(), p, 2);
            },
            H: function (d, p) {
                return d3_time_formatPad(d.getHours(), p, 2);
            },
            I: function (d, p) {
                return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
            },
            j: function (d, p) {
                return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
            },
            L: function (d, p) {
                return d3_time_formatPad(d.getMilliseconds(), p, 3);
            },
            m: function (d, p) {
                return d3_time_formatPad(d.getMonth() + 1, p, 2);
            },
            M: function (d, p) {
                return d3_time_formatPad(d.getMinutes(), p, 2);
            },
            p: function (d) {
                return locale_periods[+(d.getHours() >= 12)];
            },
            S: function (d, p) {
                return d3_time_formatPad(d.getSeconds(), p, 2);
            },
            U: function (d, p) {
                return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
            },
            w: function (d) {
                return d.getDay();
            },
            W: function (d, p) {
                return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
            },
            x: d3_time_format(locale_date),
            X: d3_time_format(locale_time),
            y: function (d, p) {
                return d3_time_formatPad(d.getFullYear() % 100, p, 2);
            },
            Y: function (d, p) {
                return d3_time_formatPad(d.getFullYear() % 10000, p, 4);
            },
            Z: d3_time_zone,
            '%': function () {
                return '%';
            }
        };
        var d3_time_parsers = {
            a: d3_time_parseWeekdayAbbrev,
            A: d3_time_parseWeekday,
            b: d3_time_parseMonthAbbrev,
            B: d3_time_parseMonth,
            c: d3_time_parseLocaleFull,
            d: d3_time_parseDay,
            e: d3_time_parseDay,
            H: d3_time_parseHour24,
            I: d3_time_parseHour24,
            j: d3_time_parseDayOfYear,
            L: d3_time_parseMilliseconds,
            m: d3_time_parseMonthNumber,
            M: d3_time_parseMinutes,
            p: d3_time_parseAmPm,
            S: d3_time_parseSeconds,
            U: d3_time_parseWeekNumberSunday,
            w: d3_time_parseWeekdayNumber,
            W: d3_time_parseWeekNumberMonday,
            x: d3_time_parseLocaleDate,
            X: d3_time_parseLocaleTime,
            y: d3_time_parseYear,
            Y: d3_time_parseFullYear,
            Z: d3_time_parseZone,
            '%': d3_time_parseLiteralPercent
        };
        function d3_time_parseWeekdayAbbrev(date, string, i) {
            d3_time_dayAbbrevRe.lastIndex = 0;
            var n = d3_time_dayAbbrevRe.exec(string.slice(i));
            return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseWeekday(date, string, i) {
            d3_time_dayRe.lastIndex = 0;
            var n = d3_time_dayRe.exec(string.slice(i));
            return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseMonthAbbrev(date, string, i) {
            d3_time_monthAbbrevRe.lastIndex = 0;
            var n = d3_time_monthAbbrevRe.exec(string.slice(i));
            return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseMonth(date, string, i) {
            d3_time_monthRe.lastIndex = 0;
            var n = d3_time_monthRe.exec(string.slice(i));
            return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseLocaleFull(date, string, i) {
            return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
        }
        function d3_time_parseLocaleDate(date, string, i) {
            return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
        }
        function d3_time_parseLocaleTime(date, string, i) {
            return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
        }
        function d3_time_parseAmPm(date, string, i) {
            var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());
            return n == null ? -1 : (date.p = n, i);
        }
        return d3_time_format;
    }
    var d3_time_formatPads = {
            '-': '',
            _: ' ',
            '0': '0'
        }, d3_time_numberRe = /^\s*\d+/, d3_time_percentRe = /^%/;
    function d3_time_formatPad(value, fill, width) {
        var sign = value < 0 ? '-' : '', string = (sign ? -value : value) + '', length = string.length;
        return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
    }
    function d3_time_formatRe(names) {
        return new RegExp('^(?:' + names.map(d3.requote).join('|') + ')', 'i');
    }
    function d3_time_formatLookup(names) {
        var map = new d3_Map(), i = -1, n = names.length;
        while (++i < n)
            map.set(names[i].toLowerCase(), i);
        return map;
    }
    function d3_time_parseWeekdayNumber(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 1));
        return n ? (date.w = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseWeekNumberSunday(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i));
        return n ? (date.U = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseWeekNumberMonday(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i));
        return n ? (date.W = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseFullYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 4));
        return n ? (date.y = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
    }
    function d3_time_parseZone(date, string, i) {
        return /^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, i + 5) : -1;
    }
    function d3_time_expandYear(d) {
        return d + (d > 68 ? 1900 : 2000);
    }
    function d3_time_parseMonthNumber(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
    }
    function d3_time_parseDay(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.d = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseDayOfYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 3));
        return n ? (date.j = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseHour24(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.H = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseMinutes(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.M = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseSeconds(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.S = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseMilliseconds(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 3));
        return n ? (date.L = +n[0], i + n[0].length) : -1;
    }
    function d3_time_zone(d) {
        var z = d.getTimezoneOffset(), zs = z > 0 ? '-' : '+', zh = abs(z) / 60 | 0, zm = abs(z) % 60;
        return zs + d3_time_formatPad(zh, '0', 2) + d3_time_formatPad(zm, '0', 2);
    }
    function d3_time_parseLiteralPercent(date, string, i) {
        d3_time_percentRe.lastIndex = 0;
        var n = d3_time_percentRe.exec(string.slice(i, i + 1));
        return n ? i + n[0].length : -1;
    }
    function d3_time_formatMulti(formats) {
        var n = formats.length, i = -1;
        while (++i < n)
            formats[i][0] = this(formats[i][0]);
        return function (date) {
            var i = 0, f = formats[i];
            while (!f[1](date))
                f = formats[++i];
            return f[0](date);
        };
    }
    d3.locale = function (locale) {
        return {
            numberFormat: d3_locale_numberFormat(locale),
            timeFormat: d3_locale_timeFormat(locale)
        };
    };
    var d3_locale_enUS = d3.locale({
        decimal: '.',
        thousands: ',',
        grouping: [3],
        currency: [
            '$',
            ''
        ],
        dateTime: '%a %b %e %X %Y',
        date: '%m/%d/%Y',
        time: '%H:%M:%S',
        periods: [
            'AM',
            'PM'
        ],
        days: [
            'Sunday',
            'Monday',
            'Tuesday',
            'Wednesday',
            'Thursday',
            'Friday',
            'Saturday'
        ],
        shortDays: [
            'Sun',
            'Mon',
            'Tue',
            'Wed',
            'Thu',
            'Fri',
            'Sat'
        ],
        months: [
            'January',
            'February',
            'March',
            'April',
            'May',
            'June',
            'July',
            'August',
            'September',
            'October',
            'November',
            'December'
        ],
        shortMonths: [
            'Jan',
            'Feb',
            'Mar',
            'Apr',
            'May',
            'Jun',
            'Jul',
            'Aug',
            'Sep',
            'Oct',
            'Nov',
            'Dec'
        ]
    });
    d3.format = d3_locale_enUS.numberFormat;
    d3.geo = {};
    function d3_adder() {
    }
    d3_adder.prototype = {
        s: 0,
        t: 0,
        add: function (y) {
            d3_adderSum(y, this.t, d3_adderTemp);
            d3_adderSum(d3_adderTemp.s, this.s, this);
            if (this.s)
                this.t += d3_adderTemp.t;
            else
                this.s = d3_adderTemp.t;
        },
        reset: function () {
            this.s = this.t = 0;
        },
        valueOf: function () {
            return this.s;
        }
    };
    var d3_adderTemp = new d3_adder();
    function d3_adderSum(a, b, o) {
        var x = o.s = a + b, bv = x - a, av = x - bv;
        o.t = a - av + (b - bv);
    }
    d3.geo.stream = function (object, listener) {
        if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
            d3_geo_streamObjectType[object.type](object, listener);
        } else {
            d3_geo_streamGeometry(object, listener);
        }
    };
    function d3_geo_streamGeometry(geometry, listener) {
        if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
            d3_geo_streamGeometryType[geometry.type](geometry, listener);
        }
    }
    var d3_geo_streamObjectType = {
        Feature: function (feature, listener) {
            d3_geo_streamGeometry(feature.geometry, listener);
        },
        FeatureCollection: function (object, listener) {
            var features = object.features, i = -1, n = features.length;
            while (++i < n)
                d3_geo_streamGeometry(features[i].geometry, listener);
        }
    };
    var d3_geo_streamGeometryType = {
        Sphere: function (object, listener) {
            listener.sphere();
        },
        Point: function (object, listener) {
            object = object.coordinates;
            listener.point(object[0], object[1], object[2]);
        },
        MultiPoint: function (object, listener) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while (++i < n)
                object = coordinates[i], listener.point(object[0], object[1], object[2]);
        },
        LineString: function (object, listener) {
            d3_geo_streamLine(object.coordinates, listener, 0);
        },
        MultiLineString: function (object, listener) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while (++i < n)
                d3_geo_streamLine(coordinates[i], listener, 0);
        },
        Polygon: function (object, listener) {
            d3_geo_streamPolygon(object.coordinates, listener);
        },
        MultiPolygon: function (object, listener) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while (++i < n)
                d3_geo_streamPolygon(coordinates[i], listener);
        },
        GeometryCollection: function (object, listener) {
            var geometries = object.geometries, i = -1, n = geometries.length;
            while (++i < n)
                d3_geo_streamGeometry(geometries[i], listener);
        }
    };
    function d3_geo_streamLine(coordinates, listener, closed) {
        var i = -1, n = coordinates.length - closed, coordinate;
        listener.lineStart();
        while (++i < n)
            coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
        listener.lineEnd();
    }
    function d3_geo_streamPolygon(coordinates, listener) {
        var i = -1, n = coordinates.length;
        listener.polygonStart();
        while (++i < n)
            d3_geo_streamLine(coordinates[i], listener, 1);
        listener.polygonEnd();
    }
    d3.geo.area = function (object) {
        d3_geo_areaSum = 0;
        d3.geo.stream(object, d3_geo_area);
        return d3_geo_areaSum;
    };
    var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();
    var d3_geo_area = {
        sphere: function () {
            d3_geo_areaSum += 4 * ;
        },
        point: d3_noop,
        lineStart: d3_noop,
        lineEnd: d3_noop,
        polygonStart: function () {
            d3_geo_areaRingSum.reset();
            d3_geo_area.lineStart = d3_geo_areaRingStart;
        },
        polygonEnd: function () {
            var area = 2 * d3_geo_areaRingSum;
            d3_geo_areaSum += area < 0 ? 4 *  + area : area;
            d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
        }
    };
    function d3_geo_areaRingStart() {
        var 00, 00, 0, cos0, sin0;
        d3_geo_area.point = function (, ) {
            d3_geo_area.point = nextPoint;
            0 = (00 = ) * d3_radians, cos0 = Math.cos( = (00 = ) * d3_radians / 2 +  / 4), sin0 = Math.sin();
        };
        function nextPoint(, ) {
             *= d3_radians;
             =  * d3_radians / 2 +  / 4;
            var d =  - 0, sd = d >= 0 ? 1 : -1, ad = sd * d, cos = Math.cos(), sin = Math.sin(), k = sin0 * sin, u = cos0 * cos + k * Math.cos(ad), v = k * sd * Math.sin(ad);
            d3_geo_areaRingSum.add(Math.atan2(v, u));
            0 = , cos0 = cos, sin0 = sin;
        }
        d3_geo_area.lineEnd = function () {
            nextPoint(00, 00);
        };
    }
    function d3_geo_cartesian(spherical) {
        var  = spherical[0],  = spherical[1], cos = Math.cos();
        return [
            cos * Math.cos(),
            cos * Math.sin(),
            Math.sin()
        ];
    }
    function d3_geo_cartesianDot(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    }
    function d3_geo_cartesianCross(a, b) {
        return [
            a[1] * b[2] - a[2] * b[1],
            a[2] * b[0] - a[0] * b[2],
            a[0] * b[1] - a[1] * b[0]
        ];
    }
    function d3_geo_cartesianAdd(a, b) {
        a[0] += b[0];
        a[1] += b[1];
        a[2] += b[2];
    }
    function d3_geo_cartesianScale(vector, k) {
        return [
            vector[0] * k,
            vector[1] * k,
            vector[2] * k
        ];
    }
    function d3_geo_cartesianNormalize(d) {
        var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
        d[0] /= l;
        d[1] /= l;
        d[2] /= l;
    }
    function d3_geo_spherical(cartesian) {
        return [
            Math.atan2(cartesian[1], cartesian[0]),
            d3_asin(cartesian[2])
        ];
    }
    function d3_geo_sphericalEqual(a, b) {
        return abs(a[0] - b[0]) <  && abs(a[1] - b[1]) < ;
    }
    d3.geo.bounds = function () {
        var 0, 0, 1, 1, _, __, __, p0, dSum, ranges, range;
        var bound = {
            point: point,
            lineStart: lineStart,
            lineEnd: lineEnd,
            polygonStart: function () {
                bound.point = ringPoint;
                bound.lineStart = ringStart;
                bound.lineEnd = ringEnd;
                dSum = 0;
                d3_geo_area.polygonStart();
            },
            polygonEnd: function () {
                d3_geo_area.polygonEnd();
                bound.point = point;
                bound.lineStart = lineStart;
                bound.lineEnd = lineEnd;
                if (d3_geo_areaRingSum < 0)
                    0 = -(1 = 180), 0 = -(1 = 90);
                else if (dSum > )
                    1 = 90;
                else if (dSum < -)
                    0 = -90;
                range[0] = 0, range[1] = 1;
            }
        };
        function point(, ) {
            ranges.push(range = [
                0 = ,
                1 = 
            ]);
            if ( < 0)
                0 = ;
            if ( > 1)
                1 = ;
        }
        function linePoint(, ) {
            var p = d3_geo_cartesian([
                 * d3_radians,
                 * d3_radians
            ]);
            if (p0) {
                var normal = d3_geo_cartesianCross(p0, p), equatorial = [
                        normal[1],
                        -normal[0],
                        0
                    ], inflection = d3_geo_cartesianCross(equatorial, normal);
                d3_geo_cartesianNormalize(inflection);
                inflection = d3_geo_spherical(inflection);
                var d =  - _, s = d > 0 ? 1 : -1, i = inflection[0] * d3_degrees * s, antimeridian = abs(d) > 180;
                if (antimeridian ^ (s * _ < i && i < s * )) {
                    var i = inflection[1] * d3_degrees;
                    if (i > 1)
                        1 = i;
                } else if (i = (i + 360) % 360 - 180, antimeridian ^ (s * _ < i && i < s * )) {
                    var i = -inflection[1] * d3_degrees;
                    if (i < 0)
                        0 = i;
                } else {
                    if ( < 0)
                        0 = ;
                    if ( > 1)
                        1 = ;
                }
                if (antimeridian) {
                    if ( < _) {
                        if (angle(0, ) > angle(0, 1))
                            1 = ;
                    } else {
                        if (angle(, 1) > angle(0, 1))
                            0 = ;
                    }
                } else {
                    if (1 >= 0) {
                        if ( < 0)
                            0 = ;
                        if ( > 1)
                            1 = ;
                    } else {
                        if ( > _) {
                            if (angle(0, ) > angle(0, 1))
                                1 = ;
                        } else {
                            if (angle(, 1) > angle(0, 1))
                                0 = ;
                        }
                    }
                }
            } else {
                point(, );
            }
            p0 = p, _ = ;
        }
        function lineStart() {
            bound.point = linePoint;
        }
        function lineEnd() {
            range[0] = 0, range[1] = 1;
            bound.point = point;
            p0 = null;
        }
        function ringPoint(, ) {
            if (p0) {
                var d =  - _;
                dSum += abs(d) > 180 ? d + (d > 0 ? 360 : -360) : d;
            } else
                __ = , __ = ;
            d3_geo_area.point(, );
            linePoint(, );
        }
        function ringStart() {
            d3_geo_area.lineStart();
        }
        function ringEnd() {
            ringPoint(__, __);
            d3_geo_area.lineEnd();
            if (abs(dSum) > )
                0 = -(1 = 180);
            range[0] = 0, range[1] = 1;
            p0 = null;
        }
        function angle(0, 1) {
            return (1 -= 0) < 0 ? 1 + 360 : 1;
        }
        function compareRanges(a, b) {
            return a[0] - b[0];
        }
        function withinRange(x, range) {
            return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
        }
        return function (feature) {
            1 = 1 = -(0 = 0 = Infinity);
            ranges = [];
            d3.geo.stream(feature, bound);
            var n = ranges.length;
            if (n) {
                ranges.sort(compareRanges);
                for (var i = 1, a = ranges[0], b, merged = [a]; i < n; ++i) {
                    b = ranges[i];
                    if (withinRange(b[0], a) || withinRange(b[1], a)) {
                        if (angle(a[0], b[1]) > angle(a[0], a[1]))
                            a[1] = b[1];
                        if (angle(b[0], a[1]) > angle(a[0], a[1]))
                            a[0] = b[0];
                    } else {
                        merged.push(a = b);
                    }
                }
                var best = -Infinity, d;
                for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {
                    b = merged[i];
                    if ((d = angle(a[1], b[0])) > best)
                        best = d, 0 = b[0], 1 = a[1];
                }
            }
            ranges = range = null;
            return 0 === Infinity || 0 === Infinity ? [
                [
                    NaN,
                    NaN
                ],
                [
                    NaN,
                    NaN
                ]
            ] : [
                [
                    0,
                    0
                ],
                [
                    1,
                    1
                ]
            ];
        };
    }();
    d3.geo.centroid = function (object) {
        d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
        d3.geo.stream(object, d3_geo_centroid);
        var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;
        if (m < 2) {
            x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
            if (d3_geo_centroidW1 < )
                x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
            m = x * x + y * y + z * z;
            if (m < 2)
                return [
                    NaN,
                    NaN
                ];
        }
        return [
            Math.atan2(y, x) * d3_degrees,
            d3_asin(z / Math.sqrt(m)) * d3_degrees
        ];
    };
    var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;
    var d3_geo_centroid = {
        sphere: d3_noop,
        point: d3_geo_centroidPoint,
        lineStart: d3_geo_centroidLineStart,
        lineEnd: d3_geo_centroidLineEnd,
        polygonStart: function () {
            d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
        },
        polygonEnd: function () {
            d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
        }
    };
    function d3_geo_centroidPoint(, ) {
         *= d3_radians;
        var cos = Math.cos( *= d3_radians);
        d3_geo_centroidPointXYZ(cos * Math.cos(), cos * Math.sin(), Math.sin());
    }
    function d3_geo_centroidPointXYZ(x, y, z) {
        ++d3_geo_centroidW0;
        d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
        d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
        d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
    }
    function d3_geo_centroidLineStart() {
        var x0, y0, z0;
        d3_geo_centroid.point = function (, ) {
             *= d3_radians;
            var cos = Math.cos( *= d3_radians);
            x0 = cos * Math.cos();
            y0 = cos * Math.sin();
            z0 = Math.sin();
            d3_geo_centroid.point = nextPoint;
            d3_geo_centroidPointXYZ(x0, y0, z0);
        };
        function nextPoint(, ) {
             *= d3_radians;
            var cos = Math.cos( *= d3_radians), x = cos * Math.cos(), y = cos * Math.sin(), z = Math.sin(), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
            d3_geo_centroidW1 += w;
            d3_geo_centroidX1 += w * (x0 + (x0 = x));
            d3_geo_centroidY1 += w * (y0 + (y0 = y));
            d3_geo_centroidZ1 += w * (z0 + (z0 = z));
            d3_geo_centroidPointXYZ(x0, y0, z0);
        }
    }
    function d3_geo_centroidLineEnd() {
        d3_geo_centroid.point = d3_geo_centroidPoint;
    }
    function d3_geo_centroidRingStart() {
        var 00, 00, x0, y0, z0;
        d3_geo_centroid.point = function (, ) {
            00 = , 00 = ;
            d3_geo_centroid.point = nextPoint;
             *= d3_radians;
            var cos = Math.cos( *= d3_radians);
            x0 = cos * Math.cos();
            y0 = cos * Math.sin();
            z0 = Math.sin();
            d3_geo_centroidPointXYZ(x0, y0, z0);
        };
        d3_geo_centroid.lineEnd = function () {
            nextPoint(00, 00);
            d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
            d3_geo_centroid.point = d3_geo_centroidPoint;
        };
        function nextPoint(, ) {
             *= d3_radians;
            var cos = Math.cos( *= d3_radians), x = cos * Math.cos(), y = cos * Math.sin(), z = Math.sin(), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);
            d3_geo_centroidX2 += v * cx;
            d3_geo_centroidY2 += v * cy;
            d3_geo_centroidZ2 += v * cz;
            d3_geo_centroidW1 += w;
            d3_geo_centroidX1 += w * (x0 + (x0 = x));
            d3_geo_centroidY1 += w * (y0 + (y0 = y));
            d3_geo_centroidZ1 += w * (z0 + (z0 = z));
            d3_geo_centroidPointXYZ(x0, y0, z0);
        }
    }
    function d3_geo_compose(a, b) {
        function compose(x, y) {
            return x = a(x, y), b(x[0], x[1]);
        }
        if (a.invert && b.invert)
            compose.invert = function (x, y) {
                return x = b.invert(x, y), x && a.invert(x[0], x[1]);
            };
        return compose;
    }
    function d3_true() {
        return true;
    }
    function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
        var subject = [], clip = [];
        segments.forEach(function (segment) {
            if ((n = segment.length - 1) <= 0)
                return;
            var n, p0 = segment[0], p1 = segment[n];
            if (d3_geo_sphericalEqual(p0, p1)) {
                listener.lineStart();
                for (var i = 0; i < n; ++i)
                    listener.point((p0 = segment[i])[0], p0[1]);
                listener.lineEnd();
                return;
            }
            var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
            a.o = b;
            subject.push(a);
            clip.push(b);
            a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
            b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
            a.o = b;
            subject.push(a);
            clip.push(b);
        });
        clip.sort(compare);
        d3_geo_clipPolygonLinkCircular(subject);
        d3_geo_clipPolygonLinkCircular(clip);
        if (!subject.length)
            return;
        for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {
            clip[i].e = entry = !entry;
        }
        var start = subject[0], points, point;
        while (1) {
            var current = start, isSubject = true;
            while (current.v)
                if ((current = current.n) === start)
                    return;
            points = current.z;
            listener.lineStart();
            do {
                current.v = current.o.v = true;
                if (current.e) {
                    if (isSubject) {
                        for (var i = 0, n = points.length; i < n; ++i)
                            listener.point((point = points[i])[0], point[1]);
                    } else {
                        interpolate(current.x, current.n.x, 1, listener);
                    }
                    current = current.n;
                } else {
                    if (isSubject) {
                        points = current.p.z;
                        for (var i = points.length - 1; i >= 0; --i)
                            listener.point((point = points[i])[0], point[1]);
                    } else {
                        interpolate(current.x, current.p.x, -1, listener);
                    }
                    current = current.p;
                }
                current = current.o;
                points = current.z;
                isSubject = !isSubject;
            } while (!current.v);
            listener.lineEnd();
        }
    }
    function d3_geo_clipPolygonLinkCircular(array) {
        if (!(n = array.length))
            return;
        var n, i = 0, a = array[0], b;
        while (++i < n) {
            a.n = b = array[i];
            b.p = a;
            a = b;
        }
        a.n = b = array[0];
        b.p = a;
    }
    function d3_geo_clipPolygonIntersection(point, points, other, entry) {
        this.x = point;
        this.z = points;
        this.o = other;
        this.e = entry;
        this.v = false;
        this.n = this.p = null;
    }
    function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
        return function (rotate, listener) {
            var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
            var clip = {
                point: point,
                lineStart: lineStart,
                lineEnd: lineEnd,
                polygonStart: function () {
                    clip.point = pointRing;
                    clip.lineStart = ringStart;
                    clip.lineEnd = ringEnd;
                    segments = [];
                    polygon = [];
                },
                polygonEnd: function () {
                    clip.point = point;
                    clip.lineStart = lineStart;
                    clip.lineEnd = lineEnd;
                    segments = d3.merge(segments);
                    var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
                    if (segments.length) {
                        if (!polygonStarted)
                            listener.polygonStart(), polygonStarted = true;
                        d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
                    } else if (clipStartInside) {
                        if (!polygonStarted)
                            listener.polygonStart(), polygonStarted = true;
                        listener.lineStart();
                        interpolate(null, null, 1, listener);
                        listener.lineEnd();
                    }
                    if (polygonStarted)
                        listener.polygonEnd(), polygonStarted = false;
                    segments = polygon = null;
                },
                sphere: function () {
                    listener.polygonStart();
                    listener.lineStart();
                    interpolate(null, null, 1, listener);
                    listener.lineEnd();
                    listener.polygonEnd();
                }
            };
            function point(, ) {
                var point = rotate(, );
                if (pointVisible( = point[0],  = point[1]))
                    listener.point(, );
            }
            function pointLine(, ) {
                var point = rotate(, );
                line.point(point[0], point[1]);
            }
            function lineStart() {
                clip.point = pointLine;
                line.lineStart();
            }
            function lineEnd() {
                clip.point = point;
                line.lineEnd();
            }
            var segments;
            var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;
            function pointRing(, ) {
                ring.push([
                    ,
                    
                ]);
                var point = rotate(, );
                ringListener.point(point[0], point[1]);
            }
            function ringStart() {
                ringListener.lineStart();
                ring = [];
            }
            function ringEnd() {
                pointRing(ring[0][0], ring[0][1]);
                ringListener.lineEnd();
                var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
                ring.pop();
                polygon.push(ring);
                ring = null;
                if (!n)
                    return;
                if (clean & 1) {
                    segment = ringSegments[0];
                    var n = segment.length - 1, i = -1, point;
                    if (n > 0) {
                        if (!polygonStarted)
                            listener.polygonStart(), polygonStarted = true;
                        listener.lineStart();
                        while (++i < n)
                            listener.point((point = segment[i])[0], point[1]);
                        listener.lineEnd();
                    }
                    return;
                }
                if (n > 1 && clean & 2)
                    ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
                segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
            }
            return clip;
        };
    }
    function d3_geo_clipSegmentLength1(segment) {
        return segment.length > 1;
    }
    function d3_geo_clipBufferListener() {
        var lines = [], line;
        return {
            lineStart: function () {
                lines.push(line = []);
            },
            point: function (, ) {
                line.push([
                    ,
                    
                ]);
            },
            lineEnd: d3_noop,
            buffer: function () {
                var buffer = lines;
                lines = [];
                line = null;
                return buffer;
            },
            rejoin: function () {
                if (lines.length > 1)
                    lines.push(lines.pop().concat(lines.shift()));
            }
        };
    }
    function d3_geo_clipSort(a, b) {
        return ((a = a.x)[0] < 0 ? a[1] - half -  : half - a[1]) - ((b = b.x)[0] < 0 ? b[1] - half -  : half - b[1]);
    }
    var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [
        -,
        - / 2
    ]);
    function d3_geo_clipAntimeridianLine(listener) {
        var 0 = NaN, 0 = NaN, s0 = NaN, clean;
        return {
            lineStart: function () {
                listener.lineStart();
                clean = 1;
            },
            point: function (1, 1) {
                var s1 = 1 > 0 ?  : -, d = abs(1 - 0);
                if (abs(d - ) < ) {
                    listener.point(0, 0 = (0 + 1) / 2 > 0 ? half : -half);
                    listener.point(s0, 0);
                    listener.lineEnd();
                    listener.lineStart();
                    listener.point(s1, 0);
                    listener.point(1, 0);
                    clean = 0;
                } else if (s0 !== s1 && d >= ) {
                    if (abs(0 - s0) < )
                        0 -= s0 * ;
                    if (abs(1 - s1) < )
                        1 -= s1 * ;
                    0 = d3_geo_clipAntimeridianIntersect(0, 0, 1, 1);
                    listener.point(s0, 0);
                    listener.lineEnd();
                    listener.lineStart();
                    listener.point(s1, 0);
                    clean = 0;
                }
                listener.point(0 = 1, 0 = 1);
                s0 = s1;
            },
            lineEnd: function () {
                listener.lineEnd();
                0 = 0 = NaN;
            },
            clean: function () {
                return 2 - clean;
            }
        };
    }
    function d3_geo_clipAntimeridianIntersect(0, 0, 1, 1) {
        var cos0, cos1, sin0_1 = Math.sin(0 - 1);
        return abs(sin0_1) >  ? Math.atan((Math.sin(0) * (cos1 = Math.cos(1)) * Math.sin(1) - Math.sin(1) * (cos0 = Math.cos(0)) * Math.sin(0)) / (cos0 * cos1 * sin0_1)) : (0 + 1) / 2;
    }
    function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
        var ;
        if (from == null) {
             = direction * half;
            listener.point(-, );
            listener.point(0, );
            listener.point(, );
            listener.point(, 0);
            listener.point(, -);
            listener.point(0, -);
            listener.point(-, -);
            listener.point(-, 0);
            listener.point(-, );
        } else if (abs(from[0] - to[0]) > ) {
            var s = from[0] < to[0] ?  : -;
             = direction * s / 2;
            listener.point(-s, );
            listener.point(0, );
            listener.point(s, );
        } else {
            listener.point(to[0], to[1]);
        }
    }
    function d3_geo_pointInPolygon(point, polygon) {
        var meridian = point[0], parallel = point[1], meridianNormal = [
                Math.sin(meridian),
                -Math.cos(meridian),
                0
            ], polarAngle = 0, winding = 0;
        d3_geo_areaRingSum.reset();
        for (var i = 0, n = polygon.length; i < n; ++i) {
            var ring = polygon[i], m = ring.length;
            if (!m)
                continue;
            var point0 = ring[0], 0 = point0[0], 0 = point0[1] / 2 +  / 4, sin0 = Math.sin(0), cos0 = Math.cos(0), j = 1;
            while (true) {
                if (j === m)
                    j = 0;
                point = ring[j];
                var  = point[0],  = point[1] / 2 +  / 4, sin = Math.sin(), cos = Math.cos(), d =  - 0, sd = d >= 0 ? 1 : -1, ad = sd * d, antimeridian = ad > , k = sin0 * sin;
                d3_geo_areaRingSum.add(Math.atan2(k * sd * Math.sin(ad), cos0 * cos + k * Math.cos(ad)));
                polarAngle += antimeridian ? d + sd *  : d;
                if (antimeridian ^ 0 >= meridian ^  >= meridian) {
                    var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
                    d3_geo_cartesianNormalize(arc);
                    var intersection = d3_geo_cartesianCross(meridianNormal, arc);
                    d3_geo_cartesianNormalize(intersection);
                    var arc = (antimeridian ^ d >= 0 ? -1 : 1) * d3_asin(intersection[2]);
                    if (parallel > arc || parallel === arc && (arc[0] || arc[1])) {
                        winding += antimeridian ^ d >= 0 ? 1 : -1;
                    }
                }
                if (!j++)
                    break;
                0 = , sin0 = sin, cos0 = cos, point0 = point;
            }
        }
        return (polarAngle < - || polarAngle <  && d3_geo_areaRingSum < 0) ^ winding & 1;
    }
    function d3_geo_clipCircle(radius) {
        var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > , interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
        return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [
            0,
            -radius
        ] : [
            -,
            radius - 
        ]);
        function visible(, ) {
            return Math.cos() * Math.cos() > cr;
        }
        function clipLine(listener) {
            var point0, c0, v0, v00, clean;
            return {
                lineStart: function () {
                    v00 = v0 = false;
                    clean = 1;
                },
                point: function (, ) {
                    var point1 = [
                            ,
                            
                        ], point2, v = visible(, ), c = smallRadius ? v ? 0 : code(, ) : v ? code( + ( < 0 ?  : -), ) : 0;
                    if (!point0 && (v00 = v0 = v))
                        listener.lineStart();
                    if (v !== v0) {
                        point2 = intersect(point0, point1);
                        if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
                            point1[0] += ;
                            point1[1] += ;
                            v = visible(point1[0], point1[1]);
                        }
                    }
                    if (v !== v0) {
                        clean = 0;
                        if (v) {
                            listener.lineStart();
                            point2 = intersect(point1, point0);
                            listener.point(point2[0], point2[1]);
                        } else {
                            point2 = intersect(point0, point1);
                            listener.point(point2[0], point2[1]);
                            listener.lineEnd();
                        }
                        point0 = point2;
                    } else if (notHemisphere && point0 && smallRadius ^ v) {
                        var t;
                        if (!(c & c0) && (t = intersect(point1, point0, true))) {
                            clean = 0;
                            if (smallRadius) {
                                listener.lineStart();
                                listener.point(t[0][0], t[0][1]);
                                listener.point(t[1][0], t[1][1]);
                                listener.lineEnd();
                            } else {
                                listener.point(t[1][0], t[1][1]);
                                listener.lineEnd();
                                listener.lineStart();
                                listener.point(t[0][0], t[0][1]);
                            }
                        }
                    }
                    if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
                        listener.point(point1[0], point1[1]);
                    }
                    point0 = point1, v0 = v, c0 = c;
                },
                lineEnd: function () {
                    if (v0)
                        listener.lineEnd();
                    point0 = null;
                },
                clean: function () {
                    return clean | (v00 && v0) << 1;
                }
            };
        }
        function intersect(a, b, two) {
            var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);
            var n1 = [
                    1,
                    0,
                    0
                ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
            if (!determinant)
                return !two && a;
            var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
            d3_geo_cartesianAdd(A, B);
            var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
            if (t2 < 0)
                return;
            var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);
            d3_geo_cartesianAdd(q, A);
            q = d3_geo_spherical(q);
            if (!two)
                return q;
            var 0 = a[0], 1 = b[0], 0 = a[1], 1 = b[1], z;
            if (1 < 0)
                z = 0, 0 = 1, 1 = z;
            var  = 1 - 0, polar = abs( - ) < , meridian = polar ||  < ;
            if (!polar && 1 < 0)
                z = 0, 0 = 1, 1 = z;
            if (meridian ? polar ? 0 + 1 > 0 ^ q[1] < (abs(q[0] - 0) <  ? 0 : 1) : 0 <= q[1] && q[1] <= 1 :  >  ^ (0 <= q[0] && q[0] <= 1)) {
                var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
                d3_geo_cartesianAdd(q1, A);
                return [
                    q,
                    d3_geo_spherical(q1)
                ];
            }
        }
        function code(, ) {
            var r = smallRadius ? radius :  - radius, code = 0;
            if ( < -r)
                code |= 1;
            else if ( > r)
                code |= 2;
            if ( < -r)
                code |= 4;
            else if ( > r)
                code |= 8;
            return code;
        }
    }
    function d3_geom_clipLine(x0, y0, x1, y1) {
        return function (line) {
            var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
            r = x0 - ax;
            if (!dx && r > 0)
                return;
            r /= dx;
            if (dx < 0) {
                if (r < t0)
                    return;
                if (r < t1)
                    t1 = r;
            } else if (dx > 0) {
                if (r > t1)
                    return;
                if (r > t0)
                    t0 = r;
            }
            r = x1 - ax;
            if (!dx && r < 0)
                return;
            r /= dx;
            if (dx < 0) {
                if (r > t1)
                    return;
                if (r > t0)
                    t0 = r;
            } else if (dx > 0) {
                if (r < t0)
                    return;
                if (r < t1)
                    t1 = r;
            }
            r = y0 - ay;
            if (!dy && r > 0)
                return;
            r /= dy;
            if (dy < 0) {
                if (r < t0)
                    return;
                if (r < t1)
                    t1 = r;
            } else if (dy > 0) {
                if (r > t1)
                    return;
                if (r > t0)
                    t0 = r;
            }
            r = y1 - ay;
            if (!dy && r < 0)
                return;
            r /= dy;
            if (dy < 0) {
                if (r > t1)
                    return;
                if (r > t0)
                    t0 = r;
            } else if (dy > 0) {
                if (r < t0)
                    return;
                if (r < t1)
                    t1 = r;
            }
            if (t0 > 0)
                line.a = {
                    x: ax + t0 * dx,
                    y: ay + t0 * dy
                };
            if (t1 < 1)
                line.b = {
                    x: ax + t1 * dx,
                    y: ay + t1 * dy
                };
            return line;
        };
    }
    var d3_geo_clipExtentMAX = 1000000000;
    d3.geo.clipExtent = function () {
        var x0, y0, x1, y1, stream, clip, clipExtent = {
                stream: function (output) {
                    if (stream)
                        stream.valid = false;
                    stream = clip(output);
                    stream.valid = true;
                    return stream;
                },
                extent: function (_) {
                    if (!arguments.length)
                        return [
                            [
                                x0,
                                y0
                            ],
                            [
                                x1,
                                y1
                            ]
                        ];
                    clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
                    if (stream)
                        stream.valid = false, stream = null;
                    return clipExtent;
                }
            };
        return clipExtent.extent([
            [
                0,
                0
            ],
            [
                960,
                500
            ]
        ]);
    };
    function d3_geo_clipExtent(x0, y0, x1, y1) {
        return function (listener) {
            var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;
            var clip = {
                point: point,
                lineStart: lineStart,
                lineEnd: lineEnd,
                polygonStart: function () {
                    listener = bufferListener;
                    segments = [];
                    polygon = [];
                    clean = true;
                },
                polygonEnd: function () {
                    listener = listener_;
                    segments = d3.merge(segments);
                    var clipStartInside = insidePolygon([
                            x0,
                            y1
                        ]), inside = clean && clipStartInside, visible = segments.length;
                    if (inside || visible) {
                        listener.polygonStart();
                        if (inside) {
                            listener.lineStart();
                            interpolate(null, null, 1, listener);
                            listener.lineEnd();
                        }
                        if (visible) {
                            d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
                        }
                        listener.polygonEnd();
                    }
                    segments = polygon = ring = null;
                }
            };
            function insidePolygon(p) {
                var wn = 0, n = polygon.length, y = p[1];
                for (var i = 0; i < n; ++i) {
                    for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {
                        b = v[j];
                        if (a[1] <= y) {
                            if (b[1] > y && d3_cross2d(a, b, p) > 0)
                                ++wn;
                        } else {
                            if (b[1] <= y && d3_cross2d(a, b, p) < 0)
                                --wn;
                        }
                        a = b;
                    }
                }
                return wn !== 0;
            }
            function interpolate(from, to, direction, listener) {
                var a = 0, a1 = 0;
                if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
                    do {
                        listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
                    } while ((a = (a + direction + 4) % 4) !== a1);
                } else {
                    listener.point(to[0], to[1]);
                }
            }
            function pointVisible(x, y) {
                return x0 <= x && x <= x1 && y0 <= y && y <= y1;
            }
            function point(x, y) {
                if (pointVisible(x, y))
                    listener.point(x, y);
            }
            var x__, y__, v__, x_, y_, v_, first, clean;
            function lineStart() {
                clip.point = linePoint;
                if (polygon)
                    polygon.push(ring = []);
                first = true;
                v_ = false;
                x_ = y_ = NaN;
            }
            function lineEnd() {
                if (segments) {
                    linePoint(x__, y__);
                    if (v__ && v_)
                        bufferListener.rejoin();
                    segments.push(bufferListener.buffer());
                }
                clip.point = point;
                if (v_)
                    listener.lineEnd();
            }
            function linePoint(x, y) {
                x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
                y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
                var v = pointVisible(x, y);
                if (polygon)
                    ring.push([
                        x,
                        y
                    ]);
                if (first) {
                    x__ = x, y__ = y, v__ = v;
                    first = false;
                    if (v) {
                        listener.lineStart();
                        listener.point(x, y);
                    }
                } else {
                    if (v && v_)
                        listener.point(x, y);
                    else {
                        var l = {
                            a: {
                                x: x_,
                                y: y_
                            },
                            b: {
                                x: x,
                                y: y
                            }
                        };
                        if (clipLine(l)) {
                            if (!v_) {
                                listener.lineStart();
                                listener.point(l.a.x, l.a.y);
                            }
                            listener.point(l.b.x, l.b.y);
                            if (!v)
                                listener.lineEnd();
                            clean = false;
                        } else if (v) {
                            listener.lineStart();
                            listener.point(x, y);
                            clean = false;
                        }
                    }
                }
                x_ = x, y_ = y, v_ = v;
            }
            return clip;
        };
        function corner(p, direction) {
            return abs(p[0] - x0) <  ? direction > 0 ? 0 : 3 : abs(p[0] - x1) <  ? direction > 0 ? 2 : 1 : abs(p[1] - y0) <  ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
        }
        function compare(a, b) {
            return comparePoints(a.x, b.x);
        }
        function comparePoints(a, b) {
            var ca = corner(a, 1), cb = corner(b, 1);
            return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
        }
    }
    function d3_geo_conic(projectAt) {
        var 0 = 0, 1 =  / 3, m = d3_geo_projectionMutator(projectAt), p = m(0, 1);
        p.parallels = function (_) {
            if (!arguments.length)
                return [
                    0 /  * 180,
                    1 /  * 180
                ];
            return m(0 = _[0] *  / 180, 1 = _[1] *  / 180);
        };
        return p;
    }
    function d3_geo_conicEqualArea(0, 1) {
        var sin0 = Math.sin(0), n = (sin0 + Math.sin(1)) / 2, C = 1 + sin0 * (2 * n - sin0), 0 = Math.sqrt(C) / n;
        function forward(, ) {
            var  = Math.sqrt(C - 2 * n * Math.sin()) / n;
            return [
                 * Math.sin( *= n),
                0 -  * Math.cos()
            ];
        }
        forward.invert = function (x, y) {
            var 0_y = 0 - y;
            return [
                Math.atan2(x, 0_y) / n,
                d3_asin((C - (x * x + 0_y * 0_y) * n * n) / (2 * n))
            ];
        };
        return forward;
    }
    (d3.geo.conicEqualArea = function () {
        return d3_geo_conic(d3_geo_conicEqualArea);
    }).raw = d3_geo_conicEqualArea;
    d3.geo.albers = function () {
        return d3.geo.conicEqualArea().rotate([
            96,
            0
        ]).center([
            -0.6,
            38.7
        ]).parallels([
            29.5,
            45.5
        ]).scale(1070);
    };
    d3.geo.albersUsa = function () {
        var lower48 = d3.geo.albers();
        var alaska = d3.geo.conicEqualArea().rotate([
            154,
            0
        ]).center([
            -2,
            58.5
        ]).parallels([
            55,
            65
        ]);
        var hawaii = d3.geo.conicEqualArea().rotate([
            157,
            0
        ]).center([
            -3,
            19.9
        ]).parallels([
            8,
            18
        ]);
        var point, pointStream = {
                point: function (x, y) {
                    point = [
                        x,
                        y
                    ];
                }
            }, lower48Point, alaskaPoint, hawaiiPoint;
        function albersUsa(coordinates) {
            var x = coordinates[0], y = coordinates[1];
            point = null;
            (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
            return point;
        }
        albersUsa.invert = function (coordinates) {
            var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
            return (y >= 0.12 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii : lower48).invert(coordinates);
        };
        albersUsa.stream = function (stream) {
            var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);
            return {
                point: function (x, y) {
                    lower48Stream.point(x, y);
                    alaskaStream.point(x, y);
                    hawaiiStream.point(x, y);
                },
                sphere: function () {
                    lower48Stream.sphere();
                    alaskaStream.sphere();
                    hawaiiStream.sphere();
                },
                lineStart: function () {
                    lower48Stream.lineStart();
                    alaskaStream.lineStart();
                    hawaiiStream.lineStart();
                },
                lineEnd: function () {
                    lower48Stream.lineEnd();
                    alaskaStream.lineEnd();
                    hawaiiStream.lineEnd();
                },
                polygonStart: function () {
                    lower48Stream.polygonStart();
                    alaskaStream.polygonStart();
                    hawaiiStream.polygonStart();
                },
                polygonEnd: function () {
                    lower48Stream.polygonEnd();
                    alaskaStream.polygonEnd();
                    hawaiiStream.polygonEnd();
                }
            };
        };
        albersUsa.precision = function (_) {
            if (!arguments.length)
                return lower48.precision();
            lower48.precision(_);
            alaska.precision(_);
            hawaii.precision(_);
            return albersUsa;
        };
        albersUsa.scale = function (_) {
            if (!arguments.length)
                return lower48.scale();
            lower48.scale(_);
            alaska.scale(_ * 0.35);
            hawaii.scale(_);
            return albersUsa.translate(lower48.translate());
        };
        albersUsa.translate = function (_) {
            if (!arguments.length)
                return lower48.translate();
            var k = lower48.scale(), x = +_[0], y = +_[1];
            lower48Point = lower48.translate(_).clipExtent([
                [
                    x - 0.455 * k,
                    y - 0.238 * k
                ],
                [
                    x + 0.455 * k,
                    y + 0.238 * k
                ]
            ]).stream(pointStream).point;
            alaskaPoint = alaska.translate([
                x - 0.307 * k,
                y + 0.201 * k
            ]).clipExtent([
                [
                    x - 0.425 * k + ,
                    y + 0.12 * k + 
                ],
                [
                    x - 0.214 * k - ,
                    y + 0.234 * k - 
                ]
            ]).stream(pointStream).point;
            hawaiiPoint = hawaii.translate([
                x - 0.205 * k,
                y + 0.212 * k
            ]).clipExtent([
                [
                    x - 0.214 * k + ,
                    y + 0.166 * k + 
                ],
                [
                    x - 0.115 * k - ,
                    y + 0.234 * k - 
                ]
            ]).stream(pointStream).point;
            return albersUsa;
        };
        return albersUsa.scale(1070);
    };
    var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
            point: d3_noop,
            lineStart: d3_noop,
            lineEnd: d3_noop,
            polygonStart: function () {
                d3_geo_pathAreaPolygon = 0;
                d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
            },
            polygonEnd: function () {
                d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
                d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
            }
        };
    function d3_geo_pathAreaRingStart() {
        var x00, y00, x0, y0;
        d3_geo_pathArea.point = function (x, y) {
            d3_geo_pathArea.point = nextPoint;
            x00 = x0 = x, y00 = y0 = y;
        };
        function nextPoint(x, y) {
            d3_geo_pathAreaPolygon += y0 * x - x0 * y;
            x0 = x, y0 = y;
        }
        d3_geo_pathArea.lineEnd = function () {
            nextPoint(x00, y00);
        };
    }
    var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;
    var d3_geo_pathBounds = {
        point: d3_geo_pathBoundsPoint,
        lineStart: d3_noop,
        lineEnd: d3_noop,
        polygonStart: d3_noop,
        polygonEnd: d3_noop
    };
    function d3_geo_pathBoundsPoint(x, y) {
        if (x < d3_geo_pathBoundsX0)
            d3_geo_pathBoundsX0 = x;
        if (x > d3_geo_pathBoundsX1)
            d3_geo_pathBoundsX1 = x;
        if (y < d3_geo_pathBoundsY0)
            d3_geo_pathBoundsY0 = y;
        if (y > d3_geo_pathBoundsY1)
            d3_geo_pathBoundsY1 = y;
    }
    function d3_geo_pathBuffer() {
        var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];
        var stream = {
            point: point,
            lineStart: function () {
                stream.point = pointLineStart;
            },
            lineEnd: lineEnd,
            polygonStart: function () {
                stream.lineEnd = lineEndPolygon;
            },
            polygonEnd: function () {
                stream.lineEnd = lineEnd;
                stream.point = point;
            },
            pointRadius: function (_) {
                pointCircle = d3_geo_pathBufferCircle(_);
                return stream;
            },
            result: function () {
                if (buffer.length) {
                    var result = buffer.join('');
                    buffer = [];
                    return result;
                }
            }
        };
        function point(x, y) {
            buffer.push('M', x, ',', y, pointCircle);
        }
        function pointLineStart(x, y) {
            buffer.push('M', x, ',', y);
            stream.point = pointLine;
        }
        function pointLine(x, y) {
            buffer.push('L', x, ',', y);
        }
        function lineEnd() {
            stream.point = point;
        }
        function lineEndPolygon() {
            buffer.push('Z');
        }
        return stream;
    }
    function d3_geo_pathBufferCircle(radius) {
        return 'm0,' + radius + 'a' + radius + ',' + radius + ' 0 1,1 0,' + -2 * radius + 'a' + radius + ',' + radius + ' 0 1,1 0,' + 2 * radius + 'z';
    }
    var d3_geo_pathCentroid = {
        point: d3_geo_pathCentroidPoint,
        lineStart: d3_geo_pathCentroidLineStart,
        lineEnd: d3_geo_pathCentroidLineEnd,
        polygonStart: function () {
            d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
        },
        polygonEnd: function () {
            d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
            d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
            d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
        }
    };
    function d3_geo_pathCentroidPoint(x, y) {
        d3_geo_centroidX0 += x;
        d3_geo_centroidY0 += y;
        ++d3_geo_centroidZ0;
    }
    function d3_geo_pathCentroidLineStart() {
        var x0, y0;
        d3_geo_pathCentroid.point = function (x, y) {
            d3_geo_pathCentroid.point = nextPoint;
            d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        };
        function nextPoint(x, y) {
            var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
            d3_geo_centroidX1 += z * (x0 + x) / 2;
            d3_geo_centroidY1 += z * (y0 + y) / 2;
            d3_geo_centroidZ1 += z;
            d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        }
    }
    function d3_geo_pathCentroidLineEnd() {
        d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
    }
    function d3_geo_pathCentroidRingStart() {
        var x00, y00, x0, y0;
        d3_geo_pathCentroid.point = function (x, y) {
            d3_geo_pathCentroid.point = nextPoint;
            d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
        };
        function nextPoint(x, y) {
            var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
            d3_geo_centroidX1 += z * (x0 + x) / 2;
            d3_geo_centroidY1 += z * (y0 + y) / 2;
            d3_geo_centroidZ1 += z;
            z = y0 * x - x0 * y;
            d3_geo_centroidX2 += z * (x0 + x);
            d3_geo_centroidY2 += z * (y0 + y);
            d3_geo_centroidZ2 += z * 3;
            d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        }
        d3_geo_pathCentroid.lineEnd = function () {
            nextPoint(x00, y00);
        };
    }
    function d3_geo_pathContext(context) {
        var pointRadius = 4.5;
        var stream = {
            point: point,
            lineStart: function () {
                stream.point = pointLineStart;
            },
            lineEnd: lineEnd,
            polygonStart: function () {
                stream.lineEnd = lineEndPolygon;
            },
            polygonEnd: function () {
                stream.lineEnd = lineEnd;
                stream.point = point;
            },
            pointRadius: function (_) {
                pointRadius = _;
                return stream;
            },
            result: d3_noop
        };
        function point(x, y) {
            context.moveTo(x + pointRadius, y);
            context.arc(x, y, pointRadius, 0, );
        }
        function pointLineStart(x, y) {
            context.moveTo(x, y);
            stream.point = pointLine;
        }
        function pointLine(x, y) {
            context.lineTo(x, y);
        }
        function lineEnd() {
            stream.point = point;
        }
        function lineEndPolygon() {
            context.closePath();
        }
        return stream;
    }
    function d3_geo_resample(project) {
        var 2 = 0.5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;
        function resample(stream) {
            return (maxDepth ? resampleRecursive : resampleNone)(stream);
        }
        function resampleNone(stream) {
            return d3_geo_transformPoint(stream, function (x, y) {
                x = project(x, y);
                stream.point(x[0], x[1]);
            });
        }
        function resampleRecursive(stream) {
            var 00, 00, x00, y00, a00, b00, c00, 0, x0, y0, a0, b0, c0;
            var resample = {
                point: point,
                lineStart: lineStart,
                lineEnd: lineEnd,
                polygonStart: function () {
                    stream.polygonStart();
                    resample.lineStart = ringStart;
                },
                polygonEnd: function () {
                    stream.polygonEnd();
                    resample.lineStart = lineStart;
                }
            };
            function point(x, y) {
                x = project(x, y);
                stream.point(x[0], x[1]);
            }
            function lineStart() {
                x0 = NaN;
                resample.point = linePoint;
                stream.lineStart();
            }
            function linePoint(, ) {
                var c = d3_geo_cartesian([
                        ,
                        
                    ]), p = project(, );
                resampleLineTo(x0, y0, 0, a0, b0, c0, x0 = p[0], y0 = p[1], 0 = , a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
                stream.point(x0, y0);
            }
            function lineEnd() {
                resample.point = point;
                stream.lineEnd();
            }
            function ringStart() {
                lineStart();
                resample.point = ringPoint;
                resample.lineEnd = ringEnd;
            }
            function ringPoint(, ) {
                linePoint(00 = , 00 = ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
                resample.point = linePoint;
            }
            function ringEnd() {
                resampleLineTo(x0, y0, 0, a0, b0, c0, x00, y00, 00, a00, b00, c00, maxDepth, stream);
                resample.lineEnd = lineEnd;
                lineEnd();
            }
            return resample;
        }
        function resampleLineTo(x0, y0, 0, a0, b0, c0, x1, y1, 1, a1, b1, c1, depth, stream) {
            var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
            if (d2 > 4 * 2 && depth--) {
                var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), 2 = Math.asin(c /= m), 2 = abs(abs(c) - 1) <  || abs(0 - 1) <  ? (0 + 1) / 2 : Math.atan2(b, a), p = project(2, 2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
                if (dz * dz / d2 > 2 || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
                    resampleLineTo(x0, y0, 0, a0, b0, c0, x2, y2, 2, a /= m, b /= m, c, depth, stream);
                    stream.point(x2, y2);
                    resampleLineTo(x2, y2, 2, a, b, c, x1, y1, 1, a1, b1, c1, depth, stream);
                }
            }
        }
        resample.precision = function (_) {
            if (!arguments.length)
                return Math.sqrt(2);
            maxDepth = (2 = _ * _) > 0 && 16;
            return resample;
        };
        return resample;
    }
    d3.geo.path = function () {
        var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;
        function path(object) {
            if (object) {
                if (typeof pointRadius === 'function')
                    contextStream.pointRadius(+pointRadius.apply(this, arguments));
                if (!cacheStream || !cacheStream.valid)
                    cacheStream = projectStream(contextStream);
                d3.geo.stream(object, cacheStream);
            }
            return contextStream.result();
        }
        path.area = function (object) {
            d3_geo_pathAreaSum = 0;
            d3.geo.stream(object, projectStream(d3_geo_pathArea));
            return d3_geo_pathAreaSum;
        };
        path.centroid = function (object) {
            d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
            d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
            return d3_geo_centroidZ2 ? [
                d3_geo_centroidX2 / d3_geo_centroidZ2,
                d3_geo_centroidY2 / d3_geo_centroidZ2
            ] : d3_geo_centroidZ1 ? [
                d3_geo_centroidX1 / d3_geo_centroidZ1,
                d3_geo_centroidY1 / d3_geo_centroidZ1
            ] : d3_geo_centroidZ0 ? [
                d3_geo_centroidX0 / d3_geo_centroidZ0,
                d3_geo_centroidY0 / d3_geo_centroidZ0
            ] : [
                NaN,
                NaN
            ];
        };
        path.bounds = function (object) {
            d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
            d3.geo.stream(object, projectStream(d3_geo_pathBounds));
            return [
                [
                    d3_geo_pathBoundsX0,
                    d3_geo_pathBoundsY0
                ],
                [
                    d3_geo_pathBoundsX1,
                    d3_geo_pathBoundsY1
                ]
            ];
        };
        path.projection = function (_) {
            if (!arguments.length)
                return projection;
            projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
            return reset();
        };
        path.context = function (_) {
            if (!arguments.length)
                return context;
            contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
            if (typeof pointRadius !== 'function')
                contextStream.pointRadius(pointRadius);
            return reset();
        };
        path.pointRadius = function (_) {
            if (!arguments.length)
                return pointRadius;
            pointRadius = typeof _ === 'function' ? _ : (contextStream.pointRadius(+_), +_);
            return path;
        };
        function reset() {
            cacheStream = null;
            return path;
        }
        return path.projection(d3.geo.albersUsa()).context(null);
    };
    function d3_geo_pathProjectStream(project) {
        var resample = d3_geo_resample(function (x, y) {
            return project([
                x * d3_degrees,
                y * d3_degrees
            ]);
        });
        return function (stream) {
            return d3_geo_projectionRadians(resample(stream));
        };
    }
    d3.geo.transform = function (methods) {
        return {
            stream: function (stream) {
                var transform = new d3_geo_transform(stream);
                for (var k in methods)
                    transform[k] = methods[k];
                return transform;
            }
        };
    };
    function d3_geo_transform(stream) {
        this.stream = stream;
    }
    d3_geo_transform.prototype = {
        point: function (x, y) {
            this.stream.point(x, y);
        },
        sphere: function () {
            this.stream.sphere();
        },
        lineStart: function () {
            this.stream.lineStart();
        },
        lineEnd: function () {
            this.stream.lineEnd();
        },
        polygonStart: function () {
            this.stream.polygonStart();
        },
        polygonEnd: function () {
            this.stream.polygonEnd();
        }
    };
    function d3_geo_transformPoint(stream, point) {
        return {
            point: point,
            sphere: function () {
                stream.sphere();
            },
            lineStart: function () {
                stream.lineStart();
            },
            lineEnd: function () {
                stream.lineEnd();
            },
            polygonStart: function () {
                stream.polygonStart();
            },
            polygonEnd: function () {
                stream.polygonEnd();
            }
        };
    }
    d3.geo.projection = d3_geo_projection;
    d3.geo.projectionMutator = d3_geo_projectionMutator;
    function d3_geo_projection(project) {
        return d3_geo_projectionMutator(function () {
            return project;
        })();
    }
    function d3_geo_projectionMutator(projectAt) {
        var project, rotate, projectRotate, projectResample = d3_geo_resample(function (x, y) {
                x = project(x, y);
                return [
                    x[0] * k + x,
                    y - x[1] * k
                ];
            }), k = 150, x = 480, y = 250,  = 0,  = 0,  = 0,  = 0,  = 0, x, y, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;
        function projection(point) {
            point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
            return [
                point[0] * k + x,
                y - point[1] * k
            ];
        }
        function invert(point) {
            point = projectRotate.invert((point[0] - x) / k, (y - point[1]) / k);
            return point && [
                point[0] * d3_degrees,
                point[1] * d3_degrees
            ];
        }
        projection.stream = function (output) {
            if (stream)
                stream.valid = false;
            stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
            stream.valid = true;
            return stream;
        };
        projection.clipAngle = function (_) {
            if (!arguments.length)
                return clipAngle;
            preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
            return invalidate();
        };
        projection.clipExtent = function (_) {
            if (!arguments.length)
                return clipExtent;
            clipExtent = _;
            postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
            return invalidate();
        };
        projection.scale = function (_) {
            if (!arguments.length)
                return k;
            k = +_;
            return reset();
        };
        projection.translate = function (_) {
            if (!arguments.length)
                return [
                    x,
                    y
                ];
            x = +_[0];
            y = +_[1];
            return reset();
        };
        projection.center = function (_) {
            if (!arguments.length)
                return [
                     * d3_degrees,
                     * d3_degrees
                ];
             = _[0] % 360 * d3_radians;
             = _[1] % 360 * d3_radians;
            return reset();
        };
        projection.rotate = function (_) {
            if (!arguments.length)
                return [
                     * d3_degrees,
                     * d3_degrees,
                     * d3_degrees
                ];
             = _[0] % 360 * d3_radians;
             = _[1] % 360 * d3_radians;
             = _.length > 2 ? _[2] % 360 * d3_radians : 0;
            return reset();
        };
        d3.rebind(projection, projectResample, 'precision');
        function reset() {
            projectRotate = d3_geo_compose(rotate = d3_geo_rotation(, , ), project);
            var center = project(, );
            x = x - center[0] * k;
            y = y + center[1] * k;
            return invalidate();
        }
        function invalidate() {
            if (stream)
                stream.valid = false, stream = null;
            return projection;
        }
        return function () {
            project = projectAt.apply(this, arguments);
            projection.invert = project.invert && invert;
            return reset();
        };
    }
    function d3_geo_projectionRadians(stream) {
        return d3_geo_transformPoint(stream, function (x, y) {
            stream.point(x * d3_radians, y * d3_radians);
        });
    }
    function d3_geo_equirectangular(, ) {
        return [
            ,
            
        ];
    }
    (d3.geo.equirectangular = function () {
        return d3_geo_projection(d3_geo_equirectangular);
    }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
    d3.geo.rotation = function (rotate) {
        rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
        function forward(coordinates) {
            coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
            return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
        }
        forward.invert = function (coordinates) {
            coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
            return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
        };
        return forward;
    };
    function d3_geo_identityRotation(, ) {
        return [
             >  ?  -  :  < - ?  +  : ,
            
        ];
    }
    d3_geo_identityRotation.invert = d3_geo_equirectangular;
    function d3_geo_rotation(, , ) {
        return  ?  ||  ? d3_geo_compose(d3_geo_rotation(), d3_geo_rotation(, )) : d3_geo_rotation() :  ||  ? d3_geo_rotation(, ) : d3_geo_identityRotation;
    }
    function d3_geo_forwardRotation() {
        return function (, ) {
            return  += , [
                 >  ?  -  :  < - ?  +  : ,
                
            ];
        };
    }
    function d3_geo_rotation() {
        var rotation = d3_geo_forwardRotation();
        rotation.invert = d3_geo_forwardRotation(-);
        return rotation;
    }
    function d3_geo_rotation(, ) {
        var cos = Math.cos(), sin = Math.sin(), cos = Math.cos(), sin = Math.sin();
        function rotation(, ) {
            var cos = Math.cos(), x = Math.cos() * cos, y = Math.sin() * cos, z = Math.sin(), k = z * cos + x * sin;
            return [
                Math.atan2(y * cos - k * sin, x * cos - z * sin),
                d3_asin(k * cos + y * sin)
            ];
        }
        rotation.invert = function (, ) {
            var cos = Math.cos(), x = Math.cos() * cos, y = Math.sin() * cos, z = Math.sin(), k = z * cos - y * sin;
            return [
                Math.atan2(y * cos + z * sin, x * cos + k * sin),
                d3_asin(k * cos - x * sin)
            ];
        };
        return rotation;
    }
    d3.geo.circle = function () {
        var origin = [
                0,
                0
            ], angle, precision = 6, interpolate;
        function circle() {
            var center = typeof origin === 'function' ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
            interpolate(null, null, 1, {
                point: function (x, y) {
                    ring.push(x = rotate(x, y));
                    x[0] *= d3_degrees, x[1] *= d3_degrees;
                }
            });
            return {
                type: 'Polygon',
                coordinates: [ring]
            };
        }
        circle.origin = function (x) {
            if (!arguments.length)
                return origin;
            origin = x;
            return circle;
        };
        circle.angle = function (x) {
            if (!arguments.length)
                return angle;
            interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
            return circle;
        };
        circle.precision = function (_) {
            if (!arguments.length)
                return precision;
            interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
            return circle;
        };
        return circle.angle(90);
    };
    function d3_geo_circleInterpolate(radius, precision) {
        var cr = Math.cos(radius), sr = Math.sin(radius);
        return function (from, to, direction, listener) {
            var step = direction * precision;
            if (from != null) {
                from = d3_geo_circleAngle(cr, from);
                to = d3_geo_circleAngle(cr, to);
                if (direction > 0 ? from < to : from > to)
                    from += direction * ;
            } else {
                from = radius + direction * ;
                to = radius - 0.5 * step;
            }
            for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {
                listener.point((point = d3_geo_spherical([
                    cr,
                    -sr * Math.cos(t),
                    -sr * Math.sin(t)
                ]))[0], point[1]);
            }
        };
    }
    function d3_geo_circleAngle(cr, point) {
        var a = d3_geo_cartesian(point);
        a[0] -= cr;
        d3_geo_cartesianNormalize(a);
        var angle = d3_acos(-a[1]);
        return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ) % (2 * Math.PI);
    }
    d3.geo.distance = function (a, b) {
        var  = (b[0] - a[0]) * d3_radians, 0 = a[1] * d3_radians, 1 = b[1] * d3_radians, sin = Math.sin(), cos = Math.cos(), sin0 = Math.sin(0), cos0 = Math.cos(0), sin1 = Math.sin(1), cos1 = Math.cos(1), t;
        return Math.atan2(Math.sqrt((t = cos1 * sin) * t + (t = cos0 * sin1 - sin0 * cos1 * cos) * t), sin0 * sin1 + cos0 * cos1 * cos);
    };
    d3.geo.graticule = function () {
        var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
        function graticule() {
            return {
                type: 'MultiLineString',
                coordinates: lines()
            };
        }
        function lines() {
            return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function (x) {
                return abs(x % DX) > ;
            }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function (y) {
                return abs(y % DY) > ;
            }).map(y));
        }
        graticule.lines = function () {
            return lines().map(function (coordinates) {
                return {
                    type: 'LineString',
                    coordinates: coordinates
                };
            });
        };
        graticule.outline = function () {
            return {
                type: 'Polygon',
                coordinates: [X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1))]
            };
        };
        graticule.extent = function (_) {
            if (!arguments.length)
                return graticule.minorExtent();
            return graticule.majorExtent(_).minorExtent(_);
        };
        graticule.majorExtent = function (_) {
            if (!arguments.length)
                return [
                    [
                        X0,
                        Y0
                    ],
                    [
                        X1,
                        Y1
                    ]
                ];
            X0 = +_[0][0], X1 = +_[1][0];
            Y0 = +_[0][1], Y1 = +_[1][1];
            if (X0 > X1)
                _ = X0, X0 = X1, X1 = _;
            if (Y0 > Y1)
                _ = Y0, Y0 = Y1, Y1 = _;
            return graticule.precision(precision);
        };
        graticule.minorExtent = function (_) {
            if (!arguments.length)
                return [
                    [
                        x0,
                        y0
                    ],
                    [
                        x1,
                        y1
                    ]
                ];
            x0 = +_[0][0], x1 = +_[1][0];
            y0 = +_[0][1], y1 = +_[1][1];
            if (x0 > x1)
                _ = x0, x0 = x1, x1 = _;
            if (y0 > y1)
                _ = y0, y0 = y1, y1 = _;
            return graticule.precision(precision);
        };
        graticule.step = function (_) {
            if (!arguments.length)
                return graticule.minorStep();
            return graticule.majorStep(_).minorStep(_);
        };
        graticule.majorStep = function (_) {
            if (!arguments.length)
                return [
                    DX,
                    DY
                ];
            DX = +_[0], DY = +_[1];
            return graticule;
        };
        graticule.minorStep = function (_) {
            if (!arguments.length)
                return [
                    dx,
                    dy
                ];
            dx = +_[0], dy = +_[1];
            return graticule;
        };
        graticule.precision = function (_) {
            if (!arguments.length)
                return precision;
            precision = +_;
            x = d3_geo_graticuleX(y0, y1, 90);
            y = d3_geo_graticuleY(x0, x1, precision);
            X = d3_geo_graticuleX(Y0, Y1, 90);
            Y = d3_geo_graticuleY(X0, X1, precision);
            return graticule;
        };
        return graticule.majorExtent([
            [
                -180,
                -90 + 
            ],
            [
                180,
                90 - 
            ]
        ]).minorExtent([
            [
                -180,
                -80 - 
            ],
            [
                180,
                80 + 
            ]
        ]);
    };
    function d3_geo_graticuleX(y0, y1, dy) {
        var y = d3.range(y0, y1 - , dy).concat(y1);
        return function (x) {
            return y.map(function (y) {
                return [
                    x,
                    y
                ];
            });
        };
    }
    function d3_geo_graticuleY(x0, x1, dx) {
        var x = d3.range(x0, x1 - , dx).concat(x1);
        return function (y) {
            return x.map(function (x) {
                return [
                    x,
                    y
                ];
            });
        };
    }
    function d3_source(d) {
        return d.source;
    }
    function d3_target(d) {
        return d.target;
    }
    d3.geo.greatArc = function () {
        var source = d3_source, source_, target = d3_target, target_;
        function greatArc() {
            return {
                type: 'LineString',
                coordinates: [
                    source_ || source.apply(this, arguments),
                    target_ || target.apply(this, arguments)
                ]
            };
        }
        greatArc.distance = function () {
            return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
        };
        greatArc.source = function (_) {
            if (!arguments.length)
                return source;
            source = _, source_ = typeof _ === 'function' ? null : _;
            return greatArc;
        };
        greatArc.target = function (_) {
            if (!arguments.length)
                return target;
            target = _, target_ = typeof _ === 'function' ? null : _;
            return greatArc;
        };
        greatArc.precision = function () {
            return arguments.length ? greatArc : 0;
        };
        return greatArc;
    };
    d3.geo.interpolate = function (source, target) {
        return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
    };
    function d3_geo_interpolate(x0, y0, x1, y1) {
        var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);
        var interpolate = d ? function (t) {
            var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
            return [
                Math.atan2(y, x) * d3_degrees,
                Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees
            ];
        } : function () {
            return [
                x0 * d3_degrees,
                y0 * d3_degrees
            ];
        };
        interpolate.distance = d;
        return interpolate;
    }
    d3.geo.length = function (object) {
        d3_geo_lengthSum = 0;
        d3.geo.stream(object, d3_geo_length);
        return d3_geo_lengthSum;
    };
    var d3_geo_lengthSum;
    var d3_geo_length = {
        sphere: d3_noop,
        point: d3_noop,
        lineStart: d3_geo_lengthLineStart,
        lineEnd: d3_noop,
        polygonStart: d3_noop,
        polygonEnd: d3_noop
    };
    function d3_geo_lengthLineStart() {
        var 0, sin0, cos0;
        d3_geo_length.point = function (, ) {
            0 =  * d3_radians, sin0 = Math.sin( *= d3_radians), cos0 = Math.cos();
            d3_geo_length.point = nextPoint;
        };
        d3_geo_length.lineEnd = function () {
            d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
        };
        function nextPoint(, ) {
            var sin = Math.sin( *= d3_radians), cos = Math.cos(), t = abs(( *= d3_radians) - 0), cos = Math.cos(t);
            d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cos * Math.sin(t)) * t + (t = cos0 * sin - sin0 * cos * cos) * t), sin0 * sin + cos0 * cos * cos);
            0 = , sin0 = sin, cos0 = cos;
        }
    }
    function d3_geo_azimuthal(scale, angle) {
        function azimuthal(, ) {
            var cos = Math.cos(), cos = Math.cos(), k = scale(cos * cos);
            return [
                k * cos * Math.sin(),
                k * Math.sin()
            ];
        }
        azimuthal.invert = function (x, y) {
            var  = Math.sqrt(x * x + y * y), c = angle(), sinc = Math.sin(c), cosc = Math.cos(c);
            return [
                Math.atan2(x * sinc,  * cosc),
                Math.asin( && y * sinc / )
            ];
        };
        return azimuthal;
    }
    var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function (coscos) {
        return Math.sqrt(2 / (1 + coscos));
    }, function () {
        return 2 * Math.asin( / 2);
    });
    (d3.geo.azimuthalEqualArea = function () {
        return d3_geo_projection(d3_geo_azimuthalEqualArea);
    }).raw = d3_geo_azimuthalEqualArea;
    var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function (coscos) {
        var c = Math.acos(coscos);
        return c && c / Math.sin(c);
    }, d3_identity);
    (d3.geo.azimuthalEquidistant = function () {
        return d3_geo_projection(d3_geo_azimuthalEquidistant);
    }).raw = d3_geo_azimuthalEquidistant;
    function d3_geo_conicConformal(0, 1) {
        var cos0 = Math.cos(0), t = function () {
                return Math.tan( / 4 +  / 2);
            }, n = 0 === 1 ? Math.sin(0) : Math.log(cos0 / Math.cos(1)) / Math.log(t(1) / t(0)), F = cos0 * Math.pow(t(0), n) / n;
        if (!n)
            return d3_geo_mercator;
        function forward(, ) {
            if (F > 0) {
                if ( < -half + )
                     = -half + ;
            } else {
                if ( > half - )
                     = half - ;
            }
            var  = F / Math.pow(t(), n);
            return [
                 * Math.sin(n * ),
                F -  * Math.cos(n * )
            ];
        }
        forward.invert = function (x, y) {
            var 0_y = F - y,  = d3_sgn(n) * Math.sqrt(x * x + 0_y * 0_y);
            return [
                Math.atan2(x, 0_y) / n,
                2 * Math.atan(Math.pow(F / , 1 / n)) - half
            ];
        };
        return forward;
    }
    (d3.geo.conicConformal = function () {
        return d3_geo_conic(d3_geo_conicConformal);
    }).raw = d3_geo_conicConformal;
    function d3_geo_conicEquidistant(0, 1) {
        var cos0 = Math.cos(0), n = 0 === 1 ? Math.sin(0) : (cos0 - Math.cos(1)) / (1 - 0), G = cos0 / n + 0;
        if (abs(n) < )
            return d3_geo_equirectangular;
        function forward(, ) {
            var  = G - ;
            return [
                 * Math.sin(n * ),
                G -  * Math.cos(n * )
            ];
        }
        forward.invert = function (x, y) {
            var 0_y = G - y;
            return [
                Math.atan2(x, 0_y) / n,
                G - d3_sgn(n) * Math.sqrt(x * x + 0_y * 0_y)
            ];
        };
        return forward;
    }
    (d3.geo.conicEquidistant = function () {
        return d3_geo_conic(d3_geo_conicEquidistant);
    }).raw = d3_geo_conicEquidistant;
    var d3_geo_gnomonic = d3_geo_azimuthal(function (coscos) {
        return 1 / coscos;
    }, Math.atan);
    (d3.geo.gnomonic = function () {
        return d3_geo_projection(d3_geo_gnomonic);
    }).raw = d3_geo_gnomonic;
    function d3_geo_mercator(, ) {
        return [
            ,
            Math.log(Math.tan( / 4 +  / 2))
        ];
    }
    d3_geo_mercator.invert = function (x, y) {
        return [
            x,
            2 * Math.atan(Math.exp(y)) - half
        ];
    };
    function d3_geo_mercatorProjection(project) {
        var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;
        m.scale = function () {
            var v = scale.apply(m, arguments);
            return v === m ? clipAuto ? m.clipExtent(null) : m : v;
        };
        m.translate = function () {
            var v = translate.apply(m, arguments);
            return v === m ? clipAuto ? m.clipExtent(null) : m : v;
        };
        m.clipExtent = function (_) {
            var v = clipExtent.apply(m, arguments);
            if (v === m) {
                if (clipAuto = _ == null) {
                    var k =  * scale(), t = translate();
                    clipExtent([
                        [
                            t[0] - k,
                            t[1] - k
                        ],
                        [
                            t[0] + k,
                            t[1] + k
                        ]
                    ]);
                }
            } else if (clipAuto) {
                v = null;
            }
            return v;
        };
        return m.clipExtent(null);
    }
    (d3.geo.mercator = function () {
        return d3_geo_mercatorProjection(d3_geo_mercator);
    }).raw = d3_geo_mercator;
    var d3_geo_orthographic = d3_geo_azimuthal(function () {
        return 1;
    }, Math.asin);
    (d3.geo.orthographic = function () {
        return d3_geo_projection(d3_geo_orthographic);
    }).raw = d3_geo_orthographic;
    var d3_geo_stereographic = d3_geo_azimuthal(function (coscos) {
        return 1 / (1 + coscos);
    }, function () {
        return 2 * Math.atan();
    });
    (d3.geo.stereographic = function () {
        return d3_geo_projection(d3_geo_stereographic);
    }).raw = d3_geo_stereographic;
    function d3_geo_transverseMercator(, ) {
        return [
            Math.log(Math.tan( / 4 +  / 2)),
            -
        ];
    }
    d3_geo_transverseMercator.invert = function (x, y) {
        return [
            -y,
            2 * Math.atan(Math.exp(x)) - half
        ];
    };
    (d3.geo.transverseMercator = function () {
        var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;
        projection.center = function (_) {
            return _ ? center([
                -_[1],
                _[0]
            ]) : (_ = center(), [
                _[1],
                -_[0]
            ]);
        };
        projection.rotate = function (_) {
            return _ ? rotate([
                _[0],
                _[1],
                _.length > 2 ? _[2] + 90 : 90
            ]) : (_ = rotate(), [
                _[0],
                _[1],
                _[2] - 90
            ]);
        };
        return rotate([
            0,
            0,
            90
        ]);
    }).raw = d3_geo_transverseMercator;
    d3.geom = {};
    function d3_geom_pointX(d) {
        return d[0];
    }
    function d3_geom_pointY(d) {
        return d[1];
    }
    d3.geom.hull = function (vertices) {
        var x = d3_geom_pointX, y = d3_geom_pointY;
        if (arguments.length)
            return hull(vertices);
        function hull(data) {
            if (data.length < 3)
                return [];
            var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];
            for (i = 0; i < n; i++) {
                points.push([
                    +fx.call(this, data[i], i),
                    +fy.call(this, data[i], i),
                    i
                ]);
            }
            points.sort(d3_geom_hullOrder);
            for (i = 0; i < n; i++)
                flippedPoints.push([
                    points[i][0],
                    -points[i][1]
                ]);
            var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);
            var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];
            for (i = upper.length - 1; i >= 0; --i)
                polygon.push(data[points[upper[i]][2]]);
            for (i = +skipLeft; i < lower.length - skipRight; ++i)
                polygon.push(data[points[lower[i]][2]]);
            return polygon;
        }
        hull.x = function (_) {
            return arguments.length ? (x = _, hull) : x;
        };
        hull.y = function (_) {
            return arguments.length ? (y = _, hull) : y;
        };
        return hull;
    };
    function d3_geom_hullUpper(points) {
        var n = points.length, hull = [
                0,
                1
            ], hs = 2;
        for (var i = 2; i < n; i++) {
            while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0)
                --hs;
            hull[hs++] = i;
        }
        return hull.slice(0, hs);
    }
    function d3_geom_hullOrder(a, b) {
        return a[0] - b[0] || a[1] - b[1];
    }
    d3.geom.polygon = function (coordinates) {
        d3_subclass(coordinates, d3_geom_polygonPrototype);
        return coordinates;
    };
    var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
    d3_geom_polygonPrototype.area = function () {
        var i = -1, n = this.length, a, b = this[n - 1], area = 0;
        while (++i < n) {
            a = b;
            b = this[i];
            area += a[1] * b[0] - a[0] * b[1];
        }
        return area * 0.5;
    };
    d3_geom_polygonPrototype.centroid = function (k) {
        var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;
        if (!arguments.length)
            k = -1 / (6 * this.area());
        while (++i < n) {
            a = b;
            b = this[i];
            c = a[0] * b[1] - b[0] * a[1];
            x += (a[0] + b[0]) * c;
            y += (a[1] + b[1]) * c;
        }
        return [
            x * k,
            y * k
        ];
    };
    d3_geom_polygonPrototype.clip = function (subject) {
        var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;
        while (++i < n) {
            input = subject.slice();
            subject.length = 0;
            b = this[i];
            c = input[(m = input.length - closed) - 1];
            j = -1;
            while (++j < m) {
                d = input[j];
                if (d3_geom_polygonInside(d, a, b)) {
                    if (!d3_geom_polygonInside(c, a, b)) {
                        subject.push(d3_geom_polygonIntersect(c, d, a, b));
                    }
                    subject.push(d);
                } else if (d3_geom_polygonInside(c, a, b)) {
                    subject.push(d3_geom_polygonIntersect(c, d, a, b));
                }
                c = d;
            }
            if (closed)
                subject.push(subject[0]);
            a = b;
        }
        return subject;
    };
    function d3_geom_polygonInside(p, a, b) {
        return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
    }
    function d3_geom_polygonIntersect(c, d, a, b) {
        var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
        return [
            x1 + ua * x21,
            y1 + ua * y21
        ];
    }
    function d3_geom_polygonClosed(coordinates) {
        var a = coordinates[0], b = coordinates[coordinates.length - 1];
        return !(a[0] - b[0] || a[1] - b[1]);
    }
    var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
    function d3_geom_voronoiBeach() {
        d3_geom_voronoiRedBlackNode(this);
        this.edge = this.site = this.circle = null;
    }
    function d3_geom_voronoiCreateBeach(site) {
        var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
        beach.site = site;
        return beach;
    }
    function d3_geom_voronoiDetachBeach(beach) {
        d3_geom_voronoiDetachCircle(beach);
        d3_geom_voronoiBeaches.remove(beach);
        d3_geom_voronoiBeachPool.push(beach);
        d3_geom_voronoiRedBlackNode(beach);
    }
    function d3_geom_voronoiRemoveBeach(beach) {
        var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {
                x: x,
                y: y
            }, previous = beach.P, next = beach.N, disappearing = [beach];
        d3_geom_voronoiDetachBeach(beach);
        var lArc = previous;
        while (lArc.circle && abs(x - lArc.circle.x) <  && abs(y - lArc.circle.cy) < ) {
            previous = lArc.P;
            disappearing.unshift(lArc);
            d3_geom_voronoiDetachBeach(lArc);
            lArc = previous;
        }
        disappearing.unshift(lArc);
        d3_geom_voronoiDetachCircle(lArc);
        var rArc = next;
        while (rArc.circle && abs(x - rArc.circle.x) <  && abs(y - rArc.circle.cy) < ) {
            next = rArc.N;
            disappearing.push(rArc);
            d3_geom_voronoiDetachBeach(rArc);
            rArc = next;
        }
        disappearing.push(rArc);
        d3_geom_voronoiDetachCircle(rArc);
        var nArcs = disappearing.length, iArc;
        for (iArc = 1; iArc < nArcs; ++iArc) {
            rArc = disappearing[iArc];
            lArc = disappearing[iArc - 1];
            d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
        }
        lArc = disappearing[0];
        rArc = disappearing[nArcs - 1];
        rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
        d3_geom_voronoiAttachCircle(lArc);
        d3_geom_voronoiAttachCircle(rArc);
    }
    function d3_geom_voronoiAddBeach(site) {
        var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
        while (node) {
            dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
            if (dxl > )
                node = node.L;
            else {
                dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
                if (dxr > ) {
                    if (!node.R) {
                        lArc = node;
                        break;
                    }
                    node = node.R;
                } else {
                    if (dxl > -) {
                        lArc = node.P;
                        rArc = node;
                    } else if (dxr > -) {
                        lArc = node;
                        rArc = node.N;
                    } else {
                        lArc = rArc = node;
                    }
                    break;
                }
            }
        }
        var newArc = d3_geom_voronoiCreateBeach(site);
        d3_geom_voronoiBeaches.insert(lArc, newArc);
        if (!lArc && !rArc)
            return;
        if (lArc === rArc) {
            d3_geom_voronoiDetachCircle(lArc);
            rArc = d3_geom_voronoiCreateBeach(lArc.site);
            d3_geom_voronoiBeaches.insert(newArc, rArc);
            newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
            d3_geom_voronoiAttachCircle(lArc);
            d3_geom_voronoiAttachCircle(rArc);
            return;
        }
        if (!rArc) {
            newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
            return;
        }
        d3_geom_voronoiDetachCircle(lArc);
        d3_geom_voronoiDetachCircle(rArc);
        var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {
                x: (cy * hb - by * hc) / d + ax,
                y: (bx * hc - cx * hb) / d + ay
            };
        d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
        newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
        rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
        d3_geom_voronoiAttachCircle(lArc);
        d3_geom_voronoiAttachCircle(rArc);
    }
    function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
        var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
        if (!pby2)
            return rfocx;
        var lArc = arc.P;
        if (!lArc)
            return -Infinity;
        site = lArc.site;
        var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
        if (!plby2)
            return lfocx;
        var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
        if (aby2)
            return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
        return (rfocx + lfocx) / 2;
    }
    function d3_geom_voronoiRightBreakPoint(arc, directrix) {
        var rArc = arc.N;
        if (rArc)
            return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
        var site = arc.site;
        return site.y === directrix ? site.x : Infinity;
    }
    function d3_geom_voronoiCell(site) {
        this.site = site;
        this.edges = [];
    }
    d3_geom_voronoiCell.prototype.prepare = function () {
        var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
        while (iHalfEdge--) {
            edge = halfEdges[iHalfEdge].edge;
            if (!edge.b || !edge.a)
                halfEdges.splice(iHalfEdge, 1);
        }
        halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
        return halfEdges.length;
    };
    function d3_geom_voronoiCloseCells(extent) {
        var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;
        while (iCell--) {
            cell = cells[iCell];
            if (!cell || !cell.prepare())
                continue;
            halfEdges = cell.edges;
            nHalfEdges = halfEdges.length;
            iHalfEdge = 0;
            while (iHalfEdge < nHalfEdges) {
                end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
                start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
                if (abs(x3 - x2) >  || abs(y3 - y2) > ) {
                    halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) <  && y1 - y3 >  ? {
                        x: x0,
                        y: abs(x2 - x0) <  ? y2 : y1
                    } : abs(y3 - y1) <  && x1 - x3 >  ? {
                        x: abs(y2 - y1) <  ? x2 : x1,
                        y: y1
                    } : abs(x3 - x1) <  && y3 - y0 >  ? {
                        x: x1,
                        y: abs(x2 - x1) <  ? y2 : y0
                    } : abs(y3 - y0) <  && x3 - x0 >  ? {
                        x: abs(y2 - y0) <  ? x2 : x0,
                        y: y0
                    } : null), cell.site, null));
                    ++nHalfEdges;
                }
            }
        }
    }
    function d3_geom_voronoiHalfEdgeOrder(a, b) {
        return b.angle - a.angle;
    }
    function d3_geom_voronoiCircle() {
        d3_geom_voronoiRedBlackNode(this);
        this.x = this.y = this.arc = this.site = this.cy = null;
    }
    function d3_geom_voronoiAttachCircle(arc) {
        var lArc = arc.P, rArc = arc.N;
        if (!lArc || !rArc)
            return;
        var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
        if (lSite === rSite)
            return;
        var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
        var d = 2 * (ax * cy - ay * cx);
        if (d >= -2)
            return;
        var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;
        var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
        circle.arc = arc;
        circle.site = cSite;
        circle.x = x + bx;
        circle.y = cy + Math.sqrt(x * x + y * y);
        circle.cy = cy;
        arc.circle = circle;
        var before = null, node = d3_geom_voronoiCircles._;
        while (node) {
            if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
                if (node.L)
                    node = node.L;
                else {
                    before = node.P;
                    break;
                }
            } else {
                if (node.R)
                    node = node.R;
                else {
                    before = node;
                    break;
                }
            }
        }
        d3_geom_voronoiCircles.insert(before, circle);
        if (!before)
            d3_geom_voronoiFirstCircle = circle;
    }
    function d3_geom_voronoiDetachCircle(arc) {
        var circle = arc.circle;
        if (circle) {
            if (!circle.P)
                d3_geom_voronoiFirstCircle = circle.N;
            d3_geom_voronoiCircles.remove(circle);
            d3_geom_voronoiCirclePool.push(circle);
            d3_geom_voronoiRedBlackNode(circle);
            arc.circle = null;
        }
    }
    function d3_geom_voronoiClipEdges(extent) {
        var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;
        while (i--) {
            e = edges[i];
            if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) <  && abs(e.a.y - e.b.y) < ) {
                e.a = e.b = null;
                edges.splice(i, 1);
            }
        }
    }
    function d3_geom_voronoiConnectEdge(edge, extent) {
        var vb = edge.b;
        if (vb)
            return true;
        var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
        if (ry === ly) {
            if (fx < x0 || fx >= x1)
                return;
            if (lx > rx) {
                if (!va)
                    va = {
                        x: fx,
                        y: y0
                    };
                else if (va.y >= y1)
                    return;
                vb = {
                    x: fx,
                    y: y1
                };
            } else {
                if (!va)
                    va = {
                        x: fx,
                        y: y1
                    };
                else if (va.y < y0)
                    return;
                vb = {
                    x: fx,
                    y: y0
                };
            }
        } else {
            fm = (lx - rx) / (ry - ly);
            fb = fy - fm * fx;
            if (fm < -1 || fm > 1) {
                if (lx > rx) {
                    if (!va)
                        va = {
                            x: (y0 - fb) / fm,
                            y: y0
                        };
                    else if (va.y >= y1)
                        return;
                    vb = {
                        x: (y1 - fb) / fm,
                        y: y1
                    };
                } else {
                    if (!va)
                        va = {
                            x: (y1 - fb) / fm,
                            y: y1
                        };
                    else if (va.y < y0)
                        return;
                    vb = {
                        x: (y0 - fb) / fm,
                        y: y0
                    };
                }
            } else {
                if (ly < ry) {
                    if (!va)
                        va = {
                            x: x0,
                            y: fm * x0 + fb
                        };
                    else if (va.x >= x1)
                        return;
                    vb = {
                        x: x1,
                        y: fm * x1 + fb
                    };
                } else {
                    if (!va)
                        va = {
                            x: x1,
                            y: fm * x1 + fb
                        };
                    else if (va.x < x0)
                        return;
                    vb = {
                        x: x0,
                        y: fm * x0 + fb
                    };
                }
            }
        }
        edge.a = va;
        edge.b = vb;
        return true;
    }
    function d3_geom_voronoiEdge(lSite, rSite) {
        this.l = lSite;
        this.r = rSite;
        this.a = this.b = null;
    }
    function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
        var edge = new d3_geom_voronoiEdge(lSite, rSite);
        d3_geom_voronoiEdges.push(edge);
        if (va)
            d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
        if (vb)
            d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
        d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
        d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
        return edge;
    }
    function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
        var edge = new d3_geom_voronoiEdge(lSite, null);
        edge.a = va;
        edge.b = vb;
        d3_geom_voronoiEdges.push(edge);
        return edge;
    }
    function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
        if (!edge.a && !edge.b) {
            edge.a = vertex;
            edge.l = lSite;
            edge.r = rSite;
        } else if (edge.l === rSite) {
            edge.b = vertex;
        } else {
            edge.a = vertex;
        }
    }
    function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
        var va = edge.a, vb = edge.b;
        this.edge = edge;
        this.site = lSite;
        this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
    }
    d3_geom_voronoiHalfEdge.prototype = {
        start: function () {
            return this.edge.l === this.site ? this.edge.a : this.edge.b;
        },
        end: function () {
            return this.edge.l === this.site ? this.edge.b : this.edge.a;
        }
    };
    function d3_geom_voronoiRedBlackTree() {
        this._ = null;
    }
    function d3_geom_voronoiRedBlackNode(node) {
        node.U = node.C = node.L = node.R = node.P = node.N = null;
    }
    d3_geom_voronoiRedBlackTree.prototype = {
        insert: function (after, node) {
            var parent, grandpa, uncle;
            if (after) {
                node.P = after;
                node.N = after.N;
                if (after.N)
                    after.N.P = node;
                after.N = node;
                if (after.R) {
                    after = after.R;
                    while (after.L)
                        after = after.L;
                    after.L = node;
                } else {
                    after.R = node;
                }
                parent = after;
            } else if (this._) {
                after = d3_geom_voronoiRedBlackFirst(this._);
                node.P = null;
                node.N = after;
                after.P = after.L = node;
                parent = after;
            } else {
                node.P = node.N = null;
                this._ = node;
                parent = null;
            }
            node.L = node.R = null;
            node.U = parent;
            node.C = true;
            after = node;
            while (parent && parent.C) {
                grandpa = parent.U;
                if (parent === grandpa.L) {
                    uncle = grandpa.R;
                    if (uncle && uncle.C) {
                        parent.C = uncle.C = false;
                        grandpa.C = true;
                        after = grandpa;
                    } else {
                        if (after === parent.R) {
                            d3_geom_voronoiRedBlackRotateLeft(this, parent);
                            after = parent;
                            parent = after.U;
                        }
                        parent.C = false;
                        grandpa.C = true;
                        d3_geom_voronoiRedBlackRotateRight(this, grandpa);
                    }
                } else {
                    uncle = grandpa.L;
                    if (uncle && uncle.C) {
                        parent.C = uncle.C = false;
                        grandpa.C = true;
                        after = grandpa;
                    } else {
                        if (after === parent.L) {
                            d3_geom_voronoiRedBlackRotateRight(this, parent);
                            after = parent;
                            parent = after.U;
                        }
                        parent.C = false;
                        grandpa.C = true;
                        d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
                    }
                }
                parent = after.U;
            }
            this._.C = false;
        },
        remove: function (node) {
            if (node.N)
                node.N.P = node.P;
            if (node.P)
                node.P.N = node.N;
            node.N = node.P = null;
            var parent = node.U, sibling, left = node.L, right = node.R, next, red;
            if (!left)
                next = right;
            else if (!right)
                next = left;
            else
                next = d3_geom_voronoiRedBlackFirst(right);
            if (parent) {
                if (parent.L === node)
                    parent.L = next;
                else
                    parent.R = next;
            } else {
                this._ = next;
            }
            if (left && right) {
                red = next.C;
                next.C = node.C;
                next.L = left;
                left.U = next;
                if (next !== right) {
                    parent = next.U;
                    next.U = node.U;
                    node = next.R;
                    parent.L = node;
                    next.R = right;
                    right.U = next;
                } else {
                    next.U = parent;
                    parent = next;
                    node = next.R;
                }
            } else {
                red = node.C;
                node = next;
            }
            if (node)
                node.U = parent;
            if (red)
                return;
            if (node && node.C) {
                node.C = false;
                return;
            }
            do {
                if (node === this._)
                    break;
                if (node === parent.L) {
                    sibling = parent.R;
                    if (sibling.C) {
                        sibling.C = false;
                        parent.C = true;
                        d3_geom_voronoiRedBlackRotateLeft(this, parent);
                        sibling = parent.R;
                    }
                    if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                        if (!sibling.R || !sibling.R.C) {
                            sibling.L.C = false;
                            sibling.C = true;
                            d3_geom_voronoiRedBlackRotateRight(this, sibling);
                            sibling = parent.R;
                        }
                        sibling.C = parent.C;
                        parent.C = sibling.R.C = false;
                        d3_geom_voronoiRedBlackRotateLeft(this, parent);
                        node = this._;
                        break;
                    }
                } else {
                    sibling = parent.L;
                    if (sibling.C) {
                        sibling.C = false;
                        parent.C = true;
                        d3_geom_voronoiRedBlackRotateRight(this, parent);
                        sibling = parent.L;
                    }
                    if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                        if (!sibling.L || !sibling.L.C) {
                            sibling.R.C = false;
                            sibling.C = true;
                            d3_geom_voronoiRedBlackRotateLeft(this, sibling);
                            sibling = parent.L;
                        }
                        sibling.C = parent.C;
                        parent.C = sibling.L.C = false;
                        d3_geom_voronoiRedBlackRotateRight(this, parent);
                        node = this._;
                        break;
                    }
                }
                sibling.C = true;
                node = parent;
                parent = parent.U;
            } while (!node.C);
            if (node)
                node.C = false;
        }
    };
    function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
        var p = node, q = node.R, parent = p.U;
        if (parent) {
            if (parent.L === p)
                parent.L = q;
            else
                parent.R = q;
        } else {
            tree._ = q;
        }
        q.U = parent;
        p.U = q;
        p.R = q.L;
        if (p.R)
            p.R.U = p;
        q.L = p;
    }
    function d3_geom_voronoiRedBlackRotateRight(tree, node) {
        var p = node, q = node.L, parent = p.U;
        if (parent) {
            if (parent.L === p)
                parent.L = q;
            else
                parent.R = q;
        } else {
            tree._ = q;
        }
        q.U = parent;
        p.U = q;
        p.L = q.R;
        if (p.L)
            p.L.U = p;
        q.R = p;
    }
    function d3_geom_voronoiRedBlackFirst(node) {
        while (node.L)
            node = node.L;
        return node;
    }
    function d3_geom_voronoi(sites, bbox) {
        var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
        d3_geom_voronoiEdges = [];
        d3_geom_voronoiCells = new Array(sites.length);
        d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
        d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
        while (true) {
            circle = d3_geom_voronoiFirstCircle;
            if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
                if (site.x !== x0 || site.y !== y0) {
                    d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
                    d3_geom_voronoiAddBeach(site);
                    x0 = site.x, y0 = site.y;
                }
                site = sites.pop();
            } else if (circle) {
                d3_geom_voronoiRemoveBeach(circle.arc);
            } else {
                break;
            }
        }
        if (bbox)
            d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
        var diagram = {
            cells: d3_geom_voronoiCells,
            edges: d3_geom_voronoiEdges
        };
        d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
        return diagram;
    }
    function d3_geom_voronoiVertexOrder(a, b) {
        return b.y - a.y || b.x - a.x;
    }
    d3.geom.voronoi = function (points) {
        var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;
        if (points)
            return voronoi(points);
        function voronoi(data) {
            var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
            d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function (cell, i) {
                var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function (e) {
                        var s = e.start();
                        return [
                            s.x,
                            s.y
                        ];
                    }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [
                        [
                            x0,
                            y1
                        ],
                        [
                            x1,
                            y1
                        ],
                        [
                            x1,
                            y0
                        ],
                        [
                            x0,
                            y0
                        ]
                    ] : [];
                polygon.point = data[i];
            });
            return polygons;
        }
        function sites(data) {
            return data.map(function (d, i) {
                return {
                    x: Math.round(fx(d, i) / ) * ,
                    y: Math.round(fy(d, i) / ) * ,
                    i: i
                };
            });
        }
        voronoi.links = function (data) {
            return d3_geom_voronoi(sites(data)).edges.filter(function (edge) {
                return edge.l && edge.r;
            }).map(function (edge) {
                return {
                    source: data[edge.l.i],
                    target: data[edge.r.i]
                };
            });
        };
        voronoi.triangles = function (data) {
            var triangles = [];
            d3_geom_voronoi(sites(data)).cells.forEach(function (cell, i) {
                var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
                while (++j < m) {
                    e0 = e1;
                    s0 = s1;
                    e1 = edges[j].edge;
                    s1 = e1.l === site ? e1.r : e1.l;
                    if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
                        triangles.push([
                            data[i],
                            data[s0.i],
                            data[s1.i]
                        ]);
                    }
                }
            });
            return triangles;
        };
        voronoi.x = function (_) {
            return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
        };
        voronoi.y = function (_) {
            return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
        };
        voronoi.clipExtent = function (_) {
            if (!arguments.length)
                return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
            clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
            return voronoi;
        };
        voronoi.size = function (_) {
            if (!arguments.length)
                return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
            return voronoi.clipExtent(_ && [
                [
                    0,
                    0
                ],
                _
            ]);
        };
        return voronoi;
    };
    var d3_geom_voronoiClipExtent = [
        [
            -1000000,
            -1000000
        ],
        [
            1000000,
            1000000
        ]
    ];
    function d3_geom_voronoiTriangleArea(a, b, c) {
        return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
    }
    d3.geom.delaunay = function (vertices) {
        return d3.geom.voronoi().triangles(vertices);
    };
    d3.geom.quadtree = function (points, x1, y1, x2, y2) {
        var x = d3_geom_pointX, y = d3_geom_pointY, compat;
        if (compat = arguments.length) {
            x = d3_geom_quadtreeCompatX;
            y = d3_geom_quadtreeCompatY;
            if (compat === 3) {
                y2 = y1;
                x2 = x1;
                y1 = x1 = 0;
            }
            return quadtree(points);
        }
        function quadtree(data) {
            var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
            if (x1 != null) {
                x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
            } else {
                x2_ = y2_ = -(x1_ = y1_ = Infinity);
                xs = [], ys = [];
                n = data.length;
                if (compat)
                    for (i = 0; i < n; ++i) {
                        d = data[i];
                        if (d.x < x1_)
                            x1_ = d.x;
                        if (d.y < y1_)
                            y1_ = d.y;
                        if (d.x > x2_)
                            x2_ = d.x;
                        if (d.y > y2_)
                            y2_ = d.y;
                        xs.push(d.x);
                        ys.push(d.y);
                    }
                else
                    for (i = 0; i < n; ++i) {
                        var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
                        if (x_ < x1_)
                            x1_ = x_;
                        if (y_ < y1_)
                            y1_ = y_;
                        if (x_ > x2_)
                            x2_ = x_;
                        if (y_ > y2_)
                            y2_ = y_;
                        xs.push(x_);
                        ys.push(y_);
                    }
            }
            var dx = x2_ - x1_, dy = y2_ - y1_;
            if (dx > dy)
                y2_ = y1_ + dx;
            else
                x2_ = x1_ + dy;
            function insert(n, d, x, y, x1, y1, x2, y2) {
                if (isNaN(x) || isNaN(y))
                    return;
                if (n.leaf) {
                    var nx = n.x, ny = n.y;
                    if (nx != null) {
                        if (abs(nx - x) + abs(ny - y) < 0.01) {
                            insertChild(n, d, x, y, x1, y1, x2, y2);
                        } else {
                            var nPoint = n.point;
                            n.x = n.y = n.point = null;
                            insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
                            insertChild(n, d, x, y, x1, y1, x2, y2);
                        }
                    } else {
                        n.x = x, n.y = y, n.point = d;
                    }
                } else {
                    insertChild(n, d, x, y, x1, y1, x2, y2);
                }
            }
            function insertChild(n, d, x, y, x1, y1, x2, y2) {
                var xm = (x1 + x2) * 0.5, ym = (y1 + y2) * 0.5, right = x >= xm, below = y >= ym, i = below << 1 | right;
                n.leaf = false;
                n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
                if (right)
                    x1 = xm;
                else
                    x2 = xm;
                if (below)
                    y1 = ym;
                else
                    y2 = ym;
                insert(n, d, x, y, x1, y1, x2, y2);
            }
            var root = d3_geom_quadtreeNode();
            root.add = function (d) {
                insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
            };
            root.visit = function (f) {
                d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
            };
            root.find = function (point) {
                return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
            };
            i = -1;
            if (x1 == null) {
                while (++i < n) {
                    insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
                }
                --i;
            } else
                data.forEach(root.add);
            xs = ys = data = d = null;
            return root;
        }
        quadtree.x = function (_) {
            return arguments.length ? (x = _, quadtree) : x;
        };
        quadtree.y = function (_) {
            return arguments.length ? (y = _, quadtree) : y;
        };
        quadtree.extent = function (_) {
            if (!arguments.length)
                return x1 == null ? null : [
                    [
                        x1,
                        y1
                    ],
                    [
                        x2,
                        y2
                    ]
                ];
            if (_ == null)
                x1 = y1 = x2 = y2 = null;
            else
                x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], y2 = +_[1][1];
            return quadtree;
        };
        quadtree.size = function (_) {
            if (!arguments.length)
                return x1 == null ? null : [
                    x2 - x1,
                    y2 - y1
                ];
            if (_ == null)
                x1 = y1 = x2 = y2 = null;
            else
                x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
            return quadtree;
        };
        return quadtree;
    };
    function d3_geom_quadtreeCompatX(d) {
        return d.x;
    }
    function d3_geom_quadtreeCompatY(d) {
        return d.y;
    }
    function d3_geom_quadtreeNode() {
        return {
            leaf: true,
            nodes: [],
            point: null,
            x: null,
            y: null
        };
    }
    function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
        if (!f(node, x1, y1, x2, y2)) {
            var sx = (x1 + x2) * 0.5, sy = (y1 + y2) * 0.5, children = node.nodes;
            if (children[0])
                d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
            if (children[1])
                d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
            if (children[2])
                d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
            if (children[3])
                d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
        }
    }
    function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
        var minDistance2 = Infinity, closestPoint;
        (function find(node, x1, y1, x2, y2) {
            if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0)
                return;
            if (point = node.point) {
                var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;
                if (distance2 < minDistance2) {
                    var distance = Math.sqrt(minDistance2 = distance2);
                    x0 = x - distance, y0 = y - distance;
                    x3 = x + distance, y3 = y + distance;
                    closestPoint = point;
                }
            }
            var children = node.nodes, xm = (x1 + x2) * 0.5, ym = (y1 + y2) * 0.5, right = x >= xm, below = y >= ym;
            for (var i = below << 1 | right, j = i + 4; i < j; ++i) {
                if (node = children[i & 3])
                    switch (i & 3) {
                    case 0:
                        find(node, x1, y1, xm, ym);
                        break;
                    case 1:
                        find(node, xm, y1, x2, ym);
                        break;
                    case 2:
                        find(node, x1, ym, xm, y2);
                        break;
                    case 3:
                        find(node, xm, ym, x2, y2);
                        break;
                    }
            }
        }(root, x0, y0, x3, y3));
        return closestPoint;
    }
    d3.interpolateRgb = d3_interpolateRgb;
    function d3_interpolateRgb(a, b) {
        a = d3.rgb(a);
        b = d3.rgb(b);
        var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
        return function (t) {
            return '#' + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
        };
    }
    d3.interpolateObject = d3_interpolateObject;
    function d3_interpolateObject(a, b) {
        var i = {}, c = {}, k;
        for (k in a) {
            if (k in b) {
                i[k] = d3_interpolate(a[k], b[k]);
            } else {
                c[k] = a[k];
            }
        }
        for (k in b) {
            if (!(k in a)) {
                c[k] = b[k];
            }
        }
        return function (t) {
            for (k in i)
                c[k] = i[k](t);
            return c;
        };
    }
    d3.interpolateNumber = d3_interpolateNumber;
    function d3_interpolateNumber(a, b) {
        a = +a, b = +b;
        return function (t) {
            return a * (1 - t) + b * t;
        };
    }
    d3.interpolateString = d3_interpolateString;
    function d3_interpolateString(a, b) {
        var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
        a = a + '', b = b + '';
        while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
            if ((bs = bm.index) > bi) {
                bs = b.slice(bi, bs);
                if (s[i])
                    s[i] += bs;
                else
                    s[++i] = bs;
            }
            if ((am = am[0]) === (bm = bm[0])) {
                if (s[i])
                    s[i] += bm;
                else
                    s[++i] = bm;
            } else {
                s[++i] = null;
                q.push({
                    i: i,
                    x: d3_interpolateNumber(am, bm)
                });
            }
            bi = d3_interpolate_numberB.lastIndex;
        }
        if (bi < b.length) {
            bs = b.slice(bi);
            if (s[i])
                s[i] += bs;
            else
                s[++i] = bs;
        }
        return s.length < 2 ? q[0] ? (b = q[0].x, function (t) {
            return b(t) + '';
        }) : function () {
            return b;
        } : (b = q.length, function (t) {
            for (var i = 0, o; i < b; ++i)
                s[(o = q[i]).i] = o.x(t);
            return s.join('');
        });
    }
    var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, 'g');
    d3.interpolate = d3_interpolate;
    function d3_interpolate(a, b) {
        var i = d3.interpolators.length, f;
        while (--i >= 0 && !(f = d3.interpolators[i](a, b)));
        return f;
    }
    d3.interpolators = [function (a, b) {
            var t = typeof b;
            return (t === 'string' ? d3_rgb_names.has(b) || /^(#|rgb\(|hsl\()/.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === 'object' && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
        }];
    d3.interpolateArray = d3_interpolateArray;
    function d3_interpolateArray(a, b) {
        var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
        for (i = 0; i < n0; ++i)
            x.push(d3_interpolate(a[i], b[i]));
        for (; i < na; ++i)
            c[i] = a[i];
        for (; i < nb; ++i)
            c[i] = b[i];
        return function (t) {
            for (i = 0; i < n0; ++i)
                c[i] = x[i](t);
            return c;
        };
    }
    var d3_ease_default = function () {
        return d3_identity;
    };
    var d3_ease = d3.map({
        linear: d3_ease_default,
        poly: d3_ease_poly,
        quad: function () {
            return d3_ease_quad;
        },
        cubic: function () {
            return d3_ease_cubic;
        },
        sin: function () {
            return d3_ease_sin;
        },
        exp: function () {
            return d3_ease_exp;
        },
        circle: function () {
            return d3_ease_circle;
        },
        elastic: d3_ease_elastic,
        back: d3_ease_back,
        bounce: function () {
            return d3_ease_bounce;
        }
    });
    var d3_ease_mode = d3.map({
        'in': d3_identity,
        out: d3_ease_reverse,
        'in-out': d3_ease_reflect,
        'out-in': function (f) {
            return d3_ease_reflect(d3_ease_reverse(f));
        }
    });
    d3.ease = function (name) {
        var i = name.indexOf('-'), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : 'in';
        t = d3_ease.get(t) || d3_ease_default;
        m = d3_ease_mode.get(m) || d3_identity;
        return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
    };
    function d3_ease_clamp(f) {
        return function (t) {
            return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
        };
    }
    function d3_ease_reverse(f) {
        return function (t) {
            return 1 - f(1 - t);
        };
    }
    function d3_ease_reflect(f) {
        return function (t) {
            return 0.5 * (t < 0.5 ? f(2 * t) : 2 - f(2 - 2 * t));
        };
    }
    function d3_ease_quad(t) {
        return t * t;
    }
    function d3_ease_cubic(t) {
        return t * t * t;
    }
    function d3_ease_cubicInOut(t) {
        if (t <= 0)
            return 0;
        if (t >= 1)
            return 1;
        var t2 = t * t, t3 = t2 * t;
        return 4 * (t < 0.5 ? t3 : 3 * (t - t2) + t3 - 0.75);
    }
    function d3_ease_poly(e) {
        return function (t) {
            return Math.pow(t, e);
        };
    }
    function d3_ease_sin(t) {
        return 1 - Math.cos(t * half);
    }
    function d3_ease_exp(t) {
        return Math.pow(2, 10 * (t - 1));
    }
    function d3_ease_circle(t) {
        return 1 - Math.sqrt(1 - t * t);
    }
    function d3_ease_elastic(a, p) {
        var s;
        if (arguments.length < 2)
            p = 0.45;
        if (arguments.length)
            s = p /  * Math.asin(1 / a);
        else
            a = 1, s = p / 4;
        return function (t) {
            return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) *  / p);
        };
    }
    function d3_ease_back(s) {
        if (!s)
            s = 1.70158;
        return function (t) {
            return t * t * ((s + 1) * t - s);
        };
    }
    function d3_ease_bounce(t) {
        return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
    }
    d3.interpolateHcl = d3_interpolateHcl;
    function d3_interpolateHcl(a, b) {
        a = d3.hcl(a);
        b = d3.hcl(b);
        var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
        if (isNaN(bc))
            bc = 0, ac = isNaN(ac) ? b.c : ac;
        if (isNaN(bh))
            bh = 0, ah = isNaN(ah) ? b.h : ah;
        else if (bh > 180)
            bh -= 360;
        else if (bh < -180)
            bh += 360;
        return function (t) {
            return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + '';
        };
    }
    d3.interpolateHsl = d3_interpolateHsl;
    function d3_interpolateHsl(a, b) {
        a = d3.hsl(a);
        b = d3.hsl(b);
        var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
        if (isNaN(bs))
            bs = 0, as = isNaN(as) ? b.s : as;
        if (isNaN(bh))
            bh = 0, ah = isNaN(ah) ? b.h : ah;
        else if (bh > 180)
            bh -= 360;
        else if (bh < -180)
            bh += 360;
        return function (t) {
            return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + '';
        };
    }
    d3.interpolateLab = d3_interpolateLab;
    function d3_interpolateLab(a, b) {
        a = d3.lab(a);
        b = d3.lab(b);
        var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
        return function (t) {
            return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + '';
        };
    }
    d3.interpolateRound = d3_interpolateRound;
    function d3_interpolateRound(a, b) {
        b -= a;
        return function (t) {
            return Math.round(a + b * t);
        };
    }
    d3.transform = function (string) {
        var g = d3_document.createElementNS(d3.ns.prefix.svg, 'g');
        return (d3.transform = function (string) {
            if (string != null) {
                g.setAttribute('transform', string);
                var t = g.transform.baseVal.consolidate();
            }
            return new d3_transform(t ? t.matrix : d3_transformIdentity);
        })(string);
    };
    function d3_transform(m) {
        var r0 = [
                m.a,
                m.b
            ], r1 = [
                m.c,
                m.d
            ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
        if (r0[0] * r1[1] < r1[0] * r0[1]) {
            r0[0] *= -1;
            r0[1] *= -1;
            kx *= -1;
            kz *= -1;
        }
        this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
        this.translate = [
            m.e,
            m.f
        ];
        this.scale = [
            kx,
            ky
        ];
        this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
    }
    d3_transform.prototype.toString = function () {
        return 'translate(' + this.translate + ')rotate(' + this.rotate + ')skewX(' + this.skew + ')scale(' + this.scale + ')';
    };
    function d3_transformDot(a, b) {
        return a[0] * b[0] + a[1] * b[1];
    }
    function d3_transformNormalize(a) {
        var k = Math.sqrt(d3_transformDot(a, a));
        if (k) {
            a[0] /= k;
            a[1] /= k;
        }
        return k;
    }
    function d3_transformCombine(a, b, k) {
        a[0] += k * b[0];
        a[1] += k * b[1];
        return a;
    }
    var d3_transformIdentity = {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        e: 0,
        f: 0
    };
    d3.interpolateTransform = d3_interpolateTransform;
    function d3_interpolateTransform(a, b) {
        var s = [], q = [], n, A = d3.transform(a), B = d3.transform(b), ta = A.translate, tb = B.translate, ra = A.rotate, rb = B.rotate, wa = A.skew, wb = B.skew, ka = A.scale, kb = B.scale;
        if (ta[0] != tb[0] || ta[1] != tb[1]) {
            s.push('translate(', null, ',', null, ')');
            q.push({
                i: 1,
                x: d3_interpolateNumber(ta[0], tb[0])
            }, {
                i: 3,
                x: d3_interpolateNumber(ta[1], tb[1])
            });
        } else if (tb[0] || tb[1]) {
            s.push('translate(' + tb + ')');
        } else {
            s.push('');
        }
        if (ra != rb) {
            if (ra - rb > 180)
                rb += 360;
            else if (rb - ra > 180)
                ra += 360;
            q.push({
                i: s.push(s.pop() + 'rotate(', null, ')') - 2,
                x: d3_interpolateNumber(ra, rb)
            });
        } else if (rb) {
            s.push(s.pop() + 'rotate(' + rb + ')');
        }
        if (wa != wb) {
            q.push({
                i: s.push(s.pop() + 'skewX(', null, ')') - 2,
                x: d3_interpolateNumber(wa, wb)
            });
        } else if (wb) {
            s.push(s.pop() + 'skewX(' + wb + ')');
        }
        if (ka[0] != kb[0] || ka[1] != kb[1]) {
            n = s.push(s.pop() + 'scale(', null, ',', null, ')');
            q.push({
                i: n - 4,
                x: d3_interpolateNumber(ka[0], kb[0])
            }, {
                i: n - 2,
                x: d3_interpolateNumber(ka[1], kb[1])
            });
        } else if (kb[0] != 1 || kb[1] != 1) {
            s.push(s.pop() + 'scale(' + kb + ')');
        }
        n = q.length;
        return function (t) {
            var i = -1, o;
            while (++i < n)
                s[(o = q[i]).i] = o.x(t);
            return s.join('');
        };
    }
    function d3_uninterpolateNumber(a, b) {
        b = (b -= a = +a) || 1 / b;
        return function (x) {
            return (x - a) / b;
        };
    }
    function d3_uninterpolateClamp(a, b) {
        b = (b -= a = +a) || 1 / b;
        return function (x) {
            return Math.max(0, Math.min(1, (x - a) / b));
        };
    }
    d3.layout = {};
    d3.layout.bundle = function () {
        return function (links) {
            var paths = [], i = -1, n = links.length;
            while (++i < n)
                paths.push(d3_layout_bundlePath(links[i]));
            return paths;
        };
    };
    function d3_layout_bundlePath(link) {
        var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [start];
        while (start !== lca) {
            start = start.parent;
            points.push(start);
        }
        var k = points.length;
        while (end !== lca) {
            points.splice(k, 0, end);
            end = end.parent;
        }
        return points;
    }
    function d3_layout_bundleAncestors(node) {
        var ancestors = [], parent = node.parent;
        while (parent != null) {
            ancestors.push(node);
            node = parent;
            parent = parent.parent;
        }
        ancestors.push(node);
        return ancestors;
    }
    function d3_layout_bundleLeastCommonAncestor(a, b) {
        if (a === b)
            return a;
        var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
        while (aNode === bNode) {
            sharedNode = aNode;
            aNode = aNodes.pop();
            bNode = bNodes.pop();
        }
        return sharedNode;
    }
    d3.layout.chord = function () {
        var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
        function relayout() {
            var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
            chords = [];
            groups = [];
            k = 0, i = -1;
            while (++i < n) {
                x = 0, j = -1;
                while (++j < n) {
                    x += matrix[i][j];
                }
                groupSums.push(x);
                subgroupIndex.push(d3.range(n));
                k += x;
            }
            if (sortGroups) {
                groupIndex.sort(function (a, b) {
                    return sortGroups(groupSums[a], groupSums[b]);
                });
            }
            if (sortSubgroups) {
                subgroupIndex.forEach(function (d, i) {
                    d.sort(function (a, b) {
                        return sortSubgroups(matrix[i][a], matrix[i][b]);
                    });
                });
            }
            k = ( - padding * n) / k;
            x = 0, i = -1;
            while (++i < n) {
                x0 = x, j = -1;
                while (++j < n) {
                    var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
                    subgroups[di + '-' + dj] = {
                        index: di,
                        subindex: dj,
                        startAngle: a0,
                        endAngle: a1,
                        value: v
                    };
                }
                groups[di] = {
                    index: di,
                    startAngle: x0,
                    endAngle: x,
                    value: (x - x0) / k
                };
                x += padding;
            }
            i = -1;
            while (++i < n) {
                j = i - 1;
                while (++j < n) {
                    var source = subgroups[i + '-' + j], target = subgroups[j + '-' + i];
                    if (source.value || target.value) {
                        chords.push(source.value < target.value ? {
                            source: target,
                            target: source
                        } : {
                            source: source,
                            target: target
                        });
                    }
                }
            }
            if (sortChords)
                resort();
        }
        function resort() {
            chords.sort(function (a, b) {
                return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
            });
        }
        chord.matrix = function (x) {
            if (!arguments.length)
                return matrix;
            n = (matrix = x) && matrix.length;
            chords = groups = null;
            return chord;
        };
        chord.padding = function (x) {
            if (!arguments.length)
                return padding;
            padding = x;
            chords = groups = null;
            return chord;
        };
        chord.sortGroups = function (x) {
            if (!arguments.length)
                return sortGroups;
            sortGroups = x;
            chords = groups = null;
            return chord;
        };
        chord.sortSubgroups = function (x) {
            if (!arguments.length)
                return sortSubgroups;
            sortSubgroups = x;
            chords = null;
            return chord;
        };
        chord.sortChords = function (x) {
            if (!arguments.length)
                return sortChords;
            sortChords = x;
            if (chords)
                resort();
            return chord;
        };
        chord.chords = function () {
            if (!chords)
                relayout();
            return chords;
        };
        chord.groups = function () {
            if (!groups)
                relayout();
            return groups;
        };
        return chord;
    };
    d3.layout.force = function () {
        var force = {}, event = d3.dispatch('start', 'tick', 'end'), size = [
                1,
                1
            ], drag, alpha, friction = 0.9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = 0.1, theta2 = 0.64, nodes = [], links = [], distances, strengths, charges;
        function repulse(node) {
            return function (quad, x1, _, x2) {
                if (quad.point !== node) {
                    var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;
                    if (dw * dw / theta2 < dn) {
                        if (dn < chargeDistance2) {
                            var k = quad.charge / dn;
                            node.px -= dx * k;
                            node.py -= dy * k;
                        }
                        return true;
                    }
                    if (quad.point && dn && dn < chargeDistance2) {
                        var k = quad.pointCharge / dn;
                        node.px -= dx * k;
                        node.py -= dy * k;
                    }
                }
                return !quad.charge;
            };
        }
        force.tick = function () {
            if ((alpha *= 0.99) < 0.005) {
                event.end({
                    type: 'end',
                    alpha: alpha = 0
                });
                return true;
            }
            var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
            for (i = 0; i < m; ++i) {
                o = links[i];
                s = o.source;
                t = o.target;
                x = t.x - s.x;
                y = t.y - s.y;
                if (l = x * x + y * y) {
                    l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
                    x *= l;
                    y *= l;
                    t.x -= x * (k = s.weight / (t.weight + s.weight));
                    t.y -= y * k;
                    s.x += x * (k = 1 - k);
                    s.y += y * k;
                }
            }
            if (k = alpha * gravity) {
                x = size[0] / 2;
                y = size[1] / 2;
                i = -1;
                if (k)
                    while (++i < n) {
                        o = nodes[i];
                        o.x += (x - o.x) * k;
                        o.y += (y - o.y) * k;
                    }
            }
            if (charge) {
                d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
                i = -1;
                while (++i < n) {
                    if (!(o = nodes[i]).fixed) {
                        q.visit(repulse(o));
                    }
                }
            }
            i = -1;
            while (++i < n) {
                o = nodes[i];
                if (o.fixed) {
                    o.x = o.px;
                    o.y = o.py;
                } else {
                    o.x -= (o.px - (o.px = o.x)) * friction;
                    o.y -= (o.py - (o.py = o.y)) * friction;
                }
            }
            event.tick({
                type: 'tick',
                alpha: alpha
            });
        };
        force.nodes = function (x) {
            if (!arguments.length)
                return nodes;
            nodes = x;
            return force;
        };
        force.links = function (x) {
            if (!arguments.length)
                return links;
            links = x;
            return force;
        };
        force.size = function (x) {
            if (!arguments.length)
                return size;
            size = x;
            return force;
        };
        force.linkDistance = function (x) {
            if (!arguments.length)
                return linkDistance;
            linkDistance = typeof x === 'function' ? x : +x;
            return force;
        };
        force.distance = force.linkDistance;
        force.linkStrength = function (x) {
            if (!arguments.length)
                return linkStrength;
            linkStrength = typeof x === 'function' ? x : +x;
            return force;
        };
        force.friction = function (x) {
            if (!arguments.length)
                return friction;
            friction = +x;
            return force;
        };
        force.charge = function (x) {
            if (!arguments.length)
                return charge;
            charge = typeof x === 'function' ? x : +x;
            return force;
        };
        force.chargeDistance = function (x) {
            if (!arguments.length)
                return Math.sqrt(chargeDistance2);
            chargeDistance2 = x * x;
            return force;
        };
        force.gravity = function (x) {
            if (!arguments.length)
                return gravity;
            gravity = +x;
            return force;
        };
        force.theta = function (x) {
            if (!arguments.length)
                return Math.sqrt(theta2);
            theta2 = x * x;
            return force;
        };
        force.alpha = function (x) {
            if (!arguments.length)
                return alpha;
            x = +x;
            if (alpha) {
                if (x > 0)
                    alpha = x;
                else
                    alpha = 0;
            } else if (x > 0) {
                event.start({
                    type: 'start',
                    alpha: alpha = x
                });
                d3.timer(force.tick);
            }
            return force;
        };
        force.start = function () {
            var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
            for (i = 0; i < n; ++i) {
                (o = nodes[i]).index = i;
                o.weight = 0;
            }
            for (i = 0; i < m; ++i) {
                o = links[i];
                if (typeof o.source == 'number')
                    o.source = nodes[o.source];
                if (typeof o.target == 'number')
                    o.target = nodes[o.target];
                ++o.source.weight;
                ++o.target.weight;
            }
            for (i = 0; i < n; ++i) {
                o = nodes[i];
                if (isNaN(o.x))
                    o.x = position('x', w);
                if (isNaN(o.y))
                    o.y = position('y', h);
                if (isNaN(o.px))
                    o.px = o.x;
                if (isNaN(o.py))
                    o.py = o.y;
            }
            distances = [];
            if (typeof linkDistance === 'function')
                for (i = 0; i < m; ++i)
                    distances[i] = +linkDistance.call(this, links[i], i);
            else
                for (i = 0; i < m; ++i)
                    distances[i] = linkDistance;
            strengths = [];
            if (typeof linkStrength === 'function')
                for (i = 0; i < m; ++i)
                    strengths[i] = +linkStrength.call(this, links[i], i);
            else
                for (i = 0; i < m; ++i)
                    strengths[i] = linkStrength;
            charges = [];
            if (typeof charge === 'function')
                for (i = 0; i < n; ++i)
                    charges[i] = +charge.call(this, nodes[i], i);
            else
                for (i = 0; i < n; ++i)
                    charges[i] = charge;
            function position(dimension, size) {
                if (!neighbors) {
                    neighbors = new Array(n);
                    for (j = 0; j < n; ++j) {
                        neighbors[j] = [];
                    }
                    for (j = 0; j < m; ++j) {
                        var o = links[j];
                        neighbors[o.source.index].push(o.target);
                        neighbors[o.target.index].push(o.source);
                    }
                }
                var candidates = neighbors[i], j = -1, l = candidates.length, x;
                while (++j < l)
                    if (!isNaN(x = candidates[j][dimension]))
                        return x;
                return Math.random() * size;
            }
            return force.resume();
        };
        force.resume = function () {
            return force.alpha(0.1);
        };
        force.stop = function () {
            return force.alpha(0);
        };
        force.drag = function () {
            if (!drag)
                drag = d3.behavior.drag().origin(d3_identity).on('dragstart.force', d3_layout_forceDragstart).on('drag.force', dragmove).on('dragend.force', d3_layout_forceDragend);
            if (!arguments.length)
                return drag;
            this.on('mouseover.force', d3_layout_forceMouseover).on('mouseout.force', d3_layout_forceMouseout).call(drag);
        };
        function dragmove(d) {
            d.px = d3.event.x, d.py = d3.event.y;
            force.resume();
        }
        return d3.rebind(force, event, 'on');
    };
    function d3_layout_forceDragstart(d) {
        d.fixed |= 2;
    }
    function d3_layout_forceDragend(d) {
        d.fixed &= ~6;
    }
    function d3_layout_forceMouseover(d) {
        d.fixed |= 4;
        d.px = d.x, d.py = d.y;
    }
    function d3_layout_forceMouseout(d) {
        d.fixed &= ~4;
    }
    function d3_layout_forceAccumulate(quad, alpha, charges) {
        var cx = 0, cy = 0;
        quad.charge = 0;
        if (!quad.leaf) {
            var nodes = quad.nodes, n = nodes.length, i = -1, c;
            while (++i < n) {
                c = nodes[i];
                if (c == null)
                    continue;
                d3_layout_forceAccumulate(c, alpha, charges);
                quad.charge += c.charge;
                cx += c.charge * c.cx;
                cy += c.charge * c.cy;
            }
        }
        if (quad.point) {
            if (!quad.leaf) {
                quad.point.x += Math.random() - 0.5;
                quad.point.y += Math.random() - 0.5;
            }
            var k = alpha * charges[quad.point.index];
            quad.charge += quad.pointCharge = k;
            cx += k * quad.point.x;
            cy += k * quad.point.y;
        }
        quad.cx = cx / quad.charge;
        quad.cy = cy / quad.charge;
    }
    var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;
    d3.layout.hierarchy = function () {
        var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
        function hierarchy(root) {
            var stack = [root], nodes = [], node;
            root.depth = 0;
            while ((node = stack.pop()) != null) {
                nodes.push(node);
                if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
                    var n, childs, child;
                    while (--n >= 0) {
                        stack.push(child = childs[n]);
                        child.parent = node;
                        child.depth = node.depth + 1;
                    }
                    if (value)
                        node.value = 0;
                    node.children = childs;
                } else {
                    if (value)
                        node.value = +value.call(hierarchy, node, node.depth) || 0;
                    delete node.children;
                }
            }
            d3_layout_hierarchyVisitAfter(root, function (node) {
                var childs, parent;
                if (sort && (childs = node.children))
                    childs.sort(sort);
                if (value && (parent = node.parent))
                    parent.value += node.value;
            });
            return nodes;
        }
        hierarchy.sort = function (x) {
            if (!arguments.length)
                return sort;
            sort = x;
            return hierarchy;
        };
        hierarchy.children = function (x) {
            if (!arguments.length)
                return children;
            children = x;
            return hierarchy;
        };
        hierarchy.value = function (x) {
            if (!arguments.length)
                return value;
            value = x;
            return hierarchy;
        };
        hierarchy.revalue = function (root) {
            if (value) {
                d3_layout_hierarchyVisitBefore(root, function (node) {
                    if (node.children)
                        node.value = 0;
                });
                d3_layout_hierarchyVisitAfter(root, function (node) {
                    var parent;
                    if (!node.children)
                        node.value = +value.call(hierarchy, node, node.depth) || 0;
                    if (parent = node.parent)
                        parent.value += node.value;
                });
            }
            return root;
        };
        return hierarchy;
    };
    function d3_layout_hierarchyRebind(object, hierarchy) {
        d3.rebind(object, hierarchy, 'sort', 'children', 'value');
        object.nodes = object;
        object.links = d3_layout_hierarchyLinks;
        return object;
    }
    function d3_layout_hierarchyVisitBefore(node, callback) {
        var nodes = [node];
        while ((node = nodes.pop()) != null) {
            callback(node);
            if ((children = node.children) && (n = children.length)) {
                var n, children;
                while (--n >= 0)
                    nodes.push(children[n]);
            }
        }
    }
    function d3_layout_hierarchyVisitAfter(node, callback) {
        var nodes = [node], nodes2 = [];
        while ((node = nodes.pop()) != null) {
            nodes2.push(node);
            if ((children = node.children) && (n = children.length)) {
                var i = -1, n, children;
                while (++i < n)
                    nodes.push(children[i]);
            }
        }
        while ((node = nodes2.pop()) != null) {
            callback(node);
        }
    }
    function d3_layout_hierarchyChildren(d) {
        return d.children;
    }
    function d3_layout_hierarchyValue(d) {
        return d.value;
    }
    function d3_layout_hierarchySort(a, b) {
        return b.value - a.value;
    }
    function d3_layout_hierarchyLinks(nodes) {
        return d3.merge(nodes.map(function (parent) {
            return (parent.children || []).map(function (child) {
                return {
                    source: parent,
                    target: child
                };
            });
        }));
    }
    d3.layout.partition = function () {
        var hierarchy = d3.layout.hierarchy(), size = [
                1,
                1
            ];
        function position(node, x, dx, dy) {
            var children = node.children;
            node.x = x;
            node.y = node.depth * dy;
            node.dx = dx;
            node.dy = dy;
            if (children && (n = children.length)) {
                var i = -1, n, c, d;
                dx = node.value ? dx / node.value : 0;
                while (++i < n) {
                    position(c = children[i], x, d = c.value * dx, dy);
                    x += d;
                }
            }
        }
        function depth(node) {
            var children = node.children, d = 0;
            if (children && (n = children.length)) {
                var i = -1, n;
                while (++i < n)
                    d = Math.max(d, depth(children[i]));
            }
            return 1 + d;
        }
        function partition(d, i) {
            var nodes = hierarchy.call(this, d, i);
            position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
            return nodes;
        }
        partition.size = function (x) {
            if (!arguments.length)
                return size;
            size = x;
            return partition;
        };
        return d3_layout_hierarchyRebind(partition, hierarchy);
    };
    d3.layout.pie = function () {
        var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = , padAngle = 0;
        function pie(data) {
            var n = data.length, values = data.map(function (d, i) {
                    return +value.call(pie, d, i);
                }), a = +(typeof startAngle === 'function' ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === 'function' ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === 'function' ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), k = (da - n * pa) / d3.sum(values), index = d3.range(n), arcs = [], v;
            if (sort != null)
                index.sort(sort === d3_layout_pieSortByValue ? function (i, j) {
                    return values[j] - values[i];
                } : function (i, j) {
                    return sort(data[i], data[j]);
                });
            index.forEach(function (i) {
                arcs[i] = {
                    data: data[i],
                    value: v = values[i],
                    startAngle: a,
                    endAngle: a += v * k + pa,
                    padAngle: p
                };
            });
            return arcs;
        }
        pie.value = function (_) {
            if (!arguments.length)
                return value;
            value = _;
            return pie;
        };
        pie.sort = function (_) {
            if (!arguments.length)
                return sort;
            sort = _;
            return pie;
        };
        pie.startAngle = function (_) {
            if (!arguments.length)
                return startAngle;
            startAngle = _;
            return pie;
        };
        pie.endAngle = function (_) {
            if (!arguments.length)
                return endAngle;
            endAngle = _;
            return pie;
        };
        pie.padAngle = function (_) {
            if (!arguments.length)
                return padAngle;
            padAngle = _;
            return pie;
        };
        return pie;
    };
    var d3_layout_pieSortByValue = {};
    d3.layout.stack = function () {
        var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
        function stack(data, index) {
            if (!(n = data.length))
                return data;
            var series = data.map(function (d, i) {
                return values.call(stack, d, i);
            });
            var points = series.map(function (d) {
                return d.map(function (v, i) {
                    return [
                        x.call(stack, v, i),
                        y.call(stack, v, i)
                    ];
                });
            });
            var orders = order.call(stack, points, index);
            series = d3.permute(series, orders);
            points = d3.permute(points, orders);
            var offsets = offset.call(stack, points, index);
            var m = series[0].length, n, i, j, o;
            for (j = 0; j < m; ++j) {
                out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
                for (i = 1; i < n; ++i) {
                    out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
                }
            }
            return data;
        }
        stack.values = function (x) {
            if (!arguments.length)
                return values;
            values = x;
            return stack;
        };
        stack.order = function (x) {
            if (!arguments.length)
                return order;
            order = typeof x === 'function' ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
            return stack;
        };
        stack.offset = function (x) {
            if (!arguments.length)
                return offset;
            offset = typeof x === 'function' ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
            return stack;
        };
        stack.x = function (z) {
            if (!arguments.length)
                return x;
            x = z;
            return stack;
        };
        stack.y = function (z) {
            if (!arguments.length)
                return y;
            y = z;
            return stack;
        };
        stack.out = function (z) {
            if (!arguments.length)
                return out;
            out = z;
            return stack;
        };
        return stack;
    };
    function d3_layout_stackX(d) {
        return d.x;
    }
    function d3_layout_stackY(d) {
        return d.y;
    }
    function d3_layout_stackOut(d, y0, y) {
        d.y0 = y0;
        d.y = y;
    }
    var d3_layout_stackOrders = d3.map({
        'inside-out': function (data) {
            var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function (a, b) {
                    return max[a] - max[b];
                }), top = 0, bottom = 0, tops = [], bottoms = [];
            for (i = 0; i < n; ++i) {
                j = index[i];
                if (top < bottom) {
                    top += sums[j];
                    tops.push(j);
                } else {
                    bottom += sums[j];
                    bottoms.push(j);
                }
            }
            return bottoms.reverse().concat(tops);
        },
        reverse: function (data) {
            return d3.range(data.length).reverse();
        },
        'default': d3_layout_stackOrderDefault
    });
    var d3_layout_stackOffsets = d3.map({
        silhouette: function (data) {
            var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
            for (j = 0; j < m; ++j) {
                for (i = 0, o = 0; i < n; i++)
                    o += data[i][j][1];
                if (o > max)
                    max = o;
                sums.push(o);
            }
            for (j = 0; j < m; ++j) {
                y0[j] = (max - sums[j]) / 2;
            }
            return y0;
        },
        wiggle: function (data) {
            var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
            y0[0] = o = o0 = 0;
            for (j = 1; j < m; ++j) {
                for (i = 0, s1 = 0; i < n; ++i)
                    s1 += data[i][j][1];
                for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
                    for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
                        s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
                    }
                    s2 += s3 * data[i][j][1];
                }
                y0[j] = o -= s1 ? s2 / s1 * dx : 0;
                if (o < o0)
                    o0 = o;
            }
            for (j = 0; j < m; ++j)
                y0[j] -= o0;
            return y0;
        },
        expand: function (data) {
            var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
            for (j = 0; j < m; ++j) {
                for (i = 0, o = 0; i < n; i++)
                    o += data[i][j][1];
                if (o)
                    for (i = 0; i < n; i++)
                        data[i][j][1] /= o;
                else
                    for (i = 0; i < n; i++)
                        data[i][j][1] = k;
            }
            for (j = 0; j < m; ++j)
                y0[j] = 0;
            return y0;
        },
        zero: d3_layout_stackOffsetZero
    });
    function d3_layout_stackOrderDefault(data) {
        return d3.range(data.length);
    }
    function d3_layout_stackOffsetZero(data) {
        var j = -1, m = data[0].length, y0 = [];
        while (++j < m)
            y0[j] = 0;
        return y0;
    }
    function d3_layout_stackMaxIndex(array) {
        var i = 1, j = 0, v = array[0][1], k, n = array.length;
        for (; i < n; ++i) {
            if ((k = array[i][1]) > v) {
                j = i;
                v = k;
            }
        }
        return j;
    }
    function d3_layout_stackReduceSum(d) {
        return d.reduce(d3_layout_stackSum, 0);
    }
    function d3_layout_stackSum(p, d) {
        return p + d[1];
    }
    d3.layout.histogram = function () {
        var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
        function histogram(data, i) {
            var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
            while (++i < m) {
                bin = bins[i] = [];
                bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
                bin.y = 0;
            }
            if (m > 0) {
                i = -1;
                while (++i < n) {
                    x = values[i];
                    if (x >= range[0] && x <= range[1]) {
                        bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
                        bin.y += k;
                        bin.push(data[i]);
                    }
                }
            }
            return bins;
        }
        histogram.value = function (x) {
            if (!arguments.length)
                return valuer;
            valuer = x;
            return histogram;
        };
        histogram.range = function (x) {
            if (!arguments.length)
                return ranger;
            ranger = d3_functor(x);
            return histogram;
        };
        histogram.bins = function (x) {
            if (!arguments.length)
                return binner;
            binner = typeof x === 'number' ? function (range) {
                return d3_layout_histogramBinFixed(range, x);
            } : d3_functor(x);
            return histogram;
        };
        histogram.frequency = function (x) {
            if (!arguments.length)
                return frequency;
            frequency = !!x;
            return histogram;
        };
        return histogram;
    };
    function d3_layout_histogramBinSturges(range, values) {
        return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
    }
    function d3_layout_histogramBinFixed(range, n) {
        var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
        while (++x <= n)
            f[x] = m * x + b;
        return f;
    }
    function d3_layout_histogramRange(values) {
        return [
            d3.min(values),
            d3.max(values)
        ];
    }
    d3.layout.pack = function () {
        var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [
                1,
                1
            ], radius;
        function pack(d, i) {
            var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === 'function' ? radius : function () {
                    return radius;
                };
            root.x = root.y = 0;
            d3_layout_hierarchyVisitAfter(root, function (d) {
                d.r = +r(d.value);
            });
            d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
            if (padding) {
                var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
                d3_layout_hierarchyVisitAfter(root, function (d) {
                    d.r += dr;
                });
                d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
                d3_layout_hierarchyVisitAfter(root, function (d) {
                    d.r -= dr;
                });
            }
            d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
            return nodes;
        }
        pack.size = function (_) {
            if (!arguments.length)
                return size;
            size = _;
            return pack;
        };
        pack.radius = function (_) {
            if (!arguments.length)
                return radius;
            radius = _ == null || typeof _ === 'function' ? _ : +_;
            return pack;
        };
        pack.padding = function (_) {
            if (!arguments.length)
                return padding;
            padding = +_;
            return pack;
        };
        return d3_layout_hierarchyRebind(pack, hierarchy);
    };
    function d3_layout_packSort(a, b) {
        return a.value - b.value;
    }
    function d3_layout_packInsert(a, b) {
        var c = a._pack_next;
        a._pack_next = b;
        b._pack_prev = a;
        b._pack_next = c;
        c._pack_prev = b;
    }
    function d3_layout_packSplice(a, b) {
        a._pack_next = b;
        b._pack_prev = a;
    }
    function d3_layout_packIntersects(a, b) {
        var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
        return 0.999 * dr * dr > dx * dx + dy * dy;
    }
    function d3_layout_packSiblings(node) {
        if (!(nodes = node.children) || !(n = nodes.length))
            return;
        var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
        function bound(node) {
            xMin = Math.min(node.x - node.r, xMin);
            xMax = Math.max(node.x + node.r, xMax);
            yMin = Math.min(node.y - node.r, yMin);
            yMax = Math.max(node.y + node.r, yMax);
        }
        nodes.forEach(d3_layout_packLink);
        a = nodes[0];
        a.x = -a.r;
        a.y = 0;
        bound(a);
        if (n > 1) {
            b = nodes[1];
            b.x = b.r;
            b.y = 0;
            bound(b);
            if (n > 2) {
                c = nodes[2];
                d3_layout_packPlace(a, b, c);
                bound(c);
                d3_layout_packInsert(a, c);
                a._pack_prev = c;
                d3_layout_packInsert(c, b);
                b = a._pack_next;
                for (i = 3; i < n; i++) {
                    d3_layout_packPlace(a, b, c = nodes[i]);
                    var isect = 0, s1 = 1, s2 = 1;
                    for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
                        if (d3_layout_packIntersects(j, c)) {
                            isect = 1;
                            break;
                        }
                    }
                    if (isect == 1) {
                        for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
                            if (d3_layout_packIntersects(k, c)) {
                                break;
                            }
                        }
                    }
                    if (isect) {
                        if (s1 < s2 || s1 == s2 && b.r < a.r)
                            d3_layout_packSplice(a, b = j);
                        else
                            d3_layout_packSplice(a = k, b);
                        i--;
                    } else {
                        d3_layout_packInsert(a, c);
                        b = c;
                        bound(c);
                    }
                }
            }
        }
        var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
        for (i = 0; i < n; i++) {
            c = nodes[i];
            c.x -= cx;
            c.y -= cy;
            cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
        }
        node.r = cr;
        nodes.forEach(d3_layout_packUnlink);
    }
    function d3_layout_packLink(node) {
        node._pack_next = node._pack_prev = node;
    }
    function d3_layout_packUnlink(node) {
        delete node._pack_next;
        delete node._pack_prev;
    }
    function d3_layout_packTransform(node, x, y, k) {
        var children = node.children;
        node.x = x += k * node.x;
        node.y = y += k * node.y;
        node.r *= k;
        if (children) {
            var i = -1, n = children.length;
            while (++i < n)
                d3_layout_packTransform(children[i], x, y, k);
        }
    }
    function d3_layout_packPlace(a, b, c) {
        var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
        if (db && (dx || dy)) {
            var da = b.r + c.r, dc = dx * dx + dy * dy;
            da *= da;
            db *= db;
            var x = 0.5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
            c.x = a.x + x * dx + y * dy;
            c.y = a.y + x * dy - y * dx;
        } else {
            c.x = a.x + db;
            c.y = a.y;
        }
    }
    d3.layout.tree = function () {
        var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [
                1,
                1
            ], nodeSize = null;
        function tree(d, i) {
            var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);
            d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
            d3_layout_hierarchyVisitBefore(root1, secondWalk);
            if (nodeSize)
                d3_layout_hierarchyVisitBefore(root0, sizeNode);
            else {
                var left = root0, right = root0, bottom = root0;
                d3_layout_hierarchyVisitBefore(root0, function (node) {
                    if (node.x < left.x)
                        left = node;
                    if (node.x > right.x)
                        right = node;
                    if (node.depth > bottom.depth)
                        bottom = node;
                });
                var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);
                d3_layout_hierarchyVisitBefore(root0, function (node) {
                    node.x = (node.x + tx) * kx;
                    node.y = node.depth * ky;
                });
            }
            return nodes;
        }
        function wrapTree(root0) {
            var root1 = {
                    A: null,
                    children: [root0]
                }, queue = [root1], node1;
            while ((node1 = queue.pop()) != null) {
                for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {
                    queue.push((children[i] = child = {
                        _: children[i],
                        parent: node1,
                        children: (child = children[i].children) && child.slice() || [],
                        A: null,
                        a: null,
                        z: 0,
                        m: 0,
                        c: 0,
                        s: 0,
                        t: null,
                        i: i
                    }).a = child);
                }
            }
            return root1.children[0];
        }
        function firstWalk(v) {
            var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
            if (children.length) {
                d3_layout_treeShift(v);
                var midpoint = (children[0].z + children[children.length - 1].z) / 2;
                if (w) {
                    v.z = w.z + separation(v._, w._);
                    v.m = v.z - midpoint;
                } else {
                    v.z = midpoint;
                }
            } else if (w) {
                v.z = w.z + separation(v._, w._);
            }
            v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
        }
        function secondWalk(v) {
            v._.x = v.z + v.parent.m;
            v.m += v.parent.m;
        }
        function apportion(v, w, ancestor) {
            if (w) {
                var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
                while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
                    vom = d3_layout_treeLeft(vom);
                    vop = d3_layout_treeRight(vop);
                    vop.a = v;
                    shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
                    if (shift > 0) {
                        d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
                        sip += shift;
                        sop += shift;
                    }
                    sim += vim.m;
                    sip += vip.m;
                    som += vom.m;
                    sop += vop.m;
                }
                if (vim && !d3_layout_treeRight(vop)) {
                    vop.t = vim;
                    vop.m += sim - sop;
                }
                if (vip && !d3_layout_treeLeft(vom)) {
                    vom.t = vip;
                    vom.m += sip - som;
                    ancestor = v;
                }
            }
            return ancestor;
        }
        function sizeNode(node) {
            node.x *= size[0];
            node.y = node.depth * size[1];
        }
        tree.separation = function (x) {
            if (!arguments.length)
                return separation;
            separation = x;
            return tree;
        };
        tree.size = function (x) {
            if (!arguments.length)
                return nodeSize ? null : size;
            nodeSize = (size = x) == null ? sizeNode : null;
            return tree;
        };
        tree.nodeSize = function (x) {
            if (!arguments.length)
                return nodeSize ? size : null;
            nodeSize = (size = x) == null ? null : sizeNode;
            return tree;
        };
        return d3_layout_hierarchyRebind(tree, hierarchy);
    };
    function d3_layout_treeSeparation(a, b) {
        return a.parent == b.parent ? 1 : 2;
    }
    function d3_layout_treeLeft(v) {
        var children = v.children;
        return children.length ? children[0] : v.t;
    }
    function d3_layout_treeRight(v) {
        var children = v.children, n;
        return (n = children.length) ? children[n - 1] : v.t;
    }
    function d3_layout_treeMove(wm, wp, shift) {
        var change = shift / (wp.i - wm.i);
        wp.c -= change;
        wp.s += shift;
        wm.c += change;
        wp.z += shift;
        wp.m += shift;
    }
    function d3_layout_treeShift(v) {
        var shift = 0, change = 0, children = v.children, i = children.length, w;
        while (--i >= 0) {
            w = children[i];
            w.z += shift;
            w.m += shift;
            shift += w.s + (change += w.c);
        }
    }
    function d3_layout_treeAncestor(vim, v, ancestor) {
        return vim.a.parent === v.parent ? vim.a : ancestor;
    }
    d3.layout.cluster = function () {
        var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [
                1,
                1
            ], nodeSize = false;
        function cluster(d, i) {
            var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
            d3_layout_hierarchyVisitAfter(root, function (node) {
                var children = node.children;
                if (children && children.length) {
                    node.x = d3_layout_clusterX(children);
                    node.y = d3_layout_clusterY(children);
                } else {
                    node.x = previousNode ? x += separation(node, previousNode) : 0;
                    node.y = 0;
                    previousNode = node;
                }
            });
            var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
            d3_layout_hierarchyVisitAfter(root, nodeSize ? function (node) {
                node.x = (node.x - root.x) * size[0];
                node.y = (root.y - node.y) * size[1];
            } : function (node) {
                node.x = (node.x - x0) / (x1 - x0) * size[0];
                node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
            });
            return nodes;
        }
        cluster.separation = function (x) {
            if (!arguments.length)
                return separation;
            separation = x;
            return cluster;
        };
        cluster.size = function (x) {
            if (!arguments.length)
                return nodeSize ? null : size;
            nodeSize = (size = x) == null;
            return cluster;
        };
        cluster.nodeSize = function (x) {
            if (!arguments.length)
                return nodeSize ? size : null;
            nodeSize = (size = x) != null;
            return cluster;
        };
        return d3_layout_hierarchyRebind(cluster, hierarchy);
    };
    function d3_layout_clusterY(children) {
        return 1 + d3.max(children, function (child) {
            return child.y;
        });
    }
    function d3_layout_clusterX(children) {
        return children.reduce(function (x, child) {
            return x + child.x;
        }, 0) / children.length;
    }
    function d3_layout_clusterLeft(node) {
        var children = node.children;
        return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
    }
    function d3_layout_clusterRight(node) {
        var children = node.children, n;
        return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
    }
    d3.layout.treemap = function () {
        var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [
                1,
                1
            ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = 'squarify', ratio = 0.5 * (1 + Math.sqrt(5));
        function scale(children, k) {
            var i = -1, n = children.length, child, area;
            while (++i < n) {
                area = (child = children[i]).value * (k < 0 ? 0 : k);
                child.area = isNaN(area) || area <= 0 ? 0 : area;
            }
        }
        function squarify(node) {
            var children = node.children;
            if (children && children.length) {
                var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === 'slice' ? rect.dx : mode === 'dice' ? rect.dy : mode === 'slice-dice' ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
                scale(remaining, rect.dx * rect.dy / node.value);
                row.area = 0;
                while ((n = remaining.length) > 0) {
                    row.push(child = remaining[n - 1]);
                    row.area += child.area;
                    if (mode !== 'squarify' || (score = worst(row, u)) <= best) {
                        remaining.pop();
                        best = score;
                    } else {
                        row.area -= row.pop().area;
                        position(row, u, rect, false);
                        u = Math.min(rect.dx, rect.dy);
                        row.length = row.area = 0;
                        best = Infinity;
                    }
                }
                if (row.length) {
                    position(row, u, rect, true);
                    row.length = row.area = 0;
                }
                children.forEach(squarify);
            }
        }
        function stickify(node) {
            var children = node.children;
            if (children && children.length) {
                var rect = pad(node), remaining = children.slice(), child, row = [];
                scale(remaining, rect.dx * rect.dy / node.value);
                row.area = 0;
                while (child = remaining.pop()) {
                    row.push(child);
                    row.area += child.area;
                    if (child.z != null) {
                        position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
                        row.length = row.area = 0;
                    }
                }
                children.forEach(stickify);
            }
        }
        function worst(row, u) {
            var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
            while (++i < n) {
                if (!(r = row[i].area))
                    continue;
                if (r < rmin)
                    rmin = r;
                if (r > rmax)
                    rmax = r;
            }
            s *= s;
            u *= u;
            return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
        }
        function position(row, u, rect, flush) {
            var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
            if (u == rect.dx) {
                if (flush || v > rect.dy)
                    v = rect.dy;
                while (++i < n) {
                    o = row[i];
                    o.x = x;
                    o.y = y;
                    o.dy = v;
                    x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
                }
                o.z = true;
                o.dx += rect.x + rect.dx - x;
                rect.y += v;
                rect.dy -= v;
            } else {
                if (flush || v > rect.dx)
                    v = rect.dx;
                while (++i < n) {
                    o = row[i];
                    o.x = x;
                    o.y = y;
                    o.dx = v;
                    y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
                }
                o.z = false;
                o.dy += rect.y + rect.dy - y;
                rect.x += v;
                rect.dx -= v;
            }
        }
        function treemap(d) {
            var nodes = stickies || hierarchy(d), root = nodes[0];
            root.x = 0;
            root.y = 0;
            root.dx = size[0];
            root.dy = size[1];
            if (stickies)
                hierarchy.revalue(root);
            scale([root], root.dx * root.dy / root.value);
            (stickies ? stickify : squarify)(root);
            if (sticky)
                stickies = nodes;
            return nodes;
        }
        treemap.size = function (x) {
            if (!arguments.length)
                return size;
            size = x;
            return treemap;
        };
        treemap.padding = function (x) {
            if (!arguments.length)
                return padding;
            function padFunction(node) {
                var p = x.call(treemap, node, node.depth);
                return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === 'number' ? [
                    p,
                    p,
                    p,
                    p
                ] : p);
            }
            function padConstant(node) {
                return d3_layout_treemapPad(node, x);
            }
            var type;
            pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === 'function' ? padFunction : type === 'number' ? (x = [
                x,
                x,
                x,
                x
            ], padConstant) : padConstant;
            return treemap;
        };
        treemap.round = function (x) {
            if (!arguments.length)
                return round != Number;
            round = x ? Math.round : Number;
            return treemap;
        };
        treemap.sticky = function (x) {
            if (!arguments.length)
                return sticky;
            sticky = x;
            stickies = null;
            return treemap;
        };
        treemap.ratio = function (x) {
            if (!arguments.length)
                return ratio;
            ratio = x;
            return treemap;
        };
        treemap.mode = function (x) {
            if (!arguments.length)
                return mode;
            mode = x + '';
            return treemap;
        };
        return d3_layout_hierarchyRebind(treemap, hierarchy);
    };
    function d3_layout_treemapPadNull(node) {
        return {
            x: node.x,
            y: node.y,
            dx: node.dx,
            dy: node.dy
        };
    }
    function d3_layout_treemapPad(node, padding) {
        var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
        if (dx < 0) {
            x += dx / 2;
            dx = 0;
        }
        if (dy < 0) {
            y += dy / 2;
            dy = 0;
        }
        return {
            x: x,
            y: y,
            dx: dx,
            dy: dy
        };
    }
    d3.random = {
        normal: function (, ) {
            var n = arguments.length;
            if (n < 2)
                 = 1;
            if (n < 1)
                 = 0;
            return function () {
                var x, y, r;
                do {
                    x = Math.random() * 2 - 1;
                    y = Math.random() * 2 - 1;
                    r = x * x + y * y;
                } while (!r || r > 1);
                return  +  * x * Math.sqrt(-2 * Math.log(r) / r);
            };
        },
        logNormal: function () {
            var random = d3.random.normal.apply(d3, arguments);
            return function () {
                return Math.exp(random());
            };
        },
        bates: function (m) {
            var random = d3.random.irwinHall(m);
            return function () {
                return random() / m;
            };
        },
        irwinHall: function (m) {
            return function () {
                for (var s = 0, j = 0; j < m; j++)
                    s += Math.random();
                return s;
            };
        }
    };
    d3.scale = {};
    function d3_scaleExtent(domain) {
        var start = domain[0], stop = domain[domain.length - 1];
        return start < stop ? [
            start,
            stop
        ] : [
            stop,
            start
        ];
    }
    function d3_scaleRange(scale) {
        return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
    }
    function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
        var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
        return function (x) {
            return i(u(x));
        };
    }
    function d3_scale_nice(domain, nice) {
        var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
        if (x1 < x0) {
            dx = i0, i0 = i1, i1 = dx;
            dx = x0, x0 = x1, x1 = dx;
        }
        domain[i0] = nice.floor(x0);
        domain[i1] = nice.ceil(x1);
        return domain;
    }
    function d3_scale_niceStep(step) {
        return step ? {
            floor: function (x) {
                return Math.floor(x / step) * step;
            },
            ceil: function (x) {
                return Math.ceil(x / step) * step;
            }
        } : d3_scale_niceIdentity;
    }
    var d3_scale_niceIdentity = {
        floor: d3_identity,
        ceil: d3_identity
    };
    function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
        var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
        if (domain[k] < domain[0]) {
            domain = domain.slice().reverse();
            range = range.slice().reverse();
        }
        while (++j <= k) {
            u.push(uninterpolate(domain[j - 1], domain[j]));
            i.push(interpolate(range[j - 1], range[j]));
        }
        return function (x) {
            var j = d3.bisect(domain, x, 1, k) - 1;
            return i[j](u[j](x));
        };
    }
    d3.scale.linear = function () {
        return d3_scale_linear([
            0,
            1
        ], [
            0,
            1
        ], d3_interpolate, false);
    };
    function d3_scale_linear(domain, range, interpolate, clamp) {
        var output, input;
        function rescale() {
            var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
            output = linear(domain, range, uninterpolate, interpolate);
            input = linear(range, domain, uninterpolate, d3_interpolate);
            return scale;
        }
        function scale(x) {
            return output(x);
        }
        scale.invert = function (y) {
            return input(y);
        };
        scale.domain = function (x) {
            if (!arguments.length)
                return domain;
            domain = x.map(Number);
            return rescale();
        };
        scale.range = function (x) {
            if (!arguments.length)
                return range;
            range = x;
            return rescale();
        };
        scale.rangeRound = function (x) {
            return scale.range(x).interpolate(d3_interpolateRound);
        };
        scale.clamp = function (x) {
            if (!arguments.length)
                return clamp;
            clamp = x;
            return rescale();
        };
        scale.interpolate = function (x) {
            if (!arguments.length)
                return interpolate;
            interpolate = x;
            return rescale();
        };
        scale.ticks = function (m) {
            return d3_scale_linearTicks(domain, m);
        };
        scale.tickFormat = function (m, format) {
            return d3_scale_linearTickFormat(domain, m, format);
        };
        scale.nice = function (m) {
            d3_scale_linearNice(domain, m);
            return rescale();
        };
        scale.copy = function () {
            return d3_scale_linear(domain, range, interpolate, clamp);
        };
        return rescale();
    }
    function d3_scale_linearRebind(scale, linear) {
        return d3.rebind(scale, linear, 'range', 'rangeRound', 'interpolate', 'clamp');
    }
    function d3_scale_linearNice(domain, m) {
        return d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
    }
    function d3_scale_linearTickRange(domain, m) {
        if (m == null)
            m = 10;
        var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
        if (err <= 0.15)
            step *= 10;
        else if (err <= 0.35)
            step *= 5;
        else if (err <= 0.75)
            step *= 2;
        extent[0] = Math.ceil(extent[0] / step) * step;
        extent[1] = Math.floor(extent[1] / step) * step + step * 0.5;
        extent[2] = step;
        return extent;
    }
    function d3_scale_linearTicks(domain, m) {
        return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
    }
    function d3_scale_linearTickFormat(domain, m, format) {
        var range = d3_scale_linearTickRange(domain, m);
        if (format) {
            var match = d3_format_re.exec(format);
            match.shift();
            if (match[8] === 's') {
                var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
                if (!match[7])
                    match[7] = '.' + d3_scale_linearPrecision(prefix.scale(range[2]));
                match[8] = 'f';
                format = d3.format(match.join(''));
                return function (d) {
                    return format(prefix.scale(d)) + prefix.symbol;
                };
            }
            if (!match[7])
                match[7] = '.' + d3_scale_linearFormatPrecision(match[8], range);
            format = match.join('');
        } else {
            format = ',.' + d3_scale_linearPrecision(range[2]) + 'f';
        }
        return d3.format(format);
    }
    var d3_scale_linearFormatSignificant = {
        s: 1,
        g: 1,
        p: 1,
        r: 1,
        e: 1
    };
    function d3_scale_linearPrecision(value) {
        return -Math.floor(Math.log(value) / Math.LN10 + 0.01);
    }
    function d3_scale_linearFormatPrecision(type, range) {
        var p = d3_scale_linearPrecision(range[2]);
        return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== 'e') : p - (type === '%') * 2;
    }
    d3.scale.log = function () {
        return d3_scale_log(d3.scale.linear().domain([
            0,
            1
        ]), 10, true, [
            1,
            10
        ]);
    };
    function d3_scale_log(linear, base, positive, domain) {
        function log(x) {
            return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
        }
        function pow(x) {
            return positive ? Math.pow(base, x) : -Math.pow(base, -x);
        }
        function scale(x) {
            return linear(log(x));
        }
        scale.invert = function (x) {
            return pow(linear.invert(x));
        };
        scale.domain = function (x) {
            if (!arguments.length)
                return domain;
            positive = x[0] >= 0;
            linear.domain((domain = x.map(Number)).map(log));
            return scale;
        };
        scale.base = function (_) {
            if (!arguments.length)
                return base;
            base = +_;
            linear.domain(domain.map(log));
            return scale;
        };
        scale.nice = function () {
            var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
            linear.domain(niced);
            domain = niced.map(pow);
            return scale;
        };
        scale.ticks = function () {
            var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;
            if (isFinite(j - i)) {
                if (positive) {
                    for (; i < j; i++)
                        for (var k = 1; k < n; k++)
                            ticks.push(pow(i) * k);
                    ticks.push(pow(i));
                } else {
                    ticks.push(pow(i));
                    for (; i++ < j;)
                        for (var k = n - 1; k > 0; k--)
                            ticks.push(pow(i) * k);
                }
                for (i = 0; ticks[i] < u; i++) {
                }
                for (j = ticks.length; ticks[j - 1] > v; j--) {
                }
                ticks = ticks.slice(i, j);
            }
            return ticks;
        };
        scale.tickFormat = function (n, format) {
            if (!arguments.length)
                return d3_scale_logFormat;
            if (arguments.length < 2)
                format = d3_scale_logFormat;
            else if (typeof format !== 'function')
                format = d3.format(format);
            var k = Math.max(0.1, n / scale.ticks().length), f = positive ? (e = 1e-12, Math.ceil) : (e = -1e-12, Math.floor), e;
            return function (d) {
                return d / pow(f(log(d) + e)) <= k ? format(d) : '';
            };
        };
        scale.copy = function () {
            return d3_scale_log(linear.copy(), base, positive, domain);
        };
        return d3_scale_linearRebind(scale, linear);
    }
    var d3_scale_logFormat = d3.format('.0e'), d3_scale_logNiceNegative = {
            floor: function (x) {
                return -Math.ceil(-x);
            },
            ceil: function (x) {
                return -Math.floor(-x);
            }
        };
    d3.scale.pow = function () {
        return d3_scale_pow(d3.scale.linear(), 1, [
            0,
            1
        ]);
    };
    function d3_scale_pow(linear, exponent, domain) {
        var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
        function scale(x) {
            return linear(powp(x));
        }
        scale.invert = function (x) {
            return powb(linear.invert(x));
        };
        scale.domain = function (x) {
            if (!arguments.length)
                return domain;
            linear.domain((domain = x.map(Number)).map(powp));
            return scale;
        };
        scale.ticks = function (m) {
            return d3_scale_linearTicks(domain, m);
        };
        scale.tickFormat = function (m, format) {
            return d3_scale_linearTickFormat(domain, m, format);
        };
        scale.nice = function (m) {
            return scale.domain(d3_scale_linearNice(domain, m));
        };
        scale.exponent = function (x) {
            if (!arguments.length)
                return exponent;
            powp = d3_scale_powPow(exponent = x);
            powb = d3_scale_powPow(1 / exponent);
            linear.domain(domain.map(powp));
            return scale;
        };
        scale.copy = function () {
            return d3_scale_pow(linear.copy(), exponent, domain);
        };
        return d3_scale_linearRebind(scale, linear);
    }
    function d3_scale_powPow(e) {
        return function (x) {
            return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
        };
    }
    d3.scale.sqrt = function () {
        return d3.scale.pow().exponent(0.5);
    };
    d3.scale.ordinal = function () {
        return d3_scale_ordinal([], {
            t: 'range',
            a: [[]]
        });
    };
    function d3_scale_ordinal(domain, ranger) {
        var index, range, rangeBand;
        function scale(x) {
            return range[((index.get(x) || (ranger.t === 'range' ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
        }
        function steps(start, step) {
            return d3.range(domain.length).map(function (i) {
                return start + step * i;
            });
        }
        scale.domain = function (x) {
            if (!arguments.length)
                return domain;
            domain = [];
            index = new d3_Map();
            var i = -1, n = x.length, xi;
            while (++i < n)
                if (!index.has(xi = x[i]))
                    index.set(xi, domain.push(xi));
            return scale[ranger.t].apply(scale, ranger.a);
        };
        scale.range = function (x) {
            if (!arguments.length)
                return range;
            range = x;
            rangeBand = 0;
            ranger = {
                t: 'range',
                a: arguments
            };
            return scale;
        };
        scale.rangePoints = function (x, padding) {
            if (arguments.length < 2)
                padding = 0;
            var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2, 0) : (stop - start) / (domain.length - 1 + padding);
            range = steps(start + step * padding / 2, step);
            rangeBand = 0;
            ranger = {
                t: 'rangePoints',
                a: arguments
            };
            return scale;
        };
        scale.rangeRoundPoints = function (x, padding) {
            if (arguments.length < 2)
                padding = 0;
            var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), 0) : (stop - start) / (domain.length - 1 + padding) | 0;
            range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
            rangeBand = 0;
            ranger = {
                t: 'rangeRoundPoints',
                a: arguments
            };
            return scale;
        };
        scale.rangeBands = function (x, padding, outerPadding) {
            if (arguments.length < 2)
                padding = 0;
            if (arguments.length < 3)
                outerPadding = padding;
            var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
            range = steps(start + step * outerPadding, step);
            if (reverse)
                range.reverse();
            rangeBand = step * (1 - padding);
            ranger = {
                t: 'rangeBands',
                a: arguments
            };
            return scale;
        };
        scale.rangeRoundBands = function (x, padding, outerPadding) {
            if (arguments.length < 2)
                padding = 0;
            if (arguments.length < 3)
                outerPadding = padding;
            var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
            range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
            if (reverse)
                range.reverse();
            rangeBand = Math.round(step * (1 - padding));
            ranger = {
                t: 'rangeRoundBands',
                a: arguments
            };
            return scale;
        };
        scale.rangeBand = function () {
            return rangeBand;
        };
        scale.rangeExtent = function () {
            return d3_scaleExtent(ranger.a[0]);
        };
        scale.copy = function () {
            return d3_scale_ordinal(domain, ranger);
        };
        return scale.domain(domain);
    }
    d3.scale.category10 = function () {
        return d3.scale.ordinal().range(d3_category10);
    };
    d3.scale.category20 = function () {
        return d3.scale.ordinal().range(d3_category20);
    };
    d3.scale.category20b = function () {
        return d3.scale.ordinal().range(d3_category20b);
    };
    d3.scale.category20c = function () {
        return d3.scale.ordinal().range(d3_category20c);
    };
    var d3_category10 = [
        2062260,
        16744206,
        2924588,
        14034728,
        9725885,
        9197131,
        14907330,
        8355711,
        12369186,
        1556175
    ].map(d3_rgbString);
    var d3_category20 = [
        2062260,
        11454440,
        16744206,
        16759672,
        2924588,
        10018698,
        14034728,
        16750742,
        9725885,
        12955861,
        9197131,
        12885140,
        14907330,
        16234194,
        8355711,
        13092807,
        12369186,
        14408589,
        1556175,
        10410725
    ].map(d3_rgbString);
    var d3_category20b = [
        3750777,
        5395619,
        7040719,
        10264286,
        6519097,
        9216594,
        11915115,
        13556636,
        9202993,
        12426809,
        15186514,
        15190932,
        8666169,
        11356490,
        14049643,
        15177372,
        8077683,
        10834324,
        13528509,
        14589654
    ].map(d3_rgbString);
    var d3_category20c = [
        3244733,
        7057110,
        10406625,
        13032431,
        15095053,
        16616764,
        16625259,
        16634018,
        3253076,
        7652470,
        10607003,
        13101504,
        7695281,
        10394312,
        12369372,
        14342891,
        6513507,
        9868950,
        12434877,
        14277081
    ].map(d3_rgbString);
    d3.scale.quantile = function () {
        return d3_scale_quantile([], []);
    };
    function d3_scale_quantile(domain, range) {
        var thresholds;
        function rescale() {
            var k = 0, q = range.length;
            thresholds = [];
            while (++k < q)
                thresholds[k - 1] = d3.quantile(domain, k / q);
            return scale;
        }
        function scale(x) {
            if (!isNaN(x = +x))
                return range[d3.bisect(thresholds, x)];
        }
        scale.domain = function (x) {
            if (!arguments.length)
                return domain;
            domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
            return rescale();
        };
        scale.range = function (x) {
            if (!arguments.length)
                return range;
            range = x;
            return rescale();
        };
        scale.quantiles = function () {
            return thresholds;
        };
        scale.invertExtent = function (y) {
            y = range.indexOf(y);
            return y < 0 ? [
                NaN,
                NaN
            ] : [
                y > 0 ? thresholds[y - 1] : domain[0],
                y < thresholds.length ? thresholds[y] : domain[domain.length - 1]
            ];
        };
        scale.copy = function () {
            return d3_scale_quantile(domain, range);
        };
        return rescale();
    }
    d3.scale.quantize = function () {
        return d3_scale_quantize(0, 1, [
            0,
            1
        ]);
    };
    function d3_scale_quantize(x0, x1, range) {
        var kx, i;
        function scale(x) {
            return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
        }
        function rescale() {
            kx = range.length / (x1 - x0);
            i = range.length - 1;
            return scale;
        }
        scale.domain = function (x) {
            if (!arguments.length)
                return [
                    x0,
                    x1
                ];
            x0 = +x[0];
            x1 = +x[x.length - 1];
            return rescale();
        };
        scale.range = function (x) {
            if (!arguments.length)
                return range;
            range = x;
            return rescale();
        };
        scale.invertExtent = function (y) {
            y = range.indexOf(y);
            y = y < 0 ? NaN : y / kx + x0;
            return [
                y,
                y + 1 / kx
            ];
        };
        scale.copy = function () {
            return d3_scale_quantize(x0, x1, range);
        };
        return rescale();
    }
    d3.scale.threshold = function () {
        return d3_scale_threshold([0.5], [
            0,
            1
        ]);
    };
    function d3_scale_threshold(domain, range) {
        function scale(x) {
            if (x <= x)
                return range[d3.bisect(domain, x)];
        }
        scale.domain = function (_) {
            if (!arguments.length)
                return domain;
            domain = _;
            return scale;
        };
        scale.range = function (_) {
            if (!arguments.length)
                return range;
            range = _;
            return scale;
        };
        scale.invertExtent = function (y) {
            y = range.indexOf(y);
            return [
                domain[y - 1],
                domain[y]
            ];
        };
        scale.copy = function () {
            return d3_scale_threshold(domain, range);
        };
        return scale;
    }
    d3.scale.identity = function () {
        return d3_scale_identity([
            0,
            1
        ]);
    };
    function d3_scale_identity(domain) {
        function identity(x) {
            return +x;
        }
        identity.invert = identity;
        identity.domain = identity.range = function (x) {
            if (!arguments.length)
                return domain;
            domain = x.map(identity);
            return identity;
        };
        identity.ticks = function (m) {
            return d3_scale_linearTicks(domain, m);
        };
        identity.tickFormat = function (m, format) {
            return d3_scale_linearTickFormat(domain, m, format);
        };
        identity.copy = function () {
            return d3_scale_identity(domain);
        };
        return identity;
    }
    d3.svg = {};
    function d3_zero() {
        return 0;
    }
    d3.svg.arc = function () {
        var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;
        function arc() {
            var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - half, a1 = endAngle.apply(this, arguments) - half, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;
            if (r1 < r0)
                rc = r1, r1 = r0, r0 = rc;
            if (da >= )
                return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : '') + 'Z';
            var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];
            if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
                rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
                if (!cw)
                    p1 *= -1;
                if (r1)
                    p1 = d3_asin(rp / r1 * Math.sin(ap));
                if (r0)
                    p0 = d3_asin(rp / r0 * Math.sin(ap));
            }
            if (r1) {
                x0 = r1 * Math.cos(a0 + p1);
                y0 = r1 * Math.sin(a0 + p1);
                x1 = r1 * Math.cos(a1 - p1);
                y1 = r1 * Math.sin(a1 - p1);
                var l1 = Math.abs(a1 - a0 - 2 * p1) <=  ? 0 : 1;
                if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
                    var h1 = (a0 + a1) / 2;
                    x0 = r1 * Math.cos(h1);
                    y0 = r1 * Math.sin(h1);
                    x1 = y1 = null;
                }
            } else {
                x0 = y0 = 0;
            }
            if (r0) {
                x2 = r0 * Math.cos(a1 - p0);
                y2 = r0 * Math.sin(a1 - p0);
                x3 = r0 * Math.cos(a0 + p0);
                y3 = r0 * Math.sin(a0 + p0);
                var l0 = Math.abs(a0 - a1 + 2 * p0) <=  ? 0 : 1;
                if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
                    var h0 = (a0 + a1) / 2;
                    x2 = r0 * Math.cos(h0);
                    y2 = r0 * Math.sin(h0);
                    x3 = y3 = null;
                }
            } else {
                x2 = y2 = 0;
            }
            if ((rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > 0.001) {
                cr = r0 < r1 ^ cw ? 0 : 1;
                var oc = x3 == null ? [
                        x2,
                        y2
                    ] : x1 == null ? [
                        x0,
                        y0
                    ] : d3_geom_polygonIntersect([
                        x0,
                        y0
                    ], [
                        x3,
                        y3
                    ], [
                        x1,
                        y1
                    ], [
                        x2,
                        y2
                    ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
                if (x1 != null) {
                    var rc1 = Math.min(rc, (r1 - lc) / (kc + 1)), t30 = d3_svg_arcCornerTangents(x3 == null ? [
                            x2,
                            y2
                        ] : [
                            x3,
                            y3
                        ], [
                            x0,
                            y0
                        ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([
                            x1,
                            y1
                        ], [
                            x2,
                            y2
                        ], r1, rc1, cw);
                    if (rc === rc1) {
                        path.push('M', t30[0], 'A', rc1, ',', rc1, ' 0 0,', cr, ' ', t30[1], 'A', r1, ',', r1, ' 0 ', 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ',', cw, ' ', t12[1], 'A', rc1, ',', rc1, ' 0 0,', cr, ' ', t12[0]);
                    } else {
                        path.push('M', t30[0], 'A', rc1, ',', rc1, ' 0 1,', cr, ' ', t12[0]);
                    }
                } else {
                    path.push('M', x0, ',', y0);
                }
                if (x3 != null) {
                    var rc0 = Math.min(rc, (r0 - lc) / (kc - 1)), t03 = d3_svg_arcCornerTangents([
                            x0,
                            y0
                        ], [
                            x3,
                            y3
                        ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([
                            x2,
                            y2
                        ], x1 == null ? [
                            x0,
                            y0
                        ] : [
                            x1,
                            y1
                        ], r0, -rc0, cw);
                    if (rc === rc0) {
                        path.push('L', t21[0], 'A', rc0, ',', rc0, ' 0 0,', cr, ' ', t21[1], 'A', r0, ',', r0, ' 0 ', cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ',', 1 - cw, ' ', t03[1], 'A', rc0, ',', rc0, ' 0 0,', cr, ' ', t03[0]);
                    } else {
                        path.push('L', t21[0], 'A', rc0, ',', rc0, ' 0 0,', cr, ' ', t03[0]);
                    }
                } else {
                    path.push('L', x2, ',', y2);
                }
            } else {
                path.push('M', x0, ',', y0);
                if (x1 != null)
                    path.push('A', r1, ',', r1, ' 0 ', l1, ',', cw, ' ', x1, ',', y1);
                path.push('L', x2, ',', y2);
                if (x3 != null)
                    path.push('A', r0, ',', r0, ' 0 ', l0, ',', 1 - cw, ' ', x3, ',', y3);
            }
            path.push('Z');
            return path.join('');
        }
        function circleSegment(r1, cw) {
            return 'M0,' + r1 + 'A' + r1 + ',' + r1 + ' 0 1,' + cw + ' 0,' + -r1 + 'A' + r1 + ',' + r1 + ' 0 1,' + cw + ' 0,' + r1;
        }
        arc.innerRadius = function (v) {
            if (!arguments.length)
                return innerRadius;
            innerRadius = d3_functor(v);
            return arc;
        };
        arc.outerRadius = function (v) {
            if (!arguments.length)
                return outerRadius;
            outerRadius = d3_functor(v);
            return arc;
        };
        arc.cornerRadius = function (v) {
            if (!arguments.length)
                return cornerRadius;
            cornerRadius = d3_functor(v);
            return arc;
        };
        arc.padRadius = function (v) {
            if (!arguments.length)
                return padRadius;
            padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
            return arc;
        };
        arc.startAngle = function (v) {
            if (!arguments.length)
                return startAngle;
            startAngle = d3_functor(v);
            return arc;
        };
        arc.endAngle = function (v) {
            if (!arguments.length)
                return endAngle;
            endAngle = d3_functor(v);
            return arc;
        };
        arc.padAngle = function (v) {
            if (!arguments.length)
                return padAngle;
            padAngle = d3_functor(v);
            return arc;
        };
        arc.centroid = function () {
            var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - half;
            return [
                Math.cos(a) * r,
                Math.sin(a) * r
            ];
        };
        return arc;
    };
    var d3_svg_arcAuto = 'auto';
    function d3_svg_arcInnerRadius(d) {
        return d.innerRadius;
    }
    function d3_svg_arcOuterRadius(d) {
        return d.outerRadius;
    }
    function d3_svg_arcStartAngle(d) {
        return d.startAngle;
    }
    function d3_svg_arcEndAngle(d) {
        return d.endAngle;
    }
    function d3_svg_arcPadAngle(d) {
        return d && d.padAngle;
    }
    function d3_svg_arcSweep(x0, y0, x1, y1) {
        return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
    }
    function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
        var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(r * r * d2 - D * D), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;
        if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)
            cx0 = cx1, cy0 = cy1;
        return [
            [
                cx0 - ox,
                cy0 - oy
            ],
            [
                cx0 * r1 / r,
                cy0 * r1 / r
            ]
        ];
    }
    function d3_svg_line(projection) {
        var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = 0.7;
        function line(data) {
            var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
            function segment() {
                segments.push('M', interpolate(projection(points), tension));
            }
            while (++i < n) {
                if (defined.call(this, d = data[i], i)) {
                    points.push([
                        +fx.call(this, d, i),
                        +fy.call(this, d, i)
                    ]);
                } else if (points.length) {
                    segment();
                    points = [];
                }
            }
            if (points.length)
                segment();
            return segments.length ? segments.join('') : null;
        }
        line.x = function (_) {
            if (!arguments.length)
                return x;
            x = _;
            return line;
        };
        line.y = function (_) {
            if (!arguments.length)
                return y;
            y = _;
            return line;
        };
        line.defined = function (_) {
            if (!arguments.length)
                return defined;
            defined = _;
            return line;
        };
        line.interpolate = function (_) {
            if (!arguments.length)
                return interpolateKey;
            if (typeof _ === 'function')
                interpolateKey = interpolate = _;
            else
                interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
            return line;
        };
        line.tension = function (_) {
            if (!arguments.length)
                return tension;
            tension = _;
            return line;
        };
        return line;
    }
    d3.svg.line = function () {
        return d3_svg_line(d3_identity);
    };
    var d3_svg_lineInterpolators = d3.map({
        linear: d3_svg_lineLinear,
        'linear-closed': d3_svg_lineLinearClosed,
        step: d3_svg_lineStep,
        'step-before': d3_svg_lineStepBefore,
        'step-after': d3_svg_lineStepAfter,
        basis: d3_svg_lineBasis,
        'basis-open': d3_svg_lineBasisOpen,
        'basis-closed': d3_svg_lineBasisClosed,
        bundle: d3_svg_lineBundle,
        cardinal: d3_svg_lineCardinal,
        'cardinal-open': d3_svg_lineCardinalOpen,
        'cardinal-closed': d3_svg_lineCardinalClosed,
        monotone: d3_svg_lineMonotone
    });
    d3_svg_lineInterpolators.forEach(function (key, value) {
        value.key = key;
        value.closed = /-closed$/.test(key);
    });
    function d3_svg_lineLinear(points) {
        return points.join('L');
    }
    function d3_svg_lineLinearClosed(points) {
        return d3_svg_lineLinear(points) + 'Z';
    }
    function d3_svg_lineStep(points) {
        var i = 0, n = points.length, p = points[0], path = [
                p[0],
                ',',
                p[1]
            ];
        while (++i < n)
            path.push('H', (p[0] + (p = points[i])[0]) / 2, 'V', p[1]);
        if (n > 1)
            path.push('H', p[0]);
        return path.join('');
    }
    function d3_svg_lineStepBefore(points) {
        var i = 0, n = points.length, p = points[0], path = [
                p[0],
                ',',
                p[1]
            ];
        while (++i < n)
            path.push('V', (p = points[i])[1], 'H', p[0]);
        return path.join('');
    }
    function d3_svg_lineStepAfter(points) {
        var i = 0, n = points.length, p = points[0], path = [
                p[0],
                ',',
                p[1]
            ];
        while (++i < n)
            path.push('H', (p = points[i])[0], 'V', p[1]);
        return path.join('');
    }
    function d3_svg_lineCardinalOpen(points, tension) {
        return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
    }
    function d3_svg_lineCardinalClosed(points, tension) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), points), d3_svg_lineCardinalTangents([points[points.length - 2]].concat(points, [points[1]]), tension));
    }
    function d3_svg_lineCardinal(points, tension) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
    }
    function d3_svg_lineHermite(points, tangents) {
        if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
            return d3_svg_lineLinear(points);
        }
        var quad = points.length != tangents.length, path = '', p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
        if (quad) {
            path += 'Q' + (p[0] - t0[0] * 2 / 3) + ',' + (p[1] - t0[1] * 2 / 3) + ',' + p[0] + ',' + p[1];
            p0 = points[1];
            pi = 2;
        }
        if (tangents.length > 1) {
            t = tangents[1];
            p = points[pi];
            pi++;
            path += 'C' + (p0[0] + t0[0]) + ',' + (p0[1] + t0[1]) + ',' + (p[0] - t[0]) + ',' + (p[1] - t[1]) + ',' + p[0] + ',' + p[1];
            for (var i = 2; i < tangents.length; i++, pi++) {
                p = points[pi];
                t = tangents[i];
                path += 'S' + (p[0] - t[0]) + ',' + (p[1] - t[1]) + ',' + p[0] + ',' + p[1];
            }
        }
        if (quad) {
            var lp = points[pi];
            path += 'Q' + (p[0] + t[0] * 2 / 3) + ',' + (p[1] + t[1] * 2 / 3) + ',' + lp[0] + ',' + lp[1];
        }
        return path;
    }
    function d3_svg_lineCardinalTangents(points, tension) {
        var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
        while (++i < n) {
            p0 = p1;
            p1 = p2;
            p2 = points[i];
            tangents.push([
                a * (p2[0] - p0[0]),
                a * (p2[1] - p0[1])
            ]);
        }
        return tangents;
    }
    function d3_svg_lineBasis(points) {
        if (points.length < 3)
            return d3_svg_lineLinear(points);
        var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [
                x0,
                x0,
                x0,
                (pi = points[1])[0]
            ], py = [
                y0,
                y0,
                y0,
                pi[1]
            ], path = [
                x0,
                ',',
                y0,
                'L',
                d3_svg_lineDot4(d3_svg_lineBasisBezier3, px),
                ',',
                d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)
            ];
        points.push(points[n - 1]);
        while (++i <= n) {
            pi = points[i];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
        }
        points.pop();
        path.push('L', pi);
        return path.join('');
    }
    function d3_svg_lineBasisOpen(points) {
        if (points.length < 4)
            return d3_svg_lineLinear(points);
        var path = [], i = -1, n = points.length, pi, px = [0], py = [0];
        while (++i < 3) {
            pi = points[i];
            px.push(pi[0]);
            py.push(pi[1]);
        }
        path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + ',' + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
        --i;
        while (++i < n) {
            pi = points[i];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
        }
        return path.join('');
    }
    function d3_svg_lineBasisClosed(points) {
        var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
        while (++i < 4) {
            pi = points[i % n];
            px.push(pi[0]);
            py.push(pi[1]);
        }
        path = [
            d3_svg_lineDot4(d3_svg_lineBasisBezier3, px),
            ',',
            d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)
        ];
        --i;
        while (++i < m) {
            pi = points[i % n];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
        }
        return path.join('');
    }
    function d3_svg_lineBundle(points, tension) {
        var n = points.length - 1;
        if (n) {
            var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
            while (++i <= n) {
                p = points[i];
                t = i / n;
                p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
                p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
            }
        }
        return d3_svg_lineBasis(points);
    }
    function d3_svg_lineDot4(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
    }
    var d3_svg_lineBasisBezier1 = [
            0,
            2 / 3,
            1 / 3,
            0
        ], d3_svg_lineBasisBezier2 = [
            0,
            1 / 3,
            2 / 3,
            0
        ], d3_svg_lineBasisBezier3 = [
            0,
            1 / 6,
            2 / 3,
            1 / 6
        ];
    function d3_svg_lineBasisBezier(path, x, y) {
        path.push('C', d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ',', d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ',', d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ',', d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ',', d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ',', d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
    }
    function d3_svg_lineSlope(p0, p1) {
        return (p1[1] - p0[1]) / (p1[0] - p0[0]);
    }
    function d3_svg_lineFiniteDifferences(points) {
        var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
        while (++i < j) {
            m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
        }
        m[i] = d;
        return m;
    }
    function d3_svg_lineMonotoneTangents(points) {
        var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
        while (++i < j) {
            d = d3_svg_lineSlope(points[i], points[i + 1]);
            if (abs(d) < ) {
                m[i] = m[i + 1] = 0;
            } else {
                a = m[i] / d;
                b = m[i + 1] / d;
                s = a * a + b * b;
                if (s > 9) {
                    s = d * 3 / Math.sqrt(s);
                    m[i] = s * a;
                    m[i + 1] = s * b;
                }
            }
        }
        i = -1;
        while (++i <= j) {
            s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
            tangents.push([
                s || 0,
                m[i] * s || 0
            ]);
        }
        return tangents;
    }
    function d3_svg_lineMonotone(points) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
    }
    d3.svg.line.radial = function () {
        var line = d3_svg_line(d3_svg_lineRadial);
        line.radius = line.x, delete line.x;
        line.angle = line.y, delete line.y;
        return line;
    };
    function d3_svg_lineRadial(points) {
        var point, i = -1, n = points.length, r, a;
        while (++i < n) {
            point = points[i];
            r = point[0];
            a = point[1] - half;
            point[0] = r * Math.cos(a);
            point[1] = r * Math.sin(a);
        }
        return points;
    }
    function d3_svg_area(projection) {
        var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = 'L', tension = 0.7;
        function area(data) {
            var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function () {
                    return x;
                } : d3_functor(x1), fy1 = y0 === y1 ? function () {
                    return y;
                } : d3_functor(y1), x, y;
            function segment() {
                segments.push('M', interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), 'Z');
            }
            while (++i < n) {
                if (defined.call(this, d = data[i], i)) {
                    points0.push([
                        x = +fx0.call(this, d, i),
                        y = +fy0.call(this, d, i)
                    ]);
                    points1.push([
                        +fx1.call(this, d, i),
                        +fy1.call(this, d, i)
                    ]);
                } else if (points0.length) {
                    segment();
                    points0 = [];
                    points1 = [];
                }
            }
            if (points0.length)
                segment();
            return segments.length ? segments.join('') : null;
        }
        area.x = function (_) {
            if (!arguments.length)
                return x1;
            x0 = x1 = _;
            return area;
        };
        area.x0 = function (_) {
            if (!arguments.length)
                return x0;
            x0 = _;
            return area;
        };
        area.x1 = function (_) {
            if (!arguments.length)
                return x1;
            x1 = _;
            return area;
        };
        area.y = function (_) {
            if (!arguments.length)
                return y1;
            y0 = y1 = _;
            return area;
        };
        area.y0 = function (_) {
            if (!arguments.length)
                return y0;
            y0 = _;
            return area;
        };
        area.y1 = function (_) {
            if (!arguments.length)
                return y1;
            y1 = _;
            return area;
        };
        area.defined = function (_) {
            if (!arguments.length)
                return defined;
            defined = _;
            return area;
        };
        area.interpolate = function (_) {
            if (!arguments.length)
                return interpolateKey;
            if (typeof _ === 'function')
                interpolateKey = interpolate = _;
            else
                interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
            interpolateReverse = interpolate.reverse || interpolate;
            L = interpolate.closed ? 'M' : 'L';
            return area;
        };
        area.tension = function (_) {
            if (!arguments.length)
                return tension;
            tension = _;
            return area;
        };
        return area;
    }
    d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
    d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
    d3.svg.area = function () {
        return d3_svg_area(d3_identity);
    };
    d3.svg.area.radial = function () {
        var area = d3_svg_area(d3_svg_lineRadial);
        area.radius = area.x, delete area.x;
        area.innerRadius = area.x0, delete area.x0;
        area.outerRadius = area.x1, delete area.x1;
        area.angle = area.y, delete area.y;
        area.startAngle = area.y0, delete area.y0;
        area.endAngle = area.y1, delete area.y1;
        return area;
    };
    d3.svg.chord = function () {
        var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
        function chord(d, i) {
            var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
            return 'M' + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + 'Z';
        }
        function subgroup(self, f, d, i) {
            var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - half, a1 = endAngle.call(self, subgroup, i) - half;
            return {
                r: r,
                a0: a0,
                a1: a1,
                p0: [
                    r * Math.cos(a0),
                    r * Math.sin(a0)
                ],
                p1: [
                    r * Math.cos(a1),
                    r * Math.sin(a1)
                ]
            };
        }
        function equals(a, b) {
            return a.a0 == b.a0 && a.a1 == b.a1;
        }
        function arc(r, p, a) {
            return 'A' + r + ',' + r + ' 0 ' + +(a > ) + ',1 ' + p;
        }
        function curve(r0, p0, r1, p1) {
            return 'Q 0,0 ' + p1;
        }
        chord.radius = function (v) {
            if (!arguments.length)
                return radius;
            radius = d3_functor(v);
            return chord;
        };
        chord.source = function (v) {
            if (!arguments.length)
                return source;
            source = d3_functor(v);
            return chord;
        };
        chord.target = function (v) {
            if (!arguments.length)
                return target;
            target = d3_functor(v);
            return chord;
        };
        chord.startAngle = function (v) {
            if (!arguments.length)
                return startAngle;
            startAngle = d3_functor(v);
            return chord;
        };
        chord.endAngle = function (v) {
            if (!arguments.length)
                return endAngle;
            endAngle = d3_functor(v);
            return chord;
        };
        return chord;
    };
    function d3_svg_chordRadius(d) {
        return d.radius;
    }
    d3.svg.diagonal = function () {
        var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
        function diagonal(d, i) {
            var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [
                    p0,
                    {
                        x: p0.x,
                        y: m
                    },
                    {
                        x: p3.x,
                        y: m
                    },
                    p3
                ];
            p = p.map(projection);
            return 'M' + p[0] + 'C' + p[1] + ' ' + p[2] + ' ' + p[3];
        }
        diagonal.source = function (x) {
            if (!arguments.length)
                return source;
            source = d3_functor(x);
            return diagonal;
        };
        diagonal.target = function (x) {
            if (!arguments.length)
                return target;
            target = d3_functor(x);
            return diagonal;
        };
        diagonal.projection = function (x) {
            if (!arguments.length)
                return projection;
            projection = x;
            return diagonal;
        };
        return diagonal;
    };
    function d3_svg_diagonalProjection(d) {
        return [
            d.x,
            d.y
        ];
    }
    d3.svg.diagonal.radial = function () {
        var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
        diagonal.projection = function (x) {
            return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
        };
        return diagonal;
    };
    function d3_svg_diagonalRadialProjection(projection) {
        return function () {
            var d = projection.apply(this, arguments), r = d[0], a = d[1] - half;
            return [
                r * Math.cos(a),
                r * Math.sin(a)
            ];
        };
    }
    d3.svg.symbol = function () {
        var type = d3_svg_symbolType, size = d3_svg_symbolSize;
        function symbol(d, i) {
            return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
        }
        symbol.type = function (x) {
            if (!arguments.length)
                return type;
            type = d3_functor(x);
            return symbol;
        };
        symbol.size = function (x) {
            if (!arguments.length)
                return size;
            size = d3_functor(x);
            return symbol;
        };
        return symbol;
    };
    function d3_svg_symbolSize() {
        return 64;
    }
    function d3_svg_symbolType() {
        return 'circle';
    }
    function d3_svg_symbolCircle(size) {
        var r = Math.sqrt(size / );
        return 'M0,' + r + 'A' + r + ',' + r + ' 0 1,1 0,' + -r + 'A' + r + ',' + r + ' 0 1,1 0,' + r + 'Z';
    }
    var d3_svg_symbols = d3.map({
        circle: d3_svg_symbolCircle,
        cross: function (size) {
            var r = Math.sqrt(size / 5) / 2;
            return 'M' + -3 * r + ',' + -r + 'H' + -r + 'V' + -3 * r + 'H' + r + 'V' + -r + 'H' + 3 * r + 'V' + r + 'H' + r + 'V' + 3 * r + 'H' + -r + 'V' + r + 'H' + -3 * r + 'Z';
        },
        diamond: function (size) {
            var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
            return 'M0,' + -ry + 'L' + rx + ',0' + ' 0,' + ry + ' ' + -rx + ',0' + 'Z';
        },
        square: function (size) {
            var r = Math.sqrt(size) / 2;
            return 'M' + -r + ',' + -r + 'L' + r + ',' + -r + ' ' + r + ',' + r + ' ' + -r + ',' + r + 'Z';
        },
        'triangle-down': function (size) {
            var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
            return 'M0,' + ry + 'L' + rx + ',' + -ry + ' ' + -rx + ',' + -ry + 'Z';
        },
        'triangle-up': function (size) {
            var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
            return 'M0,' + -ry + 'L' + rx + ',' + ry + ' ' + -rx + ',' + ry + 'Z';
        }
    });
    d3.svg.symbolTypes = d3_svg_symbols.keys();
    var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
    d3_selectionPrototype.transition = function (name) {
        var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {
                time: Date.now(),
                ease: d3_ease_cubicInOut,
                delay: 0,
                duration: 250
            };
        for (var j = -1, m = this.length; ++j < m;) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = -1, n = group.length; ++i < n;) {
                if (node = group[i])
                    d3_transitionNode(node, i, ns, id, transition);
                subgroup.push(node);
            }
        }
        return d3_transition(subgroups, ns, id);
    };
    d3_selectionPrototype.interrupt = function (name) {
        return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));
    };
    var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());
    function d3_selection_interruptNS(ns) {
        return function () {
            var lock, active;
            if ((lock = this[ns]) && (active = lock[lock.active])) {
                if (--lock.count)
                    delete lock[lock.active];
                else
                    delete this[ns];
                lock.active += 0.5;
                active.event && active.event.interrupt.call(this, this.__data__, active.index);
            }
        };
    }
    function d3_transition(groups, ns, id) {
        d3_subclass(groups, d3_transitionPrototype);
        groups.namespace = ns;
        groups.id = id;
        return groups;
    }
    var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
    d3_transitionPrototype.call = d3_selectionPrototype.call;
    d3_transitionPrototype.empty = d3_selectionPrototype.empty;
    d3_transitionPrototype.node = d3_selectionPrototype.node;
    d3_transitionPrototype.size = d3_selectionPrototype.size;
    d3.transition = function (selection, name) {
        return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);
    };
    d3.transition.prototype = d3_transitionPrototype;
    d3_transitionPrototype.select = function (selector) {
        var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;
        selector = d3_selection_selector(selector);
        for (var j = -1, m = this.length; ++j < m;) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = -1, n = group.length; ++i < n;) {
                if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
                    if ('__data__' in node)
                        subnode.__data__ = node.__data__;
                    d3_transitionNode(subnode, i, ns, id, node[ns][id]);
                    subgroup.push(subnode);
                } else {
                    subgroup.push(null);
                }
            }
        }
        return d3_transition(subgroups, ns, id);
    };
    d3_transitionPrototype.selectAll = function (selector) {
        var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;
        selector = d3_selection_selectorAll(selector);
        for (var j = -1, m = this.length; ++j < m;) {
            for (var group = this[j], i = -1, n = group.length; ++i < n;) {
                if (node = group[i]) {
                    transition = node[ns][id];
                    subnodes = selector.call(node, node.__data__, i, j);
                    subgroups.push(subgroup = []);
                    for (var k = -1, o = subnodes.length; ++k < o;) {
                        if (subnode = subnodes[k])
                            d3_transitionNode(subnode, k, ns, id, transition);
                        subgroup.push(subnode);
                    }
                }
            }
        }
        return d3_transition(subgroups, ns, id);
    };
    d3_transitionPrototype.filter = function (filter) {
        var subgroups = [], subgroup, group, node;
        if (typeof filter !== 'function')
            filter = d3_selection_filter(filter);
        for (var j = 0, m = this.length; j < m; j++) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = 0, n = group.length; i < n; i++) {
                if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
                    subgroup.push(node);
                }
            }
        }
        return d3_transition(subgroups, this.namespace, this.id);
    };
    d3_transitionPrototype.tween = function (name, tween) {
        var id = this.id, ns = this.namespace;
        if (arguments.length < 2)
            return this.node()[ns][id].tween.get(name);
        return d3_selection_each(this, tween == null ? function (node) {
            node[ns][id].tween.remove(name);
        } : function (node) {
            node[ns][id].tween.set(name, tween);
        });
    };
    function d3_transition_tween(groups, name, value, tween) {
        var id = groups.id, ns = groups.namespace;
        return d3_selection_each(groups, typeof value === 'function' ? function (node, i, j) {
            node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
        } : (value = tween(value), function (node) {
            node[ns][id].tween.set(name, value);
        }));
    }
    d3_transitionPrototype.attr = function (nameNS, value) {
        if (arguments.length < 2) {
            for (value in nameNS)
                this.attr(value, nameNS[value]);
            return this;
        }
        var interpolate = nameNS == 'transform' ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);
        function attrNull() {
            this.removeAttribute(name);
        }
        function attrNullNS() {
            this.removeAttributeNS(name.space, name.local);
        }
        function attrTween(b) {
            return b == null ? attrNull : (b += '', function () {
                var a = this.getAttribute(name), i;
                return a !== b && (i = interpolate(a, b), function (t) {
                    this.setAttribute(name, i(t));
                });
            });
        }
        function attrTweenNS(b) {
            return b == null ? attrNullNS : (b += '', function () {
                var a = this.getAttributeNS(name.space, name.local), i;
                return a !== b && (i = interpolate(a, b), function (t) {
                    this.setAttributeNS(name.space, name.local, i(t));
                });
            });
        }
        return d3_transition_tween(this, 'attr.' + nameNS, value, name.local ? attrTweenNS : attrTween);
    };
    d3_transitionPrototype.attrTween = function (nameNS, tween) {
        var name = d3.ns.qualify(nameNS);
        function attrTween(d, i) {
            var f = tween.call(this, d, i, this.getAttribute(name));
            return f && function (t) {
                this.setAttribute(name, f(t));
            };
        }
        function attrTweenNS(d, i) {
            var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
            return f && function (t) {
                this.setAttributeNS(name.space, name.local, f(t));
            };
        }
        return this.tween('attr.' + nameNS, name.local ? attrTweenNS : attrTween);
    };
    d3_transitionPrototype.style = function (name, value, priority) {
        var n = arguments.length;
        if (n < 3) {
            if (typeof name !== 'string') {
                if (n < 2)
                    value = '';
                for (priority in name)
                    this.style(priority, name[priority], value);
                return this;
            }
            priority = '';
        }
        function styleNull() {
            this.style.removeProperty(name);
        }
        function styleString(b) {
            return b == null ? styleNull : (b += '', function () {
                var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;
                return a !== b && (i = d3_interpolate(a, b), function (t) {
                    this.style.setProperty(name, i(t), priority);
                });
            });
        }
        return d3_transition_tween(this, 'style.' + name, value, styleString);
    };
    d3_transitionPrototype.styleTween = function (name, tween, priority) {
        if (arguments.length < 3)
            priority = '';
        function styleTween(d, i) {
            var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
            return f && function (t) {
                this.style.setProperty(name, f(t), priority);
            };
        }
        return this.tween('style.' + name, styleTween);
    };
    d3_transitionPrototype.text = function (value) {
        return d3_transition_tween(this, 'text', value, d3_transition_text);
    };
    function d3_transition_text(b) {
        if (b == null)
            b = '';
        return function () {
            this.textContent = b;
        };
    }
    d3_transitionPrototype.remove = function () {
        var ns = this.namespace;
        return this.each('end.transition', function () {
            var p;
            if (this[ns].count < 2 && (p = this.parentNode))
                p.removeChild(this);
        });
    };
    d3_transitionPrototype.ease = function (value) {
        var id = this.id, ns = this.namespace;
        if (arguments.length < 1)
            return this.node()[ns][id].ease;
        if (typeof value !== 'function')
            value = d3.ease.apply(d3, arguments);
        return d3_selection_each(this, function (node) {
            node[ns][id].ease = value;
        });
    };
    d3_transitionPrototype.delay = function (value) {
        var id = this.id, ns = this.namespace;
        if (arguments.length < 1)
            return this.node()[ns][id].delay;
        return d3_selection_each(this, typeof value === 'function' ? function (node, i, j) {
            node[ns][id].delay = +value.call(node, node.__data__, i, j);
        } : (value = +value, function (node) {
            node[ns][id].delay = value;
        }));
    };
    d3_transitionPrototype.duration = function (value) {
        var id = this.id, ns = this.namespace;
        if (arguments.length < 1)
            return this.node()[ns][id].duration;
        return d3_selection_each(this, typeof value === 'function' ? function (node, i, j) {
            node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));
        } : (value = Math.max(1, value), function (node) {
            node[ns][id].duration = value;
        }));
    };
    d3_transitionPrototype.each = function (type, listener) {
        var id = this.id, ns = this.namespace;
        if (arguments.length < 2) {
            var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
            try {
                d3_transitionInheritId = id;
                d3_selection_each(this, function (node, i, j) {
                    d3_transitionInherit = node[ns][id];
                    type.call(node, node.__data__, i, j);
                });
            } finally {
                d3_transitionInherit = inherit;
                d3_transitionInheritId = inheritId;
            }
        } else {
            d3_selection_each(this, function (node) {
                var transition = node[ns][id];
                (transition.event || (transition.event = d3.dispatch('start', 'end', 'interrupt'))).on(type, listener);
            });
        }
        return this;
    };
    d3_transitionPrototype.transition = function () {
        var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;
        for (var j = 0, m = this.length; j < m; j++) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = 0, n = group.length; i < n; i++) {
                if (node = group[i]) {
                    transition = node[ns][id0];
                    d3_transitionNode(node, i, ns, id1, {
                        time: transition.time,
                        ease: transition.ease,
                        delay: transition.delay + transition.duration,
                        duration: transition.duration
                    });
                }
                subgroup.push(node);
            }
        }
        return d3_transition(subgroups, ns, id1);
    };
    function d3_transitionNamespace(name) {
        return name == null ? '__transition__' : '__transition_' + name + '__';
    }
    function d3_transitionNode(node, i, ns, id, inherit) {
        var lock = node[ns] || (node[ns] = {
                active: 0,
                count: 0
            }), transition = lock[id];
        if (!transition) {
            var time = inherit.time;
            transition = lock[id] = {
                tween: new d3_Map(),
                time: time,
                delay: inherit.delay,
                duration: inherit.duration,
                ease: inherit.ease,
                index: i
            };
            inherit = null;
            ++lock.count;
            d3.timer(function (elapsed) {
                var delay = transition.delay, duration, ease, timer = d3_timer_active, tweened = [];
                timer.t = delay + time;
                if (delay <= elapsed)
                    return start(elapsed - delay);
                timer.c = start;
                function start(elapsed) {
                    if (lock.active > id)
                        return stop();
                    var active = lock[lock.active];
                    if (active) {
                        --lock.count;
                        delete lock[lock.active];
                        active.event && active.event.interrupt.call(node, node.__data__, active.index);
                    }
                    lock.active = id;
                    transition.event && transition.event.start.call(node, node.__data__, i);
                    transition.tween.forEach(function (key, value) {
                        if (value = value.call(node, node.__data__, i)) {
                            tweened.push(value);
                        }
                    });
                    ease = transition.ease;
                    duration = transition.duration;
                    d3.timer(function () {
                        timer.c = tick(elapsed || 1) ? d3_true : tick;
                        return 1;
                    }, 0, time);
                }
                function tick(elapsed) {
                    if (lock.active !== id)
                        return 1;
                    var t = elapsed / duration, e = ease(t), n = tweened.length;
                    while (n > 0) {
                        tweened[--n].call(node, e);
                    }
                    if (t >= 1) {
                        transition.event && transition.event.end.call(node, node.__data__, i);
                        return stop();
                    }
                }
                function stop() {
                    if (--lock.count)
                        delete lock[id];
                    else
                        delete node[ns];
                    return 1;
                }
            }, 0, time);
        }
    }
    d3.svg.axis = function () {
        var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [10], tickValues = null, tickFormat_;
        function axis(g) {
            g.each(function () {
                var g = d3.select(this);
                var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();
                var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll('.tick').data(ticks, scale1), tickEnter = tick.enter().insert('g', '.domain').attr('class', 'tick').style('opacity', ), tickExit = d3.transition(tick.exit()).style('opacity', ).remove(), tickUpdate = d3.transition(tick.order()).style('opacity', 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;
                var range = d3_scaleRange(scale1), path = g.selectAll('.domain').data([0]), pathUpdate = (path.enter().append('path').attr('class', 'domain'), d3.transition(path));
                tickEnter.append('line');
                tickEnter.append('text');
                var lineEnter = tickEnter.select('line'), lineUpdate = tickUpdate.select('line'), text = tick.select('text').text(tickFormat), textEnter = tickEnter.select('text'), textUpdate = tickUpdate.select('text'), sign = orient === 'top' || orient === 'left' ? -1 : 1, x1, x2, y1, y2;
                if (orient === 'bottom' || orient === 'top') {
                    tickTransform = d3_svg_axisX, x1 = 'x', y1 = 'y', x2 = 'x2', y2 = 'y2';
                    text.attr('dy', sign < 0 ? '0em' : '.71em').style('text-anchor', 'middle');
                    pathUpdate.attr('d', 'M' + range[0] + ',' + sign * outerTickSize + 'V0H' + range[1] + 'V' + sign * outerTickSize);
                } else {
                    tickTransform = d3_svg_axisY, x1 = 'y', y1 = 'x', x2 = 'y2', y2 = 'x2';
                    text.attr('dy', '.32em').style('text-anchor', sign < 0 ? 'end' : 'start');
                    pathUpdate.attr('d', 'M' + sign * outerTickSize + ',' + range[0] + 'H0V' + range[1] + 'H' + sign * outerTickSize);
                }
                lineEnter.attr(y2, sign * innerTickSize);
                textEnter.attr(y1, sign * tickSpacing);
                lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
                textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
                if (scale1.rangeBand) {
                    var x = scale1, dx = x.rangeBand() / 2;
                    scale0 = scale1 = function (d) {
                        return x(d) + dx;
                    };
                } else if (scale0.rangeBand) {
                    scale0 = scale1;
                } else {
                    tickExit.call(tickTransform, scale1, scale0);
                }
                tickEnter.call(tickTransform, scale0, scale1);
                tickUpdate.call(tickTransform, scale1, scale1);
            });
        }
        axis.scale = function (x) {
            if (!arguments.length)
                return scale;
            scale = x;
            return axis;
        };
        axis.orient = function (x) {
            if (!arguments.length)
                return orient;
            orient = x in d3_svg_axisOrients ? x + '' : d3_svg_axisDefaultOrient;
            return axis;
        };
        axis.ticks = function () {
            if (!arguments.length)
                return tickArguments_;
            tickArguments_ = arguments;
            return axis;
        };
        axis.tickValues = function (x) {
            if (!arguments.length)
                return tickValues;
            tickValues = x;
            return axis;
        };
        axis.tickFormat = function (x) {
            if (!arguments.length)
                return tickFormat_;
            tickFormat_ = x;
            return axis;
        };
        axis.tickSize = function (x) {
            var n = arguments.length;
            if (!n)
                return innerTickSize;
            innerTickSize = +x;
            outerTickSize = +arguments[n - 1];
            return axis;
        };
        axis.innerTickSize = function (x) {
            if (!arguments.length)
                return innerTickSize;
            innerTickSize = +x;
            return axis;
        };
        axis.outerTickSize = function (x) {
            if (!arguments.length)
                return outerTickSize;
            outerTickSize = +x;
            return axis;
        };
        axis.tickPadding = function (x) {
            if (!arguments.length)
                return tickPadding;
            tickPadding = +x;
            return axis;
        };
        axis.tickSubdivide = function () {
            return arguments.length && axis;
        };
        return axis;
    };
    var d3_svg_axisDefaultOrient = 'bottom', d3_svg_axisOrients = {
            top: 1,
            right: 1,
            bottom: 1,
            left: 1
        };
    function d3_svg_axisX(selection, x0, x1) {
        selection.attr('transform', function (d) {
            var v0 = x0(d);
            return 'translate(' + (isFinite(v0) ? v0 : x1(d)) + ',0)';
        });
    }
    function d3_svg_axisY(selection, y0, y1) {
        selection.attr('transform', function (d) {
            var v0 = y0(d);
            return 'translate(0,' + (isFinite(v0) ? v0 : y1(d)) + ')';
        });
    }
    d3.svg.brush = function () {
        var event = d3_eventDispatch(brush, 'brushstart', 'brush', 'brushend'), x = null, y = null, xExtent = [
                0,
                0
            ], yExtent = [
                0,
                0
            ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
        function brush(g) {
            g.each(function () {
                var g = d3.select(this).style('pointer-events', 'all').style('-webkit-tap-highlight-color', 'rgba(0,0,0,0)').on('mousedown.brush', brushstart).on('touchstart.brush', brushstart);
                var background = g.selectAll('.background').data([0]);
                background.enter().append('rect').attr('class', 'background').style('visibility', 'hidden').style('cursor', 'crosshair');
                g.selectAll('.extent').data([0]).enter().append('rect').attr('class', 'extent').style('cursor', 'move');
                var resize = g.selectAll('.resize').data(resizes, d3_identity);
                resize.exit().remove();
                resize.enter().append('g').attr('class', function (d) {
                    return 'resize ' + d;
                }).style('cursor', function (d) {
                    return d3_svg_brushCursor[d];
                }).append('rect').attr('x', function (d) {
                    return /[ew]$/.test(d) ? -3 : null;
                }).attr('y', function (d) {
                    return /^[ns]/.test(d) ? -3 : null;
                }).attr('width', 6).attr('height', 6).style('visibility', 'hidden');
                resize.style('display', brush.empty() ? 'none' : null);
                var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;
                if (x) {
                    range = d3_scaleRange(x);
                    backgroundUpdate.attr('x', range[0]).attr('width', range[1] - range[0]);
                    redrawX(gUpdate);
                }
                if (y) {
                    range = d3_scaleRange(y);
                    backgroundUpdate.attr('y', range[0]).attr('height', range[1] - range[0]);
                    redrawY(gUpdate);
                }
                redraw(gUpdate);
            });
        }
        brush.event = function (g) {
            g.each(function () {
                var event_ = event.of(this, arguments), extent1 = {
                        x: xExtent,
                        y: yExtent,
                        i: xExtentDomain,
                        j: yExtentDomain
                    }, extent0 = this.__chart__ || extent1;
                this.__chart__ = extent1;
                if (d3_transitionInheritId) {
                    d3.select(this).transition().each('start.brush', function () {
                        xExtentDomain = extent0.i;
                        yExtentDomain = extent0.j;
                        xExtent = extent0.x;
                        yExtent = extent0.y;
                        event_({ type: 'brushstart' });
                    }).tween('brush:brush', function () {
                        var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
                        xExtentDomain = yExtentDomain = null;
                        return function (t) {
                            xExtent = extent1.x = xi(t);
                            yExtent = extent1.y = yi(t);
                            event_({
                                type: 'brush',
                                mode: 'resize'
                            });
                        };
                    }).each('end.brush', function () {
                        xExtentDomain = extent1.i;
                        yExtentDomain = extent1.j;
                        event_({
                            type: 'brush',
                            mode: 'resize'
                        });
                        event_({ type: 'brushend' });
                    });
                } else {
                    event_({ type: 'brushstart' });
                    event_({
                        type: 'brush',
                        mode: 'resize'
                    });
                    event_({ type: 'brushend' });
                }
            });
        };
        function redraw(g) {
            g.selectAll('.resize').attr('transform', function (d) {
                return 'translate(' + xExtent[+/e$/.test(d)] + ',' + yExtent[+/^s/.test(d)] + ')';
            });
        }
        function redrawX(g) {
            g.select('.extent').attr('x', xExtent[0]);
            g.selectAll('.extent,.n>rect,.s>rect').attr('width', xExtent[1] - xExtent[0]);
        }
        function redrawY(g) {
            g.select('.extent').attr('y', yExtent[0]);
            g.selectAll('.extent,.e>rect,.w>rect').attr('height', yExtent[1] - yExtent[0]);
        }
        function brushstart() {
            var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed('extent'), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset;
            var w = d3.select(d3_window(target)).on('keydown.brush', keydown).on('keyup.brush', keyup);
            if (d3.event.changedTouches) {
                w.on('touchmove.brush', brushmove).on('touchend.brush', brushend);
            } else {
                w.on('mousemove.brush', brushmove).on('mouseup.brush', brushend);
            }
            g.interrupt().selectAll('*').interrupt();
            if (dragging) {
                origin[0] = xExtent[0] - origin[0];
                origin[1] = yExtent[0] - origin[1];
            } else if (resizing) {
                var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
                offset = [
                    xExtent[1 - ex] - origin[0],
                    yExtent[1 - ey] - origin[1]
                ];
                origin[0] = xExtent[ex];
                origin[1] = yExtent[ey];
            } else if (d3.event.altKey)
                center = origin.slice();
            g.style('pointer-events', 'none').selectAll('.resize').style('display', null);
            d3.select('body').style('cursor', eventTarget.style('cursor'));
            event_({ type: 'brushstart' });
            brushmove();
            function keydown() {
                if (d3.event.keyCode == 32) {
                    if (!dragging) {
                        center = null;
                        origin[0] -= xExtent[1];
                        origin[1] -= yExtent[1];
                        dragging = 2;
                    }
                    d3_eventPreventDefault();
                }
            }
            function keyup() {
                if (d3.event.keyCode == 32 && dragging == 2) {
                    origin[0] += xExtent[1];
                    origin[1] += yExtent[1];
                    dragging = 0;
                    d3_eventPreventDefault();
                }
            }
            function brushmove() {
                var point = d3.mouse(target), moved = false;
                if (offset) {
                    point[0] += offset[0];
                    point[1] += offset[1];
                }
                if (!dragging) {
                    if (d3.event.altKey) {
                        if (!center)
                            center = [
                                (xExtent[0] + xExtent[1]) / 2,
                                (yExtent[0] + yExtent[1]) / 2
                            ];
                        origin[0] = xExtent[+(point[0] < center[0])];
                        origin[1] = yExtent[+(point[1] < center[1])];
                    } else
                        center = null;
                }
                if (resizingX && move1(point, x, 0)) {
                    redrawX(g);
                    moved = true;
                }
                if (resizingY && move1(point, y, 1)) {
                    redrawY(g);
                    moved = true;
                }
                if (moved) {
                    redraw(g);
                    event_({
                        type: 'brush',
                        mode: dragging ? 'move' : 'resize'
                    });
                }
            }
            function move1(point, scale, i) {
                var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;
                if (dragging) {
                    r0 -= position;
                    r1 -= size + position;
                }
                min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
                if (dragging) {
                    max = (min += position) + size;
                } else {
                    if (center)
                        position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
                    if (position < min) {
                        max = min;
                        min = position;
                    } else {
                        max = position;
                    }
                }
                if (extent[0] != min || extent[1] != max) {
                    if (i)
                        yExtentDomain = null;
                    else
                        xExtentDomain = null;
                    extent[0] = min;
                    extent[1] = max;
                    return true;
                }
            }
            function brushend() {
                brushmove();
                g.style('pointer-events', 'all').selectAll('.resize').style('display', brush.empty() ? 'none' : null);
                d3.select('body').style('cursor', null);
                w.on('mousemove.brush', null).on('mouseup.brush', null).on('touchmove.brush', null).on('touchend.brush', null).on('keydown.brush', null).on('keyup.brush', null);
                dragRestore();
                event_({ type: 'brushend' });
            }
        }
        brush.x = function (z) {
            if (!arguments.length)
                return x;
            x = z;
            resizes = d3_svg_brushResizes[!x << 1 | !y];
            return brush;
        };
        brush.y = function (z) {
            if (!arguments.length)
                return y;
            y = z;
            resizes = d3_svg_brushResizes[!x << 1 | !y];
            return brush;
        };
        brush.clamp = function (z) {
            if (!arguments.length)
                return x && y ? [
                    xClamp,
                    yClamp
                ] : x ? xClamp : y ? yClamp : null;
            if (x && y)
                xClamp = !!z[0], yClamp = !!z[1];
            else if (x)
                xClamp = !!z;
            else if (y)
                yClamp = !!z;
            return brush;
        };
        brush.extent = function (z) {
            var x0, x1, y0, y1, t;
            if (!arguments.length) {
                if (x) {
                    if (xExtentDomain) {
                        x0 = xExtentDomain[0], x1 = xExtentDomain[1];
                    } else {
                        x0 = xExtent[0], x1 = xExtent[1];
                        if (x.invert)
                            x0 = x.invert(x0), x1 = x.invert(x1);
                        if (x1 < x0)
                            t = x0, x0 = x1, x1 = t;
                    }
                }
                if (y) {
                    if (yExtentDomain) {
                        y0 = yExtentDomain[0], y1 = yExtentDomain[1];
                    } else {
                        y0 = yExtent[0], y1 = yExtent[1];
                        if (y.invert)
                            y0 = y.invert(y0), y1 = y.invert(y1);
                        if (y1 < y0)
                            t = y0, y0 = y1, y1 = t;
                    }
                }
                return x && y ? [
                    [
                        x0,
                        y0
                    ],
                    [
                        x1,
                        y1
                    ]
                ] : x ? [
                    x0,
                    x1
                ] : y && [
                    y0,
                    y1
                ];
            }
            if (x) {
                x0 = z[0], x1 = z[1];
                if (y)
                    x0 = x0[0], x1 = x1[0];
                xExtentDomain = [
                    x0,
                    x1
                ];
                if (x.invert)
                    x0 = x(x0), x1 = x(x1);
                if (x1 < x0)
                    t = x0, x0 = x1, x1 = t;
                if (x0 != xExtent[0] || x1 != xExtent[1])
                    xExtent = [
                        x0,
                        x1
                    ];
            }
            if (y) {
                y0 = z[0], y1 = z[1];
                if (x)
                    y0 = y0[1], y1 = y1[1];
                yExtentDomain = [
                    y0,
                    y1
                ];
                if (y.invert)
                    y0 = y(y0), y1 = y(y1);
                if (y1 < y0)
                    t = y0, y0 = y1, y1 = t;
                if (y0 != yExtent[0] || y1 != yExtent[1])
                    yExtent = [
                        y0,
                        y1
                    ];
            }
            return brush;
        };
        brush.clear = function () {
            if (!brush.empty()) {
                xExtent = [
                    0,
                    0
                ], yExtent = [
                    0,
                    0
                ];
                xExtentDomain = yExtentDomain = null;
            }
            return brush;
        };
        brush.empty = function () {
            return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
        };
        return d3.rebind(brush, event, 'on');
    };
    var d3_svg_brushCursor = {
        n: 'ns-resize',
        e: 'ew-resize',
        s: 'ns-resize',
        w: 'ew-resize',
        nw: 'nwse-resize',
        ne: 'nesw-resize',
        se: 'nwse-resize',
        sw: 'nesw-resize'
    };
    var d3_svg_brushResizes = [
        [
            'n',
            'e',
            's',
            'w',
            'nw',
            'ne',
            'se',
            'sw'
        ],
        [
            'e',
            'w'
        ],
        [
            'n',
            's'
        ],
        []
    ];
    var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;
    var d3_time_formatUtc = d3_time_format.utc;
    var d3_time_formatIso = d3_time_formatUtc('%Y-%m-%dT%H:%M:%S.%LZ');
    d3_time_format.iso = Date.prototype.toISOString && +new Date('2000-01-01T00:00:00.000Z') ? d3_time_formatIsoNative : d3_time_formatIso;
    function d3_time_formatIsoNative(date) {
        return date.toISOString();
    }
    d3_time_formatIsoNative.parse = function (string) {
        var date = new Date(string);
        return isNaN(date) ? null : date;
    };
    d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
    d3_time.second = d3_time_interval(function (date) {
        return new d3_date(Math.floor(date / 1000) * 1000);
    }, function (date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 1000);
    }, function (date) {
        return date.getSeconds();
    });
    d3_time.seconds = d3_time.second.range;
    d3_time.seconds.utc = d3_time.second.utc.range;
    d3_time.minute = d3_time_interval(function (date) {
        return new d3_date(Math.floor(date / 60000) * 60000);
    }, function (date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 60000);
    }, function (date) {
        return date.getMinutes();
    });
    d3_time.minutes = d3_time.minute.range;
    d3_time.minutes.utc = d3_time.minute.utc.range;
    d3_time.hour = d3_time_interval(function (date) {
        var timezone = date.getTimezoneOffset() / 60;
        return new d3_date((Math.floor(date / 3600000 - timezone) + timezone) * 3600000);
    }, function (date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 3600000);
    }, function (date) {
        return date.getHours();
    });
    d3_time.hours = d3_time.hour.range;
    d3_time.hours.utc = d3_time.hour.utc.range;
    d3_time.month = d3_time_interval(function (date) {
        date = d3_time.day(date);
        date.setDate(1);
        return date;
    }, function (date, offset) {
        date.setMonth(date.getMonth() + offset);
    }, function (date) {
        return date.getMonth();
    });
    d3_time.months = d3_time.month.range;
    d3_time.months.utc = d3_time.month.utc.range;
    function d3_time_scale(linear, methods, format) {
        function scale(x) {
            return linear(x);
        }
        scale.invert = function (x) {
            return d3_time_scaleDate(linear.invert(x));
        };
        scale.domain = function (x) {
            if (!arguments.length)
                return linear.domain().map(d3_time_scaleDate);
            linear.domain(x);
            return scale;
        };
        function tickMethod(extent, count) {
            var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);
            return i == d3_time_scaleSteps.length ? [
                methods.year,
                d3_scale_linearTickRange(extent.map(function (d) {
                    return d / 31536000000;
                }), count)[2]
            ] : !i ? [
                d3_time_scaleMilliseconds,
                d3_scale_linearTickRange(extent, count)[2]
            ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
        }
        scale.nice = function (interval, skip) {
            var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === 'number' && tickMethod(extent, interval);
            if (method)
                interval = method[0], skip = method[1];
            function skipped(date) {
                return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
            }
            return scale.domain(d3_scale_nice(domain, skip > 1 ? {
                floor: function (date) {
                    while (skipped(date = interval.floor(date)))
                        date = d3_time_scaleDate(date - 1);
                    return date;
                },
                ceil: function (date) {
                    while (skipped(date = interval.ceil(date)))
                        date = d3_time_scaleDate(+date + 1);
                    return date;
                }
            } : interval));
        };
        scale.ticks = function (interval, skip) {
            var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === 'number' ? tickMethod(extent, interval) : !interval.range && [
                    { range: interval },
                    skip
                ];
            if (method)
                interval = method[0], skip = method[1];
            return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
        };
        scale.tickFormat = function () {
            return format;
        };
        scale.copy = function () {
            return d3_time_scale(linear.copy(), methods, format);
        };
        return d3_scale_linearRebind(scale, linear);
    }
    function d3_time_scaleDate(t) {
        return new Date(t);
    }
    var d3_time_scaleSteps = [
        1000,
        5000,
        15000,
        30000,
        60000,
        300000,
        900000,
        1800000,
        3600000,
        10800000,
        21600000,
        43200000,
        86400000,
        172800000,
        604800000,
        2592000000,
        7776000000,
        31536000000
    ];
    var d3_time_scaleLocalMethods = [
        [
            d3_time.second,
            1
        ],
        [
            d3_time.second,
            5
        ],
        [
            d3_time.second,
            15
        ],
        [
            d3_time.second,
            30
        ],
        [
            d3_time.minute,
            1
        ],
        [
            d3_time.minute,
            5
        ],
        [
            d3_time.minute,
            15
        ],
        [
            d3_time.minute,
            30
        ],
        [
            d3_time.hour,
            1
        ],
        [
            d3_time.hour,
            3
        ],
        [
            d3_time.hour,
            6
        ],
        [
            d3_time.hour,
            12
        ],
        [
            d3_time.day,
            1
        ],
        [
            d3_time.day,
            2
        ],
        [
            d3_time.week,
            1
        ],
        [
            d3_time.month,
            1
        ],
        [
            d3_time.month,
            3
        ],
        [
            d3_time.year,
            1
        ]
    ];
    var d3_time_scaleLocalFormat = d3_time_format.multi([
        [
            '.%L',
            function (d) {
                return d.getMilliseconds();
            }
        ],
        [
            ':%S',
            function (d) {
                return d.getSeconds();
            }
        ],
        [
            '%I:%M',
            function (d) {
                return d.getMinutes();
            }
        ],
        [
            '%I %p',
            function (d) {
                return d.getHours();
            }
        ],
        [
            '%a %d',
            function (d) {
                return d.getDay() && d.getDate() != 1;
            }
        ],
        [
            '%b %d',
            function (d) {
                return d.getDate() != 1;
            }
        ],
        [
            '%B',
            function (d) {
                return d.getMonth();
            }
        ],
        [
            '%Y',
            d3_true
        ]
    ]);
    var d3_time_scaleMilliseconds = {
        range: function (start, stop, step) {
            return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);
        },
        floor: d3_identity,
        ceil: d3_identity
    };
    d3_time_scaleLocalMethods.year = d3_time.year;
    d3_time.scale = function () {
        return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
    };
    var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function (m) {
        return [
            m[0].utc,
            m[1]
        ];
    });
    var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([
        [
            '.%L',
            function (d) {
                return d.getUTCMilliseconds();
            }
        ],
        [
            ':%S',
            function (d) {
                return d.getUTCSeconds();
            }
        ],
        [
            '%I:%M',
            function (d) {
                return d.getUTCMinutes();
            }
        ],
        [
            '%I %p',
            function (d) {
                return d.getUTCHours();
            }
        ],
        [
            '%a %d',
            function (d) {
                return d.getUTCDay() && d.getUTCDate() != 1;
            }
        ],
        [
            '%b %d',
            function (d) {
                return d.getUTCDate() != 1;
            }
        ],
        [
            '%B',
            function (d) {
                return d.getUTCMonth();
            }
        ],
        [
            '%Y',
            d3_true
        ]
    ]);
    d3_time_scaleUtcMethods.year = d3_time.year.utc;
    d3_time.scale.utc = function () {
        return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
    };
    d3.text = d3_xhrType(function (request) {
        return request.responseText;
    });
    d3.json = function (url, callback) {
        return d3_xhr(url, 'application/json', d3_json, callback);
    };
    function d3_json(request) {
        return JSON.parse(request.responseText);
    }
    d3.html = function (url, callback) {
        return d3_xhr(url, 'text/html', d3_html, callback);
    };
    function d3_html(request) {
        var range = d3_document.createRange();
        range.selectNode(d3_document.body);
        return range.createContextualFragment(request.responseText);
    }
    d3.xml = d3_xhrType(function (request) {
        return request.responseXML;
    });
    if (typeof define === 'function' && define.amd)
        define('d3', [], d3);
    else if (typeof module === 'object' && module.exports)
        module.exports = d3;
    this.d3 = d3;
}();
define('chiasm/src/plugins/reactivis', [
    'model',
    'd3'
], function (Model, d3) {
    var reactivis = {};
    var None = Model.None;
    function addPublicProperty(model, property, defaultValue) {
        if (!model.publicProperties) {
            model.publicProperties = [];
        }
        model.publicProperties.push(property);
        model[property] = defaultValue;
    }
    reactivis.svg = function (model) {
        model.when('container', function (container) {
            model.svg = d3.select(container).append('svg').style('position', 'relative');
        });
        model.when([
            'svg',
            'box'
        ], function (svg, box) {
            svg.style('left', box.x + 'px').style('top', box.y + 'px').attr('width', box.width).attr('height', box.height);
        });
        model.when('svg', function (svg) {
            model.g = svg.append('g');
        });
    };
    reactivis.margin = function (model) {
        addPublicProperty(model, 'margin', {
            'top': 32,
            'right': 2,
            'bottom': 40,
            'left': 47
        });
        model.when([
            'box',
            'margin'
        ], function (box, margin) {
            model.width = box.width - margin.left - margin.right;
            model.height = box.height - margin.top - margin.bottom;
        });
        model.when([
            'g',
            'margin'
        ], function (g, margin) {
            g.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
        });
        addPublicProperty(model, 'size', 1);
    };
    reactivis.title = function (model) {
        addPublicProperty(model, 'title', '');
        addPublicProperty(model, 'titleOffset', -0.3);
        model.when('g', function (g) {
            model.titleText = g.append('text').attr('class', 'title-text');
        });
        model.when([
            'titleText',
            'width'
        ], function (titleText, width) {
            titleText.attr('x', width / 2);
        });
        model.when([
            'titleText',
            'title'
        ], function (titleText, title) {
            titleText.text(title);
        });
        model.titleOffset = 1;
        model.when([
            'titleText',
            'titleOffset'
        ], function (titleText, titleOffset) {
            titleText.attr('dy', titleOffset + 'em');
        });
    };
    reactivis.color = function (model) {
        addPublicProperty(model, 'colorColumn', None);
        addPublicProperty(model, 'colorDomain', None);
        addPublicProperty(model, 'colorRange', None);
        addPublicProperty(model, 'colorDefault', 'black');
        model.when([
            'colorDefault',
            'colorDomain',
            'colorRange'
        ], function (colorDefault, colorDomain, colorRange) {
            if (colorDomain !== None && colorRange !== None) {
                model.colorScale = d3.scale.ordinal().domain(colorDomain).range(colorRange);
            } else {
                model.colorScale = None;
            }
        });
        model.when([
            'colorColumn',
            'colorScale',
            'colorDefault'
        ], function (colorColumn, colorScale, colorDefault) {
            if (colorColumn !== None && colorScale !== None) {
                model.color = function (d) {
                    return colorScale(d[colorColumn]);
                };
            } else {
                model.color = colorDefault;
            }
        });
    };
    reactivis.xAccessor = function (model) {
        addPublicProperty(model, 'xColumn', None);
        model.when(['xColumn'], function (xColumn) {
            if (xColumn !== None) {
                model.xAccessor = function (d) {
                    return d[xColumn];
                };
            }
        });
    };
    reactivis.yAccessor = function (model) {
        addPublicProperty(model, 'yColumn', None);
        model.when(['yColumn'], function (yColumn) {
            if (yColumn !== None) {
                model.yAccessor = function (d) {
                    return d[yColumn];
                };
            }
        });
    };
    var scaleConstructors = {
        linear: d3.scale.linear,
        time: d3.time.scale,
        ordinalBands: d3.scale.ordinal
    };
    reactivis.xScale = function (model, scaleType) {
        addPublicProperty(model, 'xScaleType', scaleType);
        addPublicProperty(model, 'xDomainMin', None);
        addPublicProperty(model, 'xDomainMax', None);
        addPublicProperty(model, 'xRangePadding', 0.1);
        model.when([
            'data',
            'xScaleType',
            'xAccessor',
            'xDomainMin',
            'xDomainMax'
        ], function (data, xScaleType, xAccessor, xDomainMin, xDomainMax) {
            if (xScaleType === 'linear' || xScaleType === 'time') {
                if (xDomainMin === None && xDomainMax === None) {
                    model.xDomain = d3.extent(data, xAccessor);
                } else {
                    if (xDomainMin === None) {
                        xDomainMin = d3.min(data, xAccessor);
                    }
                    if (xDomainMax === None) {
                        xDomainMax = d3.max(data, xAccessor);
                    }
                    model.xDomain = [
                        xDomainMin,
                        xDomainMax
                    ];
                }
            } else if (xScaleType === 'ordinalBands') {
                model.xDomain = data.map(xAccessor);
            }
        });
        model.when([
            'xScaleType',
            'xDomain',
            'width',
            'xRangePadding'
        ], function (xScaleType, xDomain, width, xRangePadding) {
            var scale = scaleConstructors[xScaleType]().domain(xDomain);
            if (xScaleType === 'ordinalBands') {
                scale.rangeRoundBands([
                    0,
                    width
                ], xRangePadding);
            } else {
                scale.range([
                    0,
                    width
                ]);
            }
            model.xScale = scale;
        });
        model.when([
            'data',
            'xScale',
            'xAccessor'
        ], function (data, xScale, xAccessor) {
            model.x = function (d) {
                return xScale(xAccessor(d));
            };
        });
    };
    reactivis.xAxis = function (model) {
        addPublicProperty(model, 'xAxisLabel', '');
        addPublicProperty(model, 'xAxisLabelOffset', 1.9);
        model.when('g', function (g) {
            model.xAxisG = g.append('g').attr('class', 'x axis');
            model.xAxisText = model.xAxisG.append('text').style('text-anchor', 'middle');
        });
        model.when([
            'xAxisText',
            'xAxisLabelOffset'
        ], function (xAxisText, xAxisLabelOffset) {
            xAxisText.attr('dy', xAxisLabelOffset + 'em');
        });
        model.when([
            'xAxisG',
            'height'
        ], function (xAxisG, height) {
            xAxisG.attr('transform', 'translate(0,' + height + ')');
        });
        model.when([
            'xAxisText',
            'width'
        ], function (xAxisText, width) {
            xAxisText.attr('x', width / 2);
        });
        model.when([
            'xAxisG',
            'xScale'
        ], function (xAxisG, xScale) {
            xAxisG.call(d3.svg.axis().orient('bottom').scale(xScale));
        });
        model.when([
            'xAxisText',
            'xAxisLabel'
        ], function (xAxisText, xAxisLabel) {
            xAxisText.text(xAxisLabel);
        });
    };
    reactivis.yAxis = function (model) {
        addPublicProperty(model, 'yAxisLabel', '');
        addPublicProperty(model, 'yAxisLabelOffset', 1.4);
        model.when('g', function (g) {
            model.yAxisG = g.append('g').attr('class', 'y axis');
            model.yAxisText = model.yAxisG.append('text').style('text-anchor', 'middle').attr('transform', 'rotate(-90)').attr('y', 0);
        });
        model.when([
            'yAxisText',
            'yAxisLabelOffset'
        ], function (yAxisText, yAxisLabelOffset) {
            yAxisText.attr('dy', '-' + yAxisLabelOffset + 'em');
        });
        model.when([
            'yAxisText',
            'height'
        ], function (yAxisText, height) {
            yAxisText.attr('x', -height / 2);
        });
        model.when([
            'yAxisText',
            'yAxisLabel'
        ], function (yAxisText, yAxisLabel) {
            yAxisText.text(yAxisLabel);
        });
        model.when([
            'yAxisG',
            'yScale'
        ], function (yAxisG, yScale) {
            yAxisG.call(d3.svg.axis().orient('left').scale(yScale));
        });
    };
    reactivis.addPublicProperty = addPublicProperty;
    return reactivis;
});
define('chiasm/src/plugins/barChart', [
    'chiasm/src/plugins/reactivis',
    'd3',
    'model',
    'lodash'
], function (reactivis, d3, Model, _) {
    var None = Model.None;
    return function BarChart(chiasm) {
        var model = Model();
        model.container = chiasm.container;
        reactivis.svg(model);
        reactivis.title(model);
        reactivis.margin(model);
        reactivis.xAccessor(model);
        reactivis.xScale(model, 'ordinalBands');
        reactivis.xAxis(model);
        reactivis.yAccessor(model);
        reactivis.yAxis(model);
        reactivis.color(model);
        model.publicProperties.push('yDomainMin');
        model.publicProperties.push('yDomainMax');
        model.yDomainMin = None;
        model.yDomainMax = None;
        model.when([
            'data',
            'yAccessor',
            'yDomainMin',
            'yDomainMax'
        ], function (data, yAccessor, yDomainMin, yDomainMax) {
            model.yDomain = [
                yDomainMin === None ? d3.min(data, yAccessor) : yDomainMin,
                yDomainMax === None ? d3.max(data, yAccessor) : yDomainMax
            ];
        });
        model.when([
            'data',
            'yDomain',
            'height'
        ], function (data, yDomain, height) {
            model.yScale = d3.scale.linear().domain(yDomain).range([
                height,
                0
            ]);
        });
        model.when([
            'yScale',
            'yAccessor'
        ], function (yScale, yAccessor) {
            model.y = function (d) {
                return yScale(yAccessor(d));
            };
        });
        model.when('g', function (g) {
            model.barsG = g.append('g');
        });
        model.when([
            'barsG',
            'data',
            'x',
            'y',
            'xScale',
            'height',
            'color',
            'xAccessor'
        ], function (barsG, data, x, y, xScale, height, color, xAccessor) {
            var bars = barsG.selectAll('rect').data(data, xAccessor);
            bars.enter().append('rect');
            bars.attr('x', x).attr('y', y).attr('width', xScale.rangeBand()).attr('height', function (d) {
                return height - y(d);
            }).attr('fill', color);
            bars.exit().remove();
        });
        model.destroy = function () {
            if (model.container && model.svg) {
                model.svg.node().innerHTML = '';
                model.container.removeChild(model.svg.node());
            }
        };
        return model;
    };
});
define('chiasm/src/plugins/colorScale', ['model'], function (Model) {
    return function () {
        return Model({
            publicProperties: [
                'colorDomain',
                'colorRange'
            ]
        });
    };
});
define('chiasm/src/plugins/computeLayout', ['lodash'], function (_) {
    return function computeLayout(layout, sizes, box) {
        var result = {}, isHorizontal, wiggleRoom, sizeSum = 0, x, y, visibleChildren;
        box.x = box.x || 0;
        box.y = box.y || 0;
        sizes = sizes || {};
        function size(layout) {
            var result, alias;
            if (isLeafNode(layout)) {
                alias = layout;
                if (alias in sizes && 'size' in sizes[alias]) {
                    result = sizes[alias].size;
                } else {
                    result = 1;
                }
            } else {
                result = layout.size || 1;
            }
            if (typeof result === 'string' && !isPixelCount(result)) {
                result = parseFloat(result);
            }
            return result;
        }
        function isVisible(layout) {
            if (isLeafNode(layout) && layout in sizes) {
                return !sizes[layout].hidden;
            } else {
                return true;
            }
        }
        if (isLeafNode(layout)) {
            result[layout] = _.clone(box);
        } else {
            isHorizontal = layout.orientation === 'horizontal';
            wiggleRoom = isHorizontal ? box.width : box.height;
            visibleChildren = layout.children.filter(isVisible);
            visibleChildren.forEach(function (child) {
                if (isPixelCount(size(child))) {
                    wiggleRoom -= pixelCount(size(child));
                } else {
                    sizeSum += size(child);
                }
            });
            x = box.x;
            y = box.y;
            visibleChildren.forEach(function (child) {
                var childBox = {
                        x: x,
                        y: y
                    }, childSize = size(child), sizeInPixels;
                if (isPixelCount(childSize)) {
                    sizeInPixels = pixelCount(childSize);
                } else {
                    sizeInPixels = childSize / sizeSum * wiggleRoom;
                }
                if (isHorizontal) {
                    childBox.width = sizeInPixels;
                    childBox.height = box.height;
                    x += childBox.width;
                } else {
                    childBox.width = box.width;
                    childBox.height = sizeInPixels;
                    y += childBox.height;
                }
                quantize(childBox);
                if (isLeafNode(child)) {
                    result[child] = childBox;
                } else {
                    _.extend(result, computeLayout(child, sizes, childBox));
                }
            });
        }
        return result;
    };
    function isLeafNode(layout) {
        return typeof layout === 'string';
    }
    function isPixelCount(size) {
        return typeof size === 'string' && endsWith(size, 'px');
    }
    function endsWith(str, suffix) {
        return str.indexOf(suffix, str.length - suffix.length) !== -1;
    }
    function pixelCount(size) {
        return parseInt(size.substr(0, size.length - 2));
    }
    function quantize(box) {
        var x = Math.round(box.x), y = Math.round(box.y);
        box.width = Math.round(box.width + box.x - x);
        box.height = Math.round(box.height + box.y - y);
        box.x = x;
        box.y = y;
    }
});
(function (mod) {
    if (typeof exports == 'object' && typeof module == 'object')
        module.exports = mod();
    else if (typeof define == 'function' && define.amd)
        return define('bower_components/codemirror/lib/codemirror', [], mod);
    else
        this.CodeMirror = mod();
}(function () {
    'use strict';
    var gecko = /gecko\/\d/i.test(navigator.userAgent);
    var ie_upto10 = /MSIE \d/.test(navigator.userAgent);
    var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
    var ie = ie_upto10 || ie_11up;
    var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1]);
    var webkit = /WebKit\//.test(navigator.userAgent);
    var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(navigator.userAgent);
    var chrome = /Chrome\//.test(navigator.userAgent);
    var presto = /Opera\//.test(navigator.userAgent);
    var safari = /Apple Computer/.test(navigator.vendor);
    var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(navigator.userAgent);
    var phantom = /PhantomJS/.test(navigator.userAgent);
    var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\/\w+/.test(navigator.userAgent);
    var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent);
    var mac = ios || /Mac/.test(navigator.platform);
    var windows = /win/i.test(navigator.platform);
    var presto_version = presto && navigator.userAgent.match(/Version\/(\d*\.\d*)/);
    if (presto_version)
        presto_version = Number(presto_version[1]);
    if (presto_version && presto_version >= 15) {
        presto = false;
        webkit = true;
    }
    var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
    var captureRightClick = gecko || ie && ie_version >= 9;
    var sawReadOnlySpans = false, sawCollapsedSpans = false;
    function CodeMirror(place, options) {
        if (!(this instanceof CodeMirror))
            return new CodeMirror(place, options);
        this.options = options = options ? copyObj(options) : {};
        copyObj(defaults, options, false);
        setGuttersForLineNumbers(options);
        var doc = options.value;
        if (typeof doc == 'string')
            doc = new Doc(doc, options.mode);
        this.doc = doc;
        var input = new CodeMirror.inputStyles[options.inputStyle](this);
        var display = this.display = new Display(place, doc, input);
        display.wrapper.CodeMirror = this;
        updateGutters(this);
        themeChanged(this);
        if (options.lineWrapping)
            this.display.wrapper.className += ' CodeMirror-wrap';
        if (options.autofocus && !mobile)
            display.input.focus();
        initScrollbars(this);
        this.state = {
            keyMaps: [],
            overlays: [],
            modeGen: 0,
            overwrite: false,
            delayingBlurEvent: false,
            focused: false,
            suppressEdits: false,
            pasteIncoming: false,
            cutIncoming: false,
            draggingText: false,
            highlight: new Delayed(),
            keySeq: null,
            specialChars: null
        };
        var cm = this;
        if (ie && ie_version < 11)
            setTimeout(function () {
                cm.display.input.reset(true);
            }, 20);
        registerEventHandlers(this);
        ensureGlobalHandlers();
        startOperation(this);
        this.curOp.forceUpdate = true;
        attachDoc(this, doc);
        if (options.autofocus && !mobile || cm.hasFocus())
            setTimeout(bind(onFocus, this), 20);
        else
            onBlur(this);
        for (var opt in optionHandlers)
            if (optionHandlers.hasOwnProperty(opt))
                optionHandlers[opt](this, options[opt], Init);
        maybeUpdateLineNumberWidth(this);
        if (options.finishInit)
            options.finishInit(this);
        for (var i = 0; i < initHooks.length; ++i)
            initHooks[i](this);
        endOperation(this);
        if (webkit && options.lineWrapping && getComputedStyle(display.lineDiv).textRendering == 'optimizelegibility')
            display.lineDiv.style.textRendering = 'auto';
    }
    function Display(place, doc, input) {
        var d = this;
        this.input = input;
        d.scrollbarFiller = elt('div', null, 'CodeMirror-scrollbar-filler');
        d.scrollbarFiller.setAttribute('cm-not-content', 'true');
        d.gutterFiller = elt('div', null, 'CodeMirror-gutter-filler');
        d.gutterFiller.setAttribute('cm-not-content', 'true');
        d.lineDiv = elt('div', null, 'CodeMirror-code');
        d.selectionDiv = elt('div', null, null, 'position: relative; z-index: 1');
        d.cursorDiv = elt('div', null, 'CodeMirror-cursors');
        d.measure = elt('div', null, 'CodeMirror-measure');
        d.lineMeasure = elt('div', null, 'CodeMirror-measure');
        d.lineSpace = elt('div', [
            d.measure,
            d.lineMeasure,
            d.selectionDiv,
            d.cursorDiv,
            d.lineDiv
        ], null, 'position: relative; outline: none');
        d.mover = elt('div', [elt('div', [d.lineSpace], 'CodeMirror-lines')], null, 'position: relative');
        d.sizer = elt('div', [d.mover], 'CodeMirror-sizer');
        d.sizerWidth = null;
        d.heightForcer = elt('div', null, null, 'position: absolute; height: ' + scrollerGap + 'px; width: 1px;');
        d.gutters = elt('div', null, 'CodeMirror-gutters');
        d.lineGutter = null;
        d.scroller = elt('div', [
            d.sizer,
            d.heightForcer,
            d.gutters
        ], 'CodeMirror-scroll');
        d.scroller.setAttribute('tabIndex', '-1');
        d.wrapper = elt('div', [
            d.scrollbarFiller,
            d.gutterFiller,
            d.scroller
        ], 'CodeMirror');
        if (ie && ie_version < 8) {
            d.gutters.style.zIndex = -1;
            d.scroller.style.paddingRight = 0;
        }
        if (!webkit && !(gecko && mobile))
            d.scroller.draggable = true;
        if (place) {
            if (place.appendChild)
                place.appendChild(d.wrapper);
            else
                place(d.wrapper);
        }
        d.viewFrom = d.viewTo = doc.first;
        d.reportedViewFrom = d.reportedViewTo = doc.first;
        d.view = [];
        d.renderedView = null;
        d.externalMeasured = null;
        d.viewOffset = 0;
        d.lastWrapHeight = d.lastWrapWidth = 0;
        d.updateLineNumbers = null;
        d.nativeBarWidth = d.barHeight = d.barWidth = 0;
        d.scrollbarsClipped = false;
        d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
        d.alignWidgets = false;
        d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
        d.maxLine = null;
        d.maxLineLength = 0;
        d.maxLineChanged = false;
        d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;
        d.shift = false;
        d.selForContextMenu = null;
        d.activeTouch = null;
        input.init(d);
    }
    function loadMode(cm) {
        cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);
        resetModeState(cm);
    }
    function resetModeState(cm) {
        cm.doc.iter(function (line) {
            if (line.stateAfter)
                line.stateAfter = null;
            if (line.styles)
                line.styles = null;
        });
        cm.doc.frontier = cm.doc.first;
        startWorker(cm, 100);
        cm.state.modeGen++;
        if (cm.curOp)
            regChange(cm);
    }
    function wrappingChanged(cm) {
        if (cm.options.lineWrapping) {
            addClass(cm.display.wrapper, 'CodeMirror-wrap');
            cm.display.sizer.style.minWidth = '';
            cm.display.sizerWidth = null;
        } else {
            rmClass(cm.display.wrapper, 'CodeMirror-wrap');
            findMaxLine(cm);
        }
        estimateLineHeights(cm);
        regChange(cm);
        clearCaches(cm);
        setTimeout(function () {
            updateScrollbars(cm);
        }, 100);
    }
    function estimateHeight(cm) {
        var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
        var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
        return function (line) {
            if (lineIsHidden(cm.doc, line))
                return 0;
            var widgetsHeight = 0;
            if (line.widgets)
                for (var i = 0; i < line.widgets.length; i++) {
                    if (line.widgets[i].height)
                        widgetsHeight += line.widgets[i].height;
                }
            if (wrapping)
                return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
            else
                return widgetsHeight + th;
        };
    }
    function estimateLineHeights(cm) {
        var doc = cm.doc, est = estimateHeight(cm);
        doc.iter(function (line) {
            var estHeight = est(line);
            if (estHeight != line.height)
                updateLineHeight(line, estHeight);
        });
    }
    function themeChanged(cm) {
        cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, '') + cm.options.theme.replace(/(^|\s)\s*/g, ' cm-s-');
        clearCaches(cm);
    }
    function guttersChanged(cm) {
        updateGutters(cm);
        regChange(cm);
        setTimeout(function () {
            alignHorizontally(cm);
        }, 20);
    }
    function updateGutters(cm) {
        var gutters = cm.display.gutters, specs = cm.options.gutters;
        removeChildren(gutters);
        for (var i = 0; i < specs.length; ++i) {
            var gutterClass = specs[i];
            var gElt = gutters.appendChild(elt('div', null, 'CodeMirror-gutter ' + gutterClass));
            if (gutterClass == 'CodeMirror-linenumbers') {
                cm.display.lineGutter = gElt;
                gElt.style.width = (cm.display.lineNumWidth || 1) + 'px';
            }
        }
        gutters.style.display = i ? '' : 'none';
        updateGutterSpace(cm);
    }
    function updateGutterSpace(cm) {
        var width = cm.display.gutters.offsetWidth;
        cm.display.sizer.style.marginLeft = width + 'px';
    }
    function lineLength(line) {
        if (line.height == 0)
            return 0;
        var len = line.text.length, merged, cur = line;
        while (merged = collapsedSpanAtStart(cur)) {
            var found = merged.find(0, true);
            cur = found.from.line;
            len += found.from.ch - found.to.ch;
        }
        cur = line;
        while (merged = collapsedSpanAtEnd(cur)) {
            var found = merged.find(0, true);
            len -= cur.text.length - found.from.ch;
            cur = found.to.line;
            len += cur.text.length - found.to.ch;
        }
        return len;
    }
    function findMaxLine(cm) {
        var d = cm.display, doc = cm.doc;
        d.maxLine = getLine(doc, doc.first);
        d.maxLineLength = lineLength(d.maxLine);
        d.maxLineChanged = true;
        doc.iter(function (line) {
            var len = lineLength(line);
            if (len > d.maxLineLength) {
                d.maxLineLength = len;
                d.maxLine = line;
            }
        });
    }
    function setGuttersForLineNumbers(options) {
        var found = indexOf(options.gutters, 'CodeMirror-linenumbers');
        if (found == -1 && options.lineNumbers) {
            options.gutters = options.gutters.concat(['CodeMirror-linenumbers']);
        } else if (found > -1 && !options.lineNumbers) {
            options.gutters = options.gutters.slice(0);
            options.gutters.splice(found, 1);
        }
    }
    function measureForScrollbars(cm) {
        var d = cm.display, gutterW = d.gutters.offsetWidth;
        var docH = Math.round(cm.doc.height + paddingVert(cm.display));
        return {
            clientHeight: d.scroller.clientHeight,
            viewHeight: d.wrapper.clientHeight,
            scrollWidth: d.scroller.scrollWidth,
            clientWidth: d.scroller.clientWidth,
            viewWidth: d.wrapper.clientWidth,
            barLeft: cm.options.fixedGutter ? gutterW : 0,
            docHeight: docH,
            scrollHeight: docH + scrollGap(cm) + d.barHeight,
            nativeBarWidth: d.nativeBarWidth,
            gutterWidth: gutterW
        };
    }
    function NativeScrollbars(place, scroll, cm) {
        this.cm = cm;
        var vert = this.vert = elt('div', [elt('div', null, null, 'min-width: 1px')], 'CodeMirror-vscrollbar');
        var horiz = this.horiz = elt('div', [elt('div', null, null, 'height: 100%; min-height: 1px')], 'CodeMirror-hscrollbar');
        place(vert);
        place(horiz);
        on(vert, 'scroll', function () {
            if (vert.clientHeight)
                scroll(vert.scrollTop, 'vertical');
        });
        on(horiz, 'scroll', function () {
            if (horiz.clientWidth)
                scroll(horiz.scrollLeft, 'horizontal');
        });
        this.checkedOverlay = false;
        if (ie && ie_version < 8)
            this.horiz.style.minHeight = this.vert.style.minWidth = '18px';
    }
    NativeScrollbars.prototype = copyObj({
        update: function (measure) {
            var needsH = measure.scrollWidth > measure.clientWidth + 1;
            var needsV = measure.scrollHeight > measure.clientHeight + 1;
            var sWidth = measure.nativeBarWidth;
            if (needsV) {
                this.vert.style.display = 'block';
                this.vert.style.bottom = needsH ? sWidth + 'px' : '0';
                var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
                this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + 'px';
            } else {
                this.vert.style.display = '';
                this.vert.firstChild.style.height = '0';
            }
            if (needsH) {
                this.horiz.style.display = 'block';
                this.horiz.style.right = needsV ? sWidth + 'px' : '0';
                this.horiz.style.left = measure.barLeft + 'px';
                var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
                this.horiz.firstChild.style.width = measure.scrollWidth - measure.clientWidth + totalWidth + 'px';
            } else {
                this.horiz.style.display = '';
                this.horiz.firstChild.style.width = '0';
            }
            if (!this.checkedOverlay && measure.clientHeight > 0) {
                if (sWidth == 0)
                    this.overlayHack();
                this.checkedOverlay = true;
            }
            return {
                right: needsV ? sWidth : 0,
                bottom: needsH ? sWidth : 0
            };
        },
        setScrollLeft: function (pos) {
            if (this.horiz.scrollLeft != pos)
                this.horiz.scrollLeft = pos;
        },
        setScrollTop: function (pos) {
            if (this.vert.scrollTop != pos)
                this.vert.scrollTop = pos;
        },
        overlayHack: function () {
            var w = mac && !mac_geMountainLion ? '12px' : '18px';
            this.horiz.style.minHeight = this.vert.style.minWidth = w;
            var self = this;
            var barMouseDown = function (e) {
                if (e_target(e) != self.vert && e_target(e) != self.horiz)
                    operation(self.cm, onMouseDown)(e);
            };
            on(this.vert, 'mousedown', barMouseDown);
            on(this.horiz, 'mousedown', barMouseDown);
        },
        clear: function () {
            var parent = this.horiz.parentNode;
            parent.removeChild(this.horiz);
            parent.removeChild(this.vert);
        }
    }, NativeScrollbars.prototype);
    function NullScrollbars() {
    }
    NullScrollbars.prototype = copyObj({
        update: function () {
            return {
                bottom: 0,
                right: 0
            };
        },
        setScrollLeft: function () {
        },
        setScrollTop: function () {
        },
        clear: function () {
        }
    }, NullScrollbars.prototype);
    CodeMirror.scrollbarModel = {
        'native': NativeScrollbars,
        'null': NullScrollbars
    };
    function initScrollbars(cm) {
        if (cm.display.scrollbars) {
            cm.display.scrollbars.clear();
            if (cm.display.scrollbars.addClass)
                rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
        }
        cm.display.scrollbars = new CodeMirror.scrollbarModel[cm.options.scrollbarStyle](function (node) {
            cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
            on(node, 'mousedown', function () {
                if (cm.state.focused)
                    setTimeout(function () {
                        cm.display.input.focus();
                    }, 0);
            });
            node.setAttribute('cm-not-content', 'true');
        }, function (pos, axis) {
            if (axis == 'horizontal')
                setScrollLeft(cm, pos);
            else
                setScrollTop(cm, pos);
        }, cm);
        if (cm.display.scrollbars.addClass)
            addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
    }
    function updateScrollbars(cm, measure) {
        if (!measure)
            measure = measureForScrollbars(cm);
        var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
        updateScrollbarsInner(cm, measure);
        for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
            if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
                updateHeightsInViewport(cm);
            updateScrollbarsInner(cm, measureForScrollbars(cm));
            startWidth = cm.display.barWidth;
            startHeight = cm.display.barHeight;
        }
    }
    function updateScrollbarsInner(cm, measure) {
        var d = cm.display;
        var sizes = d.scrollbars.update(measure);
        d.sizer.style.paddingRight = (d.barWidth = sizes.right) + 'px';
        d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + 'px';
        if (sizes.right && sizes.bottom) {
            d.scrollbarFiller.style.display = 'block';
            d.scrollbarFiller.style.height = sizes.bottom + 'px';
            d.scrollbarFiller.style.width = sizes.right + 'px';
        } else
            d.scrollbarFiller.style.display = '';
        if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
            d.gutterFiller.style.display = 'block';
            d.gutterFiller.style.height = sizes.bottom + 'px';
            d.gutterFiller.style.width = measure.gutterWidth + 'px';
        } else
            d.gutterFiller.style.display = '';
    }
    function visibleLines(display, doc, viewport) {
        var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
        top = Math.floor(top - paddingTop(display));
        var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;
        var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
        if (viewport && viewport.ensure) {
            var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
            if (ensureFrom < from) {
                from = ensureFrom;
                to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
            } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
                from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
                to = ensureTo;
            }
        }
        return {
            from: from,
            to: Math.max(to, from + 1)
        };
    }
    function alignHorizontally(cm) {
        var display = cm.display, view = display.view;
        if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter))
            return;
        var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
        var gutterW = display.gutters.offsetWidth, left = comp + 'px';
        for (var i = 0; i < view.length; i++)
            if (!view[i].hidden) {
                if (cm.options.fixedGutter && view[i].gutter)
                    view[i].gutter.style.left = left;
                var align = view[i].alignable;
                if (align)
                    for (var j = 0; j < align.length; j++)
                        align[j].style.left = left;
            }
        if (cm.options.fixedGutter)
            display.gutters.style.left = comp + gutterW + 'px';
    }
    function maybeUpdateLineNumberWidth(cm) {
        if (!cm.options.lineNumbers)
            return false;
        var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
        if (last.length != display.lineNumChars) {
            var test = display.measure.appendChild(elt('div', [elt('div', last)], 'CodeMirror-linenumber CodeMirror-gutter-elt'));
            var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
            display.lineGutter.style.width = '';
            display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
            display.lineNumWidth = display.lineNumInnerWidth + padding;
            display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
            display.lineGutter.style.width = display.lineNumWidth + 'px';
            updateGutterSpace(cm);
            return true;
        }
        return false;
    }
    function lineNumberFor(options, i) {
        return String(options.lineNumberFormatter(i + options.firstLineNumber));
    }
    function compensateForHScroll(display) {
        return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
    }
    function DisplayUpdate(cm, viewport, force) {
        var display = cm.display;
        this.viewport = viewport;
        this.visible = visibleLines(display, cm.doc, viewport);
        this.editorIsHidden = !display.wrapper.offsetWidth;
        this.wrapperHeight = display.wrapper.clientHeight;
        this.wrapperWidth = display.wrapper.clientWidth;
        this.oldDisplayWidth = displayWidth(cm);
        this.force = force;
        this.dims = getDimensions(cm);
        this.events = [];
    }
    DisplayUpdate.prototype.signal = function (emitter, type) {
        if (hasHandler(emitter, type))
            this.events.push(arguments);
    };
    DisplayUpdate.prototype.finish = function () {
        for (var i = 0; i < this.events.length; i++)
            signal.apply(null, this.events[i]);
    };
    function maybeClipScrollbars(cm) {
        var display = cm.display;
        if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
            display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
            display.heightForcer.style.height = scrollGap(cm) + 'px';
            display.sizer.style.marginBottom = -display.nativeBarWidth + 'px';
            display.sizer.style.borderRightWidth = scrollGap(cm) + 'px';
            display.scrollbarsClipped = true;
        }
    }
    function updateDisplayIfNeeded(cm, update) {
        var display = cm.display, doc = cm.doc;
        if (update.editorIsHidden) {
            resetView(cm);
            return false;
        }
        if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && countDirtyView(cm) == 0)
            return false;
        if (maybeUpdateLineNumberWidth(cm)) {
            resetView(cm);
            update.dims = getDimensions(cm);
        }
        var end = doc.first + doc.size;
        var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
        var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
        if (display.viewFrom < from && from - display.viewFrom < 20)
            from = Math.max(doc.first, display.viewFrom);
        if (display.viewTo > to && display.viewTo - to < 20)
            to = Math.min(end, display.viewTo);
        if (sawCollapsedSpans) {
            from = visualLineNo(cm.doc, from);
            to = visualLineEndNo(cm.doc, to);
        }
        var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
        adjustView(cm, from, to);
        display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
        cm.display.mover.style.top = display.viewOffset + 'px';
        var toUpdate = countDirtyView(cm);
        if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
            return false;
        var focused = activeElt();
        if (toUpdate > 4)
            display.lineDiv.style.display = 'none';
        patchDisplay(cm, display.updateLineNumbers, update.dims);
        if (toUpdate > 4)
            display.lineDiv.style.display = '';
        display.renderedView = display.view;
        if (focused && activeElt() != focused && focused.offsetHeight)
            focused.focus();
        removeChildren(display.cursorDiv);
        removeChildren(display.selectionDiv);
        display.gutters.style.height = 0;
        if (different) {
            display.lastWrapHeight = update.wrapperHeight;
            display.lastWrapWidth = update.wrapperWidth;
            startWorker(cm, 400);
        }
        display.updateLineNumbers = null;
        return true;
    }
    function postUpdateDisplay(cm, update) {
        var force = update.force, viewport = update.viewport;
        for (var first = true;; first = false) {
            if (first && cm.options.lineWrapping && update.oldDisplayWidth != displayWidth(cm)) {
                force = true;
            } else {
                force = false;
                if (viewport && viewport.top != null)
                    viewport = { top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top) };
                update.visible = visibleLines(cm.display, cm.doc, viewport);
                if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
                    break;
            }
            if (!updateDisplayIfNeeded(cm, update))
                break;
            updateHeightsInViewport(cm);
            var barMeasure = measureForScrollbars(cm);
            updateSelection(cm);
            setDocumentHeight(cm, barMeasure);
            updateScrollbars(cm, barMeasure);
        }
        update.signal(cm, 'update', cm);
        if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
            update.signal(cm, 'viewportChange', cm, cm.display.viewFrom, cm.display.viewTo);
            cm.display.reportedViewFrom = cm.display.viewFrom;
            cm.display.reportedViewTo = cm.display.viewTo;
        }
    }
    function updateDisplaySimple(cm, viewport) {
        var update = new DisplayUpdate(cm, viewport);
        if (updateDisplayIfNeeded(cm, update)) {
            updateHeightsInViewport(cm);
            postUpdateDisplay(cm, update);
            var barMeasure = measureForScrollbars(cm);
            updateSelection(cm);
            setDocumentHeight(cm, barMeasure);
            updateScrollbars(cm, barMeasure);
            update.finish();
        }
    }
    function setDocumentHeight(cm, measure) {
        cm.display.sizer.style.minHeight = measure.docHeight + 'px';
        var total = measure.docHeight + cm.display.barHeight;
        cm.display.heightForcer.style.top = total + 'px';
        cm.display.gutters.style.height = Math.max(total + scrollGap(cm), measure.clientHeight) + 'px';
    }
    function updateHeightsInViewport(cm) {
        var display = cm.display;
        var prevBottom = display.lineDiv.offsetTop;
        for (var i = 0; i < display.view.length; i++) {
            var cur = display.view[i], height;
            if (cur.hidden)
                continue;
            if (ie && ie_version < 8) {
                var bot = cur.node.offsetTop + cur.node.offsetHeight;
                height = bot - prevBottom;
                prevBottom = bot;
            } else {
                var box = cur.node.getBoundingClientRect();
                height = box.bottom - box.top;
            }
            var diff = cur.line.height - height;
            if (height < 2)
                height = textHeight(display);
            if (diff > 0.001 || diff < -0.001) {
                updateLineHeight(cur.line, height);
                updateWidgetHeight(cur.line);
                if (cur.rest)
                    for (var j = 0; j < cur.rest.length; j++)
                        updateWidgetHeight(cur.rest[j]);
            }
        }
    }
    function updateWidgetHeight(line) {
        if (line.widgets)
            for (var i = 0; i < line.widgets.length; ++i)
                line.widgets[i].height = line.widgets[i].node.offsetHeight;
    }
    function getDimensions(cm) {
        var d = cm.display, left = {}, width = {};
        var gutterLeft = d.gutters.clientLeft;
        for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
            left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;
            width[cm.options.gutters[i]] = n.clientWidth;
        }
        return {
            fixedPos: compensateForHScroll(d),
            gutterTotalWidth: d.gutters.offsetWidth,
            gutterLeft: left,
            gutterWidth: width,
            wrapperWidth: d.wrapper.clientWidth
        };
    }
    function patchDisplay(cm, updateNumbersFrom, dims) {
        var display = cm.display, lineNumbers = cm.options.lineNumbers;
        var container = display.lineDiv, cur = container.firstChild;
        function rm(node) {
            var next = node.nextSibling;
            if (webkit && mac && cm.display.currentWheelTarget == node)
                node.style.display = 'none';
            else
                node.parentNode.removeChild(node);
            return next;
        }
        var view = display.view, lineN = display.viewFrom;
        for (var i = 0; i < view.length; i++) {
            var lineView = view[i];
            if (lineView.hidden) {
            } else if (!lineView.node || lineView.node.parentNode != container) {
                var node = buildLineElement(cm, lineView, lineN, dims);
                container.insertBefore(node, cur);
            } else {
                while (cur != lineView.node)
                    cur = rm(cur);
                var updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;
                if (lineView.changes) {
                    if (indexOf(lineView.changes, 'gutter') > -1)
                        updateNumber = false;
                    updateLineForChanges(cm, lineView, lineN, dims);
                }
                if (updateNumber) {
                    removeChildren(lineView.lineNumber);
                    lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
                }
                cur = lineView.node.nextSibling;
            }
            lineN += lineView.size;
        }
        while (cur)
            cur = rm(cur);
    }
    function updateLineForChanges(cm, lineView, lineN, dims) {
        for (var j = 0; j < lineView.changes.length; j++) {
            var type = lineView.changes[j];
            if (type == 'text')
                updateLineText(cm, lineView);
            else if (type == 'gutter')
                updateLineGutter(cm, lineView, lineN, dims);
            else if (type == 'class')
                updateLineClasses(lineView);
            else if (type == 'widget')
                updateLineWidgets(cm, lineView, dims);
        }
        lineView.changes = null;
    }
    function ensureLineWrapped(lineView) {
        if (lineView.node == lineView.text) {
            lineView.node = elt('div', null, null, 'position: relative');
            if (lineView.text.parentNode)
                lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
            lineView.node.appendChild(lineView.text);
            if (ie && ie_version < 8)
                lineView.node.style.zIndex = 2;
        }
        return lineView.node;
    }
    function updateLineBackground(lineView) {
        var cls = lineView.bgClass ? lineView.bgClass + ' ' + (lineView.line.bgClass || '') : lineView.line.bgClass;
        if (cls)
            cls += ' CodeMirror-linebackground';
        if (lineView.background) {
            if (cls)
                lineView.background.className = cls;
            else {
                lineView.background.parentNode.removeChild(lineView.background);
                lineView.background = null;
            }
        } else if (cls) {
            var wrap = ensureLineWrapped(lineView);
            lineView.background = wrap.insertBefore(elt('div', null, cls), wrap.firstChild);
        }
    }
    function getLineContent(cm, lineView) {
        var ext = cm.display.externalMeasured;
        if (ext && ext.line == lineView.line) {
            cm.display.externalMeasured = null;
            lineView.measure = ext.measure;
            return ext.built;
        }
        return buildLineContent(cm, lineView);
    }
    function updateLineText(cm, lineView) {
        var cls = lineView.text.className;
        var built = getLineContent(cm, lineView);
        if (lineView.text == lineView.node)
            lineView.node = built.pre;
        lineView.text.parentNode.replaceChild(built.pre, lineView.text);
        lineView.text = built.pre;
        if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
            lineView.bgClass = built.bgClass;
            lineView.textClass = built.textClass;
            updateLineClasses(lineView);
        } else if (cls) {
            lineView.text.className = cls;
        }
    }
    function updateLineClasses(lineView) {
        updateLineBackground(lineView);
        if (lineView.line.wrapClass)
            ensureLineWrapped(lineView).className = lineView.line.wrapClass;
        else if (lineView.node != lineView.text)
            lineView.node.className = '';
        var textClass = lineView.textClass ? lineView.textClass + ' ' + (lineView.line.textClass || '') : lineView.line.textClass;
        lineView.text.className = textClass || '';
    }
    function updateLineGutter(cm, lineView, lineN, dims) {
        if (lineView.gutter) {
            lineView.node.removeChild(lineView.gutter);
            lineView.gutter = null;
        }
        var markers = lineView.line.gutterMarkers;
        if (cm.options.lineNumbers || markers) {
            var wrap = ensureLineWrapped(lineView);
            var gutterWrap = lineView.gutter = elt('div', null, 'CodeMirror-gutter-wrapper', 'left: ' + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + 'px; width: ' + dims.gutterTotalWidth + 'px');
            cm.display.input.setUneditable(gutterWrap);
            wrap.insertBefore(gutterWrap, lineView.text);
            if (lineView.line.gutterClass)
                gutterWrap.className += ' ' + lineView.line.gutterClass;
            if (cm.options.lineNumbers && (!markers || !markers['CodeMirror-linenumbers']))
                lineView.lineNumber = gutterWrap.appendChild(elt('div', lineNumberFor(cm.options, lineN), 'CodeMirror-linenumber CodeMirror-gutter-elt', 'left: ' + dims.gutterLeft['CodeMirror-linenumbers'] + 'px; width: ' + cm.display.lineNumInnerWidth + 'px'));
            if (markers)
                for (var k = 0; k < cm.options.gutters.length; ++k) {
                    var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];
                    if (found)
                        gutterWrap.appendChild(elt('div', [found], 'CodeMirror-gutter-elt', 'left: ' + dims.gutterLeft[id] + 'px; width: ' + dims.gutterWidth[id] + 'px'));
                }
        }
    }
    function updateLineWidgets(cm, lineView, dims) {
        if (lineView.alignable)
            lineView.alignable = null;
        for (var node = lineView.node.firstChild, next; node; node = next) {
            var next = node.nextSibling;
            if (node.className == 'CodeMirror-linewidget')
                lineView.node.removeChild(node);
        }
        insertLineWidgets(cm, lineView, dims);
    }
    function buildLineElement(cm, lineView, lineN, dims) {
        var built = getLineContent(cm, lineView);
        lineView.text = lineView.node = built.pre;
        if (built.bgClass)
            lineView.bgClass = built.bgClass;
        if (built.textClass)
            lineView.textClass = built.textClass;
        updateLineClasses(lineView);
        updateLineGutter(cm, lineView, lineN, dims);
        insertLineWidgets(cm, lineView, dims);
        return lineView.node;
    }
    function insertLineWidgets(cm, lineView, dims) {
        insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
        if (lineView.rest)
            for (var i = 0; i < lineView.rest.length; i++)
                insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);
    }
    function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
        if (!line.widgets)
            return;
        var wrap = ensureLineWrapped(lineView);
        for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
            var widget = ws[i], node = elt('div', [widget.node], 'CodeMirror-linewidget');
            if (!widget.handleMouseEvents)
                node.setAttribute('cm-ignore-events', 'true');
            positionLineWidget(widget, node, lineView, dims);
            cm.display.input.setUneditable(node);
            if (allowAbove && widget.above)
                wrap.insertBefore(node, lineView.gutter || lineView.text);
            else
                wrap.appendChild(node);
            signalLater(widget, 'redraw');
        }
    }
    function positionLineWidget(widget, node, lineView, dims) {
        if (widget.noHScroll) {
            (lineView.alignable || (lineView.alignable = [])).push(node);
            var width = dims.wrapperWidth;
            node.style.left = dims.fixedPos + 'px';
            if (!widget.coverGutter) {
                width -= dims.gutterTotalWidth;
                node.style.paddingLeft = dims.gutterTotalWidth + 'px';
            }
            node.style.width = width + 'px';
        }
        if (widget.coverGutter) {
            node.style.zIndex = 5;
            node.style.position = 'relative';
            if (!widget.noHScroll)
                node.style.marginLeft = -dims.gutterTotalWidth + 'px';
        }
    }
    var Pos = CodeMirror.Pos = function (line, ch) {
        if (!(this instanceof Pos))
            return new Pos(line, ch);
        this.line = line;
        this.ch = ch;
    };
    var cmp = CodeMirror.cmpPos = function (a, b) {
        return a.line - b.line || a.ch - b.ch;
    };
    function copyPos(x) {
        return Pos(x.line, x.ch);
    }
    function maxPos(a, b) {
        return cmp(a, b) < 0 ? b : a;
    }
    function minPos(a, b) {
        return cmp(a, b) < 0 ? a : b;
    }
    function ensureFocus(cm) {
        if (!cm.state.focused) {
            cm.display.input.focus();
            onFocus(cm);
        }
    }
    function isReadOnly(cm) {
        return cm.options.readOnly || cm.doc.cantEdit;
    }
    var lastCopied = null;
    function applyTextInput(cm, inserted, deleted, sel, origin) {
        var doc = cm.doc;
        cm.display.shift = false;
        if (!sel)
            sel = doc.sel;
        var textLines = splitLines(inserted), multiPaste = null;
        if (cm.state.pasteIncoming && sel.ranges.length > 1) {
            if (lastCopied && lastCopied.join('\n') == inserted)
                multiPaste = sel.ranges.length % lastCopied.length == 0 && map(lastCopied, splitLines);
            else if (textLines.length == sel.ranges.length)
                multiPaste = map(textLines, function (l) {
                    return [l];
                });
        }
        for (var i = sel.ranges.length - 1; i >= 0; i--) {
            var range = sel.ranges[i];
            var from = range.from(), to = range.to();
            if (range.empty()) {
                if (deleted && deleted > 0)
                    from = Pos(from.line, from.ch - deleted);
                else if (cm.state.overwrite && !cm.state.pasteIncoming)
                    to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));
            }
            var updateInput = cm.curOp.updateInput;
            var changeEvent = {
                from: from,
                to: to,
                text: multiPaste ? multiPaste[i % multiPaste.length] : textLines,
                origin: origin || (cm.state.pasteIncoming ? 'paste' : cm.state.cutIncoming ? 'cut' : '+input')
            };
            makeChange(cm.doc, changeEvent);
            signalLater(cm, 'inputRead', cm, changeEvent);
            if (inserted && !cm.state.pasteIncoming && cm.options.electricChars && cm.options.smartIndent && range.head.ch < 100 && (!i || sel.ranges[i - 1].head.line != range.head.line)) {
                var mode = cm.getModeAt(range.head);
                var end = changeEnd(changeEvent);
                var indented = false;
                if (mode.electricChars) {
                    for (var j = 0; j < mode.electricChars.length; j++)
                        if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
                            indented = indentLine(cm, end.line, 'smart');
                            break;
                        }
                } else if (mode.electricInput) {
                    if (mode.electricInput.test(getLine(doc, end.line).text.slice(0, end.ch)))
                        indented = indentLine(cm, end.line, 'smart');
                }
                if (indented)
                    signalLater(cm, 'electricInput', cm, end.line);
            }
        }
        ensureCursorVisible(cm);
        cm.curOp.updateInput = updateInput;
        cm.curOp.typing = true;
        cm.state.pasteIncoming = cm.state.cutIncoming = false;
    }
    function copyableRanges(cm) {
        var text = [], ranges = [];
        for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
            var line = cm.doc.sel.ranges[i].head.line;
            var lineRange = {
                anchor: Pos(line, 0),
                head: Pos(line + 1, 0)
            };
            ranges.push(lineRange);
            text.push(cm.getRange(lineRange.anchor, lineRange.head));
        }
        return {
            text: text,
            ranges: ranges
        };
    }
    function disableBrowserMagic(field) {
        field.setAttribute('autocorrect', 'off');
        field.setAttribute('autocapitalize', 'off');
        field.setAttribute('spellcheck', 'false');
    }
    function TextareaInput(cm) {
        this.cm = cm;
        this.prevInput = '';
        this.pollingFast = false;
        this.polling = new Delayed();
        this.inaccurateSelection = false;
        this.hasSelection = false;
        this.composing = null;
    }
    ;
    function hiddenTextarea() {
        var te = elt('textarea', null, null, 'position: absolute; padding: 0; width: 1px; height: 1em; outline: none');
        var div = elt('div', [te], null, 'overflow: hidden; position: relative; width: 3px; height: 0px;');
        if (webkit)
            te.style.width = '1000px';
        else
            te.setAttribute('wrap', 'off');
        if (ios)
            te.style.border = '1px solid black';
        disableBrowserMagic(te);
        return div;
    }
    TextareaInput.prototype = copyObj({
        init: function (display) {
            var input = this, cm = this.cm;
            var div = this.wrapper = hiddenTextarea();
            var te = this.textarea = div.firstChild;
            display.wrapper.insertBefore(div, display.wrapper.firstChild);
            if (ios)
                te.style.width = '0px';
            on(te, 'input', function () {
                if (ie && ie_version >= 9 && input.hasSelection)
                    input.hasSelection = null;
                input.poll();
            });
            on(te, 'paste', function () {
                if (webkit && !cm.state.fakedLastChar && !(new Date() - cm.state.lastMiddleDown < 200)) {
                    var start = te.selectionStart, end = te.selectionEnd;
                    te.value += '$';
                    te.selectionEnd = end;
                    te.selectionStart = start;
                    cm.state.fakedLastChar = true;
                }
                cm.state.pasteIncoming = true;
                input.fastPoll();
            });
            function prepareCopyCut(e) {
                if (cm.somethingSelected()) {
                    lastCopied = cm.getSelections();
                    if (input.inaccurateSelection) {
                        input.prevInput = '';
                        input.inaccurateSelection = false;
                        te.value = lastCopied.join('\n');
                        selectInput(te);
                    }
                } else if (!cm.options.lineWiseCopyCut) {
                    return;
                } else {
                    var ranges = copyableRanges(cm);
                    lastCopied = ranges.text;
                    if (e.type == 'cut') {
                        cm.setSelections(ranges.ranges, null, sel_dontScroll);
                    } else {
                        input.prevInput = '';
                        te.value = ranges.text.join('\n');
                        selectInput(te);
                    }
                }
                if (e.type == 'cut')
                    cm.state.cutIncoming = true;
            }
            on(te, 'cut', prepareCopyCut);
            on(te, 'copy', prepareCopyCut);
            on(display.scroller, 'paste', function (e) {
                if (eventInWidget(display, e))
                    return;
                cm.state.pasteIncoming = true;
                input.focus();
            });
            on(display.lineSpace, 'selectstart', function (e) {
                if (!eventInWidget(display, e))
                    e_preventDefault(e);
            });
            on(te, 'compositionstart', function () {
                var start = cm.getCursor('from');
                input.composing = {
                    start: start,
                    range: cm.markText(start, cm.getCursor('to'), { className: 'CodeMirror-composing' })
                };
            });
            on(te, 'compositionend', function () {
                if (input.composing) {
                    input.poll();
                    input.composing.range.clear();
                    input.composing = null;
                }
            });
        },
        prepareSelection: function () {
            var cm = this.cm, display = cm.display, doc = cm.doc;
            var result = prepareSelection(cm);
            if (cm.options.moveInputWithCursor) {
                var headPos = cursorCoords(cm, doc.sel.primary().head, 'div');
                var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
                result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top));
                result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left));
            }
            return result;
        },
        showSelection: function (drawn) {
            var cm = this.cm, display = cm.display;
            removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
            removeChildrenAndAdd(display.selectionDiv, drawn.selection);
            if (drawn.teTop != null) {
                this.wrapper.style.top = drawn.teTop + 'px';
                this.wrapper.style.left = drawn.teLeft + 'px';
            }
        },
        reset: function (typing) {
            if (this.contextMenuPending)
                return;
            var minimal, selected, cm = this.cm, doc = cm.doc;
            if (cm.somethingSelected()) {
                this.prevInput = '';
                var range = doc.sel.primary();
                minimal = hasCopyEvent && (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000);
                var content = minimal ? '-' : selected || cm.getSelection();
                this.textarea.value = content;
                if (cm.state.focused)
                    selectInput(this.textarea);
                if (ie && ie_version >= 9)
                    this.hasSelection = content;
            } else if (!typing) {
                this.prevInput = this.textarea.value = '';
                if (ie && ie_version >= 9)
                    this.hasSelection = null;
            }
            this.inaccurateSelection = minimal;
        },
        getField: function () {
            return this.textarea;
        },
        supportsTouch: function () {
            return false;
        },
        focus: function () {
            if (this.cm.options.readOnly != 'nocursor' && (!mobile || activeElt() != this.textarea)) {
                try {
                    this.textarea.focus();
                } catch (e) {
                }
            }
        },
        blur: function () {
            this.textarea.blur();
        },
        resetPosition: function () {
            this.wrapper.style.top = this.wrapper.style.left = 0;
        },
        receivedFocus: function () {
            this.slowPoll();
        },
        slowPoll: function () {
            var input = this;
            if (input.pollingFast)
                return;
            input.polling.set(this.cm.options.pollInterval, function () {
                input.poll();
                if (input.cm.state.focused)
                    input.slowPoll();
            });
        },
        fastPoll: function () {
            var missed = false, input = this;
            input.pollingFast = true;
            function p() {
                var changed = input.poll();
                if (!changed && !missed) {
                    missed = true;
                    input.polling.set(60, p);
                } else {
                    input.pollingFast = false;
                    input.slowPoll();
                }
            }
            input.polling.set(20, p);
        },
        poll: function () {
            var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
            if (!cm.state.focused || hasSelection(input) && !prevInput || isReadOnly(cm) || cm.options.disableInput || cm.state.keySeq)
                return false;
            if (cm.state.pasteIncoming && cm.state.fakedLastChar) {
                input.value = input.value.substring(0, input.value.length - 1);
                cm.state.fakedLastChar = false;
            }
            var text = input.value;
            if (text == prevInput && !cm.somethingSelected())
                return false;
            if (ie && ie_version >= 9 && this.hasSelection === text || mac && /[\uf700-\uf7ff]/.test(text)) {
                cm.display.input.reset();
                return false;
            }
            if (cm.doc.sel == cm.display.selForContextMenu) {
                var first = text.charCodeAt(0);
                if (first == 8203 && !prevInput)
                    prevInput = '\u200B';
                if (first == 8666) {
                    this.reset();
                    return this.cm.execCommand('undo');
                }
            }
            var same = 0, l = Math.min(prevInput.length, text.length);
            while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same))
                ++same;
            var self = this;
            runInOp(cm, function () {
                applyTextInput(cm, text.slice(same), prevInput.length - same, null, self.composing ? '*compose' : null);
                if (text.length > 1000 || text.indexOf('\n') > -1)
                    input.value = self.prevInput = '';
                else
                    self.prevInput = text;
                if (self.composing) {
                    self.composing.range.clear();
                    self.composing.range = cm.markText(self.composing.start, cm.getCursor('to'), { className: 'CodeMirror-composing' });
                }
            });
            return true;
        },
        ensurePolled: function () {
            if (this.pollingFast && this.poll())
                this.pollingFast = false;
        },
        onKeyPress: function () {
            if (ie && ie_version >= 9)
                this.hasSelection = null;
            this.fastPoll();
        },
        onContextMenu: function (e) {
            var input = this, cm = input.cm, display = cm.display, te = input.textarea;
            var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
            if (!pos || presto)
                return;
            var reset = cm.options.resetSelectionOnContextMenu;
            if (reset && cm.doc.sel.contains(pos) == -1)
                operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);
            var oldCSS = te.style.cssText;
            input.wrapper.style.position = 'absolute';
            te.style.cssText = 'position: fixed; width: 30px; height: 30px; top: ' + (e.clientY - 5) + 'px; left: ' + (e.clientX - 5) + 'px; z-index: 1000; background: ' + (ie ? 'rgba(255, 255, 255, .05)' : 'transparent') + '; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);';
            if (webkit)
                var oldScrollY = window.scrollY;
            display.input.focus();
            if (webkit)
                window.scrollTo(null, oldScrollY);
            display.input.reset();
            if (!cm.somethingSelected())
                te.value = input.prevInput = ' ';
            input.contextMenuPending = true;
            display.selForContextMenu = cm.doc.sel;
            clearTimeout(display.detectingSelectAll);
            function prepareSelectAllHack() {
                if (te.selectionStart != null) {
                    var selected = cm.somethingSelected();
                    var extval = '\u200B' + (selected ? te.value : '');
                    te.value = '\u21DA';
                    te.value = extval;
                    input.prevInput = selected ? '' : '\u200B';
                    te.selectionStart = 1;
                    te.selectionEnd = extval.length;
                    display.selForContextMenu = cm.doc.sel;
                }
            }
            function rehide() {
                input.contextMenuPending = false;
                input.wrapper.style.position = 'relative';
                te.style.cssText = oldCSS;
                if (ie && ie_version < 9)
                    display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);
                if (te.selectionStart != null) {
                    if (!ie || ie && ie_version < 9)
                        prepareSelectAllHack();
                    var i = 0, poll = function () {
                            if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && te.selectionEnd > 0 && input.prevInput == '\u200B')
                                operation(cm, commands.selectAll)(cm);
                            else if (i++ < 10)
                                display.detectingSelectAll = setTimeout(poll, 500);
                            else
                                display.input.reset();
                        };
                    display.detectingSelectAll = setTimeout(poll, 200);
                }
            }
            if (ie && ie_version >= 9)
                prepareSelectAllHack();
            if (captureRightClick) {
                e_stop(e);
                var mouseup = function () {
                    off(window, 'mouseup', mouseup);
                    setTimeout(rehide, 20);
                };
                on(window, 'mouseup', mouseup);
            } else {
                setTimeout(rehide, 50);
            }
        },
        setUneditable: nothing,
        needsContentAttribute: false
    }, TextareaInput.prototype);
    function ContentEditableInput(cm) {
        this.cm = cm;
        this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
        this.polling = new Delayed();
        this.gracePeriod = false;
    }
    ContentEditableInput.prototype = copyObj({
        init: function (display) {
            var input = this, cm = input.cm;
            var div = input.div = display.lineDiv;
            div.contentEditable = 'true';
            disableBrowserMagic(div);
            on(div, 'paste', function (e) {
                var pasted = e.clipboardData && e.clipboardData.getData('text/plain');
                if (pasted) {
                    e.preventDefault();
                    cm.replaceSelection(pasted, null, 'paste');
                }
            });
            on(div, 'compositionstart', function (e) {
                var data = e.data;
                input.composing = {
                    sel: cm.doc.sel,
                    data: data,
                    startData: data
                };
                if (!data)
                    return;
                var prim = cm.doc.sel.primary();
                var line = cm.getLine(prim.head.line);
                var found = line.indexOf(data, Math.max(0, prim.head.ch - data.length));
                if (found > -1 && found <= prim.head.ch)
                    input.composing.sel = simpleSelection(Pos(prim.head.line, found), Pos(prim.head.line, found + data.length));
            });
            on(div, 'compositionupdate', function (e) {
                input.composing.data = e.data;
            });
            on(div, 'compositionend', function (e) {
                var ours = input.composing;
                if (!ours)
                    return;
                if (e.data != ours.startData && !/\u200b/.test(e.data))
                    ours.data = e.data;
                setTimeout(function () {
                    if (!ours.handled)
                        input.applyComposition(ours);
                    if (input.composing == ours)
                        input.composing = null;
                }, 50);
            });
            on(div, 'touchstart', function () {
                input.forceCompositionEnd();
            });
            on(div, 'input', function () {
                if (input.composing)
                    return;
                if (!input.pollContent())
                    runInOp(input.cm, function () {
                        regChange(cm);
                    });
            });
            function onCopyCut(e) {
                if (cm.somethingSelected()) {
                    lastCopied = cm.getSelections();
                    if (e.type == 'cut')
                        cm.replaceSelection('', null, 'cut');
                } else if (!cm.options.lineWiseCopyCut) {
                    return;
                } else {
                    var ranges = copyableRanges(cm);
                    lastCopied = ranges.text;
                    if (e.type == 'cut') {
                        cm.operation(function () {
                            cm.setSelections(ranges.ranges, 0, sel_dontScroll);
                            cm.replaceSelection('', null, 'cut');
                        });
                    }
                }
                if (e.clipboardData && !ios) {
                    e.preventDefault();
                    e.clipboardData.clearData();
                    e.clipboardData.setData('text/plain', lastCopied.join('\n'));
                } else {
                    var kludge = hiddenTextarea(), te = kludge.firstChild;
                    cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
                    te.value = lastCopied.join('\n');
                    var hadFocus = document.activeElement;
                    selectInput(te);
                    setTimeout(function () {
                        cm.display.lineSpace.removeChild(kludge);
                        hadFocus.focus();
                    }, 50);
                }
            }
            on(div, 'copy', onCopyCut);
            on(div, 'cut', onCopyCut);
        },
        prepareSelection: function () {
            var result = prepareSelection(this.cm, false);
            result.focus = this.cm.state.focused;
            return result;
        },
        showSelection: function (info) {
            if (!info || !this.cm.display.view.length)
                return;
            if (info.focus)
                this.showPrimarySelection();
            this.showMultipleSelections(info);
        },
        showPrimarySelection: function () {
            var sel = window.getSelection(), prim = this.cm.doc.sel.primary();
            var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset);
            var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset);
            if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && cmp(minPos(curAnchor, curFocus), prim.from()) == 0 && cmp(maxPos(curAnchor, curFocus), prim.to()) == 0)
                return;
            var start = posToDOM(this.cm, prim.from());
            var end = posToDOM(this.cm, prim.to());
            if (!start && !end)
                return;
            var view = this.cm.display.view;
            var old = sel.rangeCount && sel.getRangeAt(0);
            if (!start) {
                start = {
                    node: view[0].measure.map[2],
                    offset: 0
                };
            } else if (!end) {
                var measure = view[view.length - 1].measure;
                var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
                end = {
                    node: map[map.length - 1],
                    offset: map[map.length - 2] - map[map.length - 3]
                };
            }
            try {
                var rng = range(start.node, start.offset, end.offset, end.node);
            } catch (e) {
            }
            if (rng) {
                sel.removeAllRanges();
                sel.addRange(rng);
                if (old && sel.anchorNode == null)
                    sel.addRange(old);
                else if (gecko)
                    this.startGracePeriod();
            }
            this.rememberSelection();
        },
        startGracePeriod: function () {
            var input = this;
            clearTimeout(this.gracePeriod);
            this.gracePeriod = setTimeout(function () {
                input.gracePeriod = false;
                if (input.selectionChanged())
                    input.cm.operation(function () {
                        input.cm.curOp.selectionChanged = true;
                    });
            }, 20);
        },
        showMultipleSelections: function (info) {
            removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
            removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
        },
        rememberSelection: function () {
            var sel = window.getSelection();
            this.lastAnchorNode = sel.anchorNode;
            this.lastAnchorOffset = sel.anchorOffset;
            this.lastFocusNode = sel.focusNode;
            this.lastFocusOffset = sel.focusOffset;
        },
        selectionInEditor: function () {
            var sel = window.getSelection();
            if (!sel.rangeCount)
                return false;
            var node = sel.getRangeAt(0).commonAncestorContainer;
            return contains(this.div, node);
        },
        focus: function () {
            if (this.cm.options.readOnly != 'nocursor')
                this.div.focus();
        },
        blur: function () {
            this.div.blur();
        },
        getField: function () {
            return this.div;
        },
        supportsTouch: function () {
            return true;
        },
        receivedFocus: function () {
            var input = this;
            if (this.selectionInEditor())
                this.pollSelection();
            else
                runInOp(this.cm, function () {
                    input.cm.curOp.selectionChanged = true;
                });
            function poll() {
                if (input.cm.state.focused) {
                    input.pollSelection();
                    input.polling.set(input.cm.options.pollInterval, poll);
                }
            }
            this.polling.set(this.cm.options.pollInterval, poll);
        },
        selectionChanged: function () {
            var sel = window.getSelection();
            return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
        },
        pollSelection: function () {
            if (!this.composing && !this.gracePeriod && this.selectionChanged()) {
                var sel = window.getSelection(), cm = this.cm;
                this.rememberSelection();
                var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
                var head = domToPos(cm, sel.focusNode, sel.focusOffset);
                if (anchor && head)
                    runInOp(cm, function () {
                        setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
                        if (anchor.bad || head.bad)
                            cm.curOp.selectionChanged = true;
                    });
            }
        },
        pollContent: function () {
            var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
            var from = sel.from(), to = sel.to();
            if (from.line < display.viewFrom || to.line > display.viewTo - 1)
                return false;
            var fromIndex;
            if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
                var fromLine = lineNo(display.view[0].line);
                var fromNode = display.view[0].node;
            } else {
                var fromLine = lineNo(display.view[fromIndex].line);
                var fromNode = display.view[fromIndex - 1].node.nextSibling;
            }
            var toIndex = findViewIndex(cm, to.line);
            if (toIndex == display.view.length - 1) {
                var toLine = display.viewTo - 1;
                var toNode = display.view[toIndex].node;
            } else {
                var toLine = lineNo(display.view[toIndex + 1].line) - 1;
                var toNode = display.view[toIndex + 1].node.previousSibling;
            }
            var newText = splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
            var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
            while (newText.length > 1 && oldText.length > 1) {
                if (lst(newText) == lst(oldText)) {
                    newText.pop();
                    oldText.pop();
                    toLine--;
                } else if (newText[0] == oldText[0]) {
                    newText.shift();
                    oldText.shift();
                    fromLine++;
                } else
                    break;
            }
            var cutFront = 0, cutEnd = 0;
            var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
            while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
                ++cutFront;
            var newBot = lst(newText), oldBot = lst(oldText);
            var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0), oldBot.length - (oldText.length == 1 ? cutFront : 0));
            while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
                ++cutEnd;
            newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd);
            newText[0] = newText[0].slice(cutFront);
            var chFrom = Pos(fromLine, cutFront);
            var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
            if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
                replaceRange(cm.doc, newText, chFrom, chTo, '+input');
                return true;
            }
        },
        ensurePolled: function () {
            this.forceCompositionEnd();
        },
        reset: function () {
            this.forceCompositionEnd();
        },
        forceCompositionEnd: function () {
            if (!this.composing || this.composing.handled)
                return;
            this.applyComposition(this.composing);
            this.composing.handled = true;
            this.div.blur();
            this.div.focus();
        },
        applyComposition: function (composing) {
            if (composing.data && composing.data != composing.startData)
                operation(this.cm, applyTextInput)(this.cm, composing.data, 0, composing.sel);
        },
        setUneditable: function (node) {
            node.setAttribute('contenteditable', 'false');
        },
        onKeyPress: function (e) {
            e.preventDefault();
            operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);
        },
        onContextMenu: nothing,
        resetPosition: nothing,
        needsContentAttribute: true
    }, ContentEditableInput.prototype);
    function posToDOM(cm, pos) {
        var view = findViewForLine(cm, pos.line);
        if (!view || view.hidden)
            return null;
        var line = getLine(cm.doc, pos.line);
        var info = mapFromLineView(view, line, pos.line);
        var order = getOrder(line), side = 'left';
        if (order) {
            var partPos = getBidiPartAt(order, pos.ch);
            side = partPos % 2 ? 'right' : 'left';
        }
        var result = nodeAndOffsetInLineMap(info.map, pos.ch, 'left');
        result.offset = result.collapse == 'right' ? result.end : result.start;
        return result;
    }
    function badPos(pos, bad) {
        if (bad)
            pos.bad = true;
        return pos;
    }
    function domToPos(cm, node, offset) {
        var lineNode;
        if (node == cm.display.lineDiv) {
            lineNode = cm.display.lineDiv.childNodes[offset];
            if (!lineNode)
                return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);
            node = null;
            offset = 0;
        } else {
            for (lineNode = node;; lineNode = lineNode.parentNode) {
                if (!lineNode || lineNode == cm.display.lineDiv)
                    return null;
                if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv)
                    break;
            }
        }
        for (var i = 0; i < cm.display.view.length; i++) {
            var lineView = cm.display.view[i];
            if (lineView.node == lineNode)
                return locateNodeInLineView(lineView, node, offset);
        }
    }
    function locateNodeInLineView(lineView, node, offset) {
        var wrapper = lineView.text.firstChild, bad = false;
        if (!node || !contains(wrapper, node))
            return badPos(Pos(lineNo(lineView.line), 0), true);
        if (node == wrapper) {
            bad = true;
            node = wrapper.childNodes[offset];
            offset = 0;
            if (!node) {
                var line = lineView.rest ? lst(lineView.rest) : lineView.line;
                return badPos(Pos(lineNo(line), line.text.length), bad);
            }
        }
        var textNode = node.nodeType == 3 ? node : null, topNode = node;
        if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
            textNode = node.firstChild;
            if (offset)
                offset = textNode.nodeValue.length;
        }
        while (topNode.parentNode != wrapper)
            topNode = topNode.parentNode;
        var measure = lineView.measure, maps = measure.maps;
        function find(textNode, topNode, offset) {
            for (var i = -1; i < (maps ? maps.length : 0); i++) {
                var map = i < 0 ? measure.map : maps[i];
                for (var j = 0; j < map.length; j += 3) {
                    var curNode = map[j + 2];
                    if (curNode == textNode || curNode == topNode) {
                        var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
                        var ch = map[j] + offset;
                        if (offset < 0 || curNode != textNode)
                            ch = map[j + (offset ? 1 : 0)];
                        return Pos(line, ch);
                    }
                }
            }
        }
        var found = find(textNode, topNode, offset);
        if (found)
            return badPos(found, bad);
        for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
            found = find(after, after.firstChild, 0);
            if (found)
                return badPos(Pos(found.line, found.ch - dist), bad);
            else
                dist += after.textContent.length;
        }
        for (var before = topNode.previousSibling, dist = offset; before; before = before.previousSibling) {
            found = find(before, before.firstChild, -1);
            if (found)
                return badPos(Pos(found.line, found.ch + dist), bad);
            else
                dist += after.textContent.length;
        }
    }
    function domTextBetween(cm, from, to, fromLine, toLine) {
        var text = '', closing = false;
        function recognizeMarker(id) {
            return function (marker) {
                return marker.id == id;
            };
        }
        function walk(node) {
            if (node.nodeType == 1) {
                var cmText = node.getAttribute('cm-text');
                if (cmText != null) {
                    if (cmText == '')
                        cmText = node.textContent.replace(/\u200b/g, '');
                    text += cmText;
                    return;
                }
                var markerID = node.getAttribute('cm-marker'), range;
                if (markerID) {
                    var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
                    if (found.length && (range = found[0].find()))
                        text += getBetween(cm.doc, range.from, range.to).join('\n');
                    return;
                }
                if (node.getAttribute('contenteditable') == 'false')
                    return;
                for (var i = 0; i < node.childNodes.length; i++)
                    walk(node.childNodes[i]);
                if (/^(pre|div|p)$/i.test(node.nodeName))
                    closing = true;
            } else if (node.nodeType == 3) {
                var val = node.nodeValue;
                if (!val)
                    return;
                if (closing) {
                    text += '\n';
                    closing = false;
                }
                text += val;
            }
        }
        for (;;) {
            walk(from);
            if (from == to)
                break;
            from = from.nextSibling;
        }
        return text;
    }
    CodeMirror.inputStyles = {
        'textarea': TextareaInput,
        'contenteditable': ContentEditableInput
    };
    function Selection(ranges, primIndex) {
        this.ranges = ranges;
        this.primIndex = primIndex;
    }
    Selection.prototype = {
        primary: function () {
            return this.ranges[this.primIndex];
        },
        equals: function (other) {
            if (other == this)
                return true;
            if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length)
                return false;
            for (var i = 0; i < this.ranges.length; i++) {
                var here = this.ranges[i], there = other.ranges[i];
                if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0)
                    return false;
            }
            return true;
        },
        deepCopy: function () {
            for (var out = [], i = 0; i < this.ranges.length; i++)
                out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));
            return new Selection(out, this.primIndex);
        },
        somethingSelected: function () {
            for (var i = 0; i < this.ranges.length; i++)
                if (!this.ranges[i].empty())
                    return true;
            return false;
        },
        contains: function (pos, end) {
            if (!end)
                end = pos;
            for (var i = 0; i < this.ranges.length; i++) {
                var range = this.ranges[i];
                if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
                    return i;
            }
            return -1;
        }
    };
    function Range(anchor, head) {
        this.anchor = anchor;
        this.head = head;
    }
    Range.prototype = {
        from: function () {
            return minPos(this.anchor, this.head);
        },
        to: function () {
            return maxPos(this.anchor, this.head);
        },
        empty: function () {
            return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
        }
    };
    function normalizeSelection(ranges, primIndex) {
        var prim = ranges[primIndex];
        ranges.sort(function (a, b) {
            return cmp(a.from(), b.from());
        });
        primIndex = indexOf(ranges, prim);
        for (var i = 1; i < ranges.length; i++) {
            var cur = ranges[i], prev = ranges[i - 1];
            if (cmp(prev.to(), cur.from()) >= 0) {
                var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
                var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
                if (i <= primIndex)
                    --primIndex;
                ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
            }
        }
        return new Selection(ranges, primIndex);
    }
    function simpleSelection(anchor, head) {
        return new Selection([new Range(anchor, head || anchor)], 0);
    }
    function clipLine(doc, n) {
        return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));
    }
    function clipPos(doc, pos) {
        if (pos.line < doc.first)
            return Pos(doc.first, 0);
        var last = doc.first + doc.size - 1;
        if (pos.line > last)
            return Pos(last, getLine(doc, last).text.length);
        return clipToLen(pos, getLine(doc, pos.line).text.length);
    }
    function clipToLen(pos, linelen) {
        var ch = pos.ch;
        if (ch == null || ch > linelen)
            return Pos(pos.line, linelen);
        else if (ch < 0)
            return Pos(pos.line, 0);
        else
            return pos;
    }
    function isLine(doc, l) {
        return l >= doc.first && l < doc.first + doc.size;
    }
    function clipPosArray(doc, array) {
        for (var out = [], i = 0; i < array.length; i++)
            out[i] = clipPos(doc, array[i]);
        return out;
    }
    function extendRange(doc, range, head, other) {
        if (doc.cm && doc.cm.display.shift || doc.extend) {
            var anchor = range.anchor;
            if (other) {
                var posBefore = cmp(head, anchor) < 0;
                if (posBefore != cmp(other, anchor) < 0) {
                    anchor = head;
                    head = other;
                } else if (posBefore != cmp(head, other) < 0) {
                    head = other;
                }
            }
            return new Range(anchor, head);
        } else {
            return new Range(other || head, head);
        }
    }
    function extendSelection(doc, head, other, options) {
        setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);
    }
    function extendSelections(doc, heads, options) {
        for (var out = [], i = 0; i < doc.sel.ranges.length; i++)
            out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);
        var newSel = normalizeSelection(out, doc.sel.primIndex);
        setSelection(doc, newSel, options);
    }
    function replaceOneSelection(doc, i, range, options) {
        var ranges = doc.sel.ranges.slice(0);
        ranges[i] = range;
        setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);
    }
    function setSimpleSelection(doc, anchor, head, options) {
        setSelection(doc, simpleSelection(anchor, head), options);
    }
    function filterSelectionChange(doc, sel) {
        var obj = {
            ranges: sel.ranges,
            update: function (ranges) {
                this.ranges = [];
                for (var i = 0; i < ranges.length; i++)
                    this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor), clipPos(doc, ranges[i].head));
            }
        };
        signal(doc, 'beforeSelectionChange', doc, obj);
        if (doc.cm)
            signal(doc.cm, 'beforeSelectionChange', doc.cm, obj);
        if (obj.ranges != sel.ranges)
            return normalizeSelection(obj.ranges, obj.ranges.length - 1);
        else
            return sel;
    }
    function setSelectionReplaceHistory(doc, sel, options) {
        var done = doc.history.done, last = lst(done);
        if (last && last.ranges) {
            done[done.length - 1] = sel;
            setSelectionNoUndo(doc, sel, options);
        } else {
            setSelection(doc, sel, options);
        }
    }
    function setSelection(doc, sel, options) {
        setSelectionNoUndo(doc, sel, options);
        addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
    }
    function setSelectionNoUndo(doc, sel, options) {
        if (hasHandler(doc, 'beforeSelectionChange') || doc.cm && hasHandler(doc.cm, 'beforeSelectionChange'))
            sel = filterSelectionChange(doc, sel);
        var bias = options && options.bias || (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
        setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));
        if (!(options && options.scroll === false) && doc.cm)
            ensureCursorVisible(doc.cm);
    }
    function setSelectionInner(doc, sel) {
        if (sel.equals(doc.sel))
            return;
        doc.sel = sel;
        if (doc.cm) {
            doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;
            signalCursorActivity(doc.cm);
        }
        signalLater(doc, 'cursorActivity', doc);
    }
    function reCheckSelection(doc) {
        setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);
    }
    function skipAtomicInSelection(doc, sel, bias, mayClear) {
        var out;
        for (var i = 0; i < sel.ranges.length; i++) {
            var range = sel.ranges[i];
            var newAnchor = skipAtomic(doc, range.anchor, bias, mayClear);
            var newHead = skipAtomic(doc, range.head, bias, mayClear);
            if (out || newAnchor != range.anchor || newHead != range.head) {
                if (!out)
                    out = sel.ranges.slice(0, i);
                out[i] = new Range(newAnchor, newHead);
            }
        }
        return out ? normalizeSelection(out, sel.primIndex) : sel;
    }
    function skipAtomic(doc, pos, bias, mayClear) {
        var flipped = false, curPos = pos;
        var dir = bias || 1;
        doc.cantEdit = false;
        search:
            for (;;) {
                var line = getLine(doc, curPos.line);
                if (line.markedSpans) {
                    for (var i = 0; i < line.markedSpans.length; ++i) {
                        var sp = line.markedSpans[i], m = sp.marker;
                        if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) && (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {
                            if (mayClear) {
                                signal(m, 'beforeCursorEnter');
                                if (m.explicitlyCleared) {
                                    if (!line.markedSpans)
                                        break;
                                    else {
                                        --i;
                                        continue;
                                    }
                                }
                            }
                            if (!m.atomic)
                                continue;
                            var newPos = m.find(dir < 0 ? -1 : 1);
                            if (cmp(newPos, curPos) == 0) {
                                newPos.ch += dir;
                                if (newPos.ch < 0) {
                                    if (newPos.line > doc.first)
                                        newPos = clipPos(doc, Pos(newPos.line - 1));
                                    else
                                        newPos = null;
                                } else if (newPos.ch > line.text.length) {
                                    if (newPos.line < doc.first + doc.size - 1)
                                        newPos = Pos(newPos.line + 1, 0);
                                    else
                                        newPos = null;
                                }
                                if (!newPos) {
                                    if (flipped) {
                                        if (!mayClear)
                                            return skipAtomic(doc, pos, bias, true);
                                        doc.cantEdit = true;
                                        return Pos(doc.first, 0);
                                    }
                                    flipped = true;
                                    newPos = pos;
                                    dir = -dir;
                                }
                            }
                            curPos = newPos;
                            continue search;
                        }
                    }
                }
                return curPos;
            }
    }
    function updateSelection(cm) {
        cm.display.input.showSelection(cm.display.input.prepareSelection());
    }
    function prepareSelection(cm, primary) {
        var doc = cm.doc, result = {};
        var curFragment = result.cursors = document.createDocumentFragment();
        var selFragment = result.selection = document.createDocumentFragment();
        for (var i = 0; i < doc.sel.ranges.length; i++) {
            if (primary === false && i == doc.sel.primIndex)
                continue;
            var range = doc.sel.ranges[i];
            var collapsed = range.empty();
            if (collapsed || cm.options.showCursorWhenSelecting)
                drawSelectionCursor(cm, range, curFragment);
            if (!collapsed)
                drawSelectionRange(cm, range, selFragment);
        }
        return result;
    }
    function drawSelectionCursor(cm, range, output) {
        var pos = cursorCoords(cm, range.head, 'div', null, null, !cm.options.singleCursorHeightPerLine);
        var cursor = output.appendChild(elt('div', '\xA0', 'CodeMirror-cursor'));
        cursor.style.left = pos.left + 'px';
        cursor.style.top = pos.top + 'px';
        cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + 'px';
        if (pos.other) {
            var otherCursor = output.appendChild(elt('div', '\xA0', 'CodeMirror-cursor CodeMirror-secondarycursor'));
            otherCursor.style.display = '';
            otherCursor.style.left = pos.other.left + 'px';
            otherCursor.style.top = pos.other.top + 'px';
            otherCursor.style.height = (pos.other.bottom - pos.other.top) * 0.85 + 'px';
        }
    }
    function drawSelectionRange(cm, range, output) {
        var display = cm.display, doc = cm.doc;
        var fragment = document.createDocumentFragment();
        var padding = paddingH(cm.display), leftSide = padding.left;
        var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
        function add(left, top, width, bottom) {
            if (top < 0)
                top = 0;
            top = Math.round(top);
            bottom = Math.round(bottom);
            fragment.appendChild(elt('div', null, 'CodeMirror-selected', 'position: absolute; left: ' + left + 'px; top: ' + top + 'px; width: ' + (width == null ? rightSide - left : width) + 'px; height: ' + (bottom - top) + 'px'));
        }
        function drawForLine(line, fromArg, toArg) {
            var lineObj = getLine(doc, line);
            var lineLen = lineObj.text.length;
            var start, end;
            function coords(ch, bias) {
                return charCoords(cm, Pos(line, ch), 'div', lineObj, bias);
            }
            iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir) {
                var leftPos = coords(from, 'left'), rightPos, left, right;
                if (from == to) {
                    rightPos = leftPos;
                    left = right = leftPos.left;
                } else {
                    rightPos = coords(to - 1, 'right');
                    if (dir == 'rtl') {
                        var tmp = leftPos;
                        leftPos = rightPos;
                        rightPos = tmp;
                    }
                    left = leftPos.left;
                    right = rightPos.right;
                }
                if (fromArg == null && from == 0)
                    left = leftSide;
                if (rightPos.top - leftPos.top > 3) {
                    add(left, leftPos.top, null, leftPos.bottom);
                    left = leftSide;
                    if (leftPos.bottom < rightPos.top)
                        add(left, leftPos.bottom, null, rightPos.top);
                }
                if (toArg == null && to == lineLen)
                    right = rightSide;
                if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)
                    start = leftPos;
                if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)
                    end = rightPos;
                if (left < leftSide + 1)
                    left = leftSide;
                add(left, rightPos.top, right - left, rightPos.bottom);
            });
            return {
                start: start,
                end: end
            };
        }
        var sFrom = range.from(), sTo = range.to();
        if (sFrom.line == sTo.line) {
            drawForLine(sFrom.line, sFrom.ch, sTo.ch);
        } else {
            var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
            var singleVLine = visualLine(fromLine) == visualLine(toLine);
            var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
            var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
            if (singleVLine) {
                if (leftEnd.top < rightStart.top - 2) {
                    add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
                    add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
                } else {
                    add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
                }
            }
            if (leftEnd.bottom < rightStart.top)
                add(leftSide, leftEnd.bottom, null, rightStart.top);
        }
        output.appendChild(fragment);
    }
    function restartBlink(cm) {
        if (!cm.state.focused)
            return;
        var display = cm.display;
        clearInterval(display.blinker);
        var on = true;
        display.cursorDiv.style.visibility = '';
        if (cm.options.cursorBlinkRate > 0)
            display.blinker = setInterval(function () {
                display.cursorDiv.style.visibility = (on = !on) ? '' : 'hidden';
            }, cm.options.cursorBlinkRate);
        else if (cm.options.cursorBlinkRate < 0)
            display.cursorDiv.style.visibility = 'hidden';
    }
    function startWorker(cm, time) {
        if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)
            cm.state.highlight.set(time, bind(highlightWorker, cm));
    }
    function highlightWorker(cm) {
        var doc = cm.doc;
        if (doc.frontier < doc.first)
            doc.frontier = doc.first;
        if (doc.frontier >= cm.display.viewTo)
            return;
        var end = +new Date() + cm.options.workTime;
        var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));
        var changedLines = [];
        doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
            if (doc.frontier >= cm.display.viewFrom) {
                var oldStyles = line.styles;
                var highlighted = highlightLine(cm, line, state, true);
                line.styles = highlighted.styles;
                var oldCls = line.styleClasses, newCls = highlighted.classes;
                if (newCls)
                    line.styleClasses = newCls;
                else if (oldCls)
                    line.styleClasses = null;
                var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
                for (var i = 0; !ischange && i < oldStyles.length; ++i)
                    ischange = oldStyles[i] != line.styles[i];
                if (ischange)
                    changedLines.push(doc.frontier);
                line.stateAfter = copyState(doc.mode, state);
            } else {
                processLine(cm, line.text, state);
                line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;
            }
            ++doc.frontier;
            if (+new Date() > end) {
                startWorker(cm, cm.options.workDelay);
                return true;
            }
        });
        if (changedLines.length)
            runInOp(cm, function () {
                for (var i = 0; i < changedLines.length; i++)
                    regLineChange(cm, changedLines[i], 'text');
            });
    }
    function findStartLine(cm, n, precise) {
        var minindent, minline, doc = cm.doc;
        var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
        for (var search = n; search > lim; --search) {
            if (search <= doc.first)
                return doc.first;
            var line = getLine(doc, search - 1);
            if (line.stateAfter && (!precise || search <= doc.frontier))
                return search;
            var indented = countColumn(line.text, null, cm.options.tabSize);
            if (minline == null || minindent > indented) {
                minline = search - 1;
                minindent = indented;
            }
        }
        return minline;
    }
    function getStateBefore(cm, n, precise) {
        var doc = cm.doc, display = cm.display;
        if (!doc.mode.startState)
            return true;
        var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos - 1).stateAfter;
        if (!state)
            state = startState(doc.mode);
        else
            state = copyState(doc.mode, state);
        doc.iter(pos, n, function (line) {
            processLine(cm, line.text, state);
            var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;
            line.stateAfter = save ? copyState(doc.mode, state) : null;
            ++pos;
        });
        if (precise)
            doc.frontier = pos;
        return state;
    }
    function paddingTop(display) {
        return display.lineSpace.offsetTop;
    }
    function paddingVert(display) {
        return display.mover.offsetHeight - display.lineSpace.offsetHeight;
    }
    function paddingH(display) {
        if (display.cachedPaddingH)
            return display.cachedPaddingH;
        var e = removeChildrenAndAdd(display.measure, elt('pre', 'x'));
        var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
        var data = {
            left: parseInt(style.paddingLeft),
            right: parseInt(style.paddingRight)
        };
        if (!isNaN(data.left) && !isNaN(data.right))
            display.cachedPaddingH = data;
        return data;
    }
    function scrollGap(cm) {
        return scrollerGap - cm.display.nativeBarWidth;
    }
    function displayWidth(cm) {
        return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
    }
    function displayHeight(cm) {
        return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
    }
    function ensureLineHeights(cm, lineView, rect) {
        var wrapping = cm.options.lineWrapping;
        var curWidth = wrapping && displayWidth(cm);
        if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
            var heights = lineView.measure.heights = [];
            if (wrapping) {
                lineView.measure.width = curWidth;
                var rects = lineView.text.firstChild.getClientRects();
                for (var i = 0; i < rects.length - 1; i++) {
                    var cur = rects[i], next = rects[i + 1];
                    if (Math.abs(cur.bottom - next.bottom) > 2)
                        heights.push((cur.bottom + next.top) / 2 - rect.top);
                }
            }
            heights.push(rect.bottom - rect.top);
        }
    }
    function mapFromLineView(lineView, line, lineN) {
        if (lineView.line == line)
            return {
                map: lineView.measure.map,
                cache: lineView.measure.cache
            };
        for (var i = 0; i < lineView.rest.length; i++)
            if (lineView.rest[i] == line)
                return {
                    map: lineView.measure.maps[i],
                    cache: lineView.measure.caches[i]
                };
        for (var i = 0; i < lineView.rest.length; i++)
            if (lineNo(lineView.rest[i]) > lineN)
                return {
                    map: lineView.measure.maps[i],
                    cache: lineView.measure.caches[i],
                    before: true
                };
    }
    function updateExternalMeasurement(cm, line) {
        line = visualLine(line);
        var lineN = lineNo(line);
        var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
        view.lineN = lineN;
        var built = view.built = buildLineContent(cm, view);
        view.text = built.pre;
        removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
        return view;
    }
    function measureChar(cm, line, ch, bias) {
        return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
    }
    function findViewForLine(cm, lineN) {
        if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
            return cm.display.view[findViewIndex(cm, lineN)];
        var ext = cm.display.externalMeasured;
        if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
            return ext;
    }
    function prepareMeasureForLine(cm, line) {
        var lineN = lineNo(line);
        var view = findViewForLine(cm, lineN);
        if (view && !view.text)
            view = null;
        else if (view && view.changes)
            updateLineForChanges(cm, view, lineN, getDimensions(cm));
        if (!view)
            view = updateExternalMeasurement(cm, line);
        var info = mapFromLineView(view, line, lineN);
        return {
            line: line,
            view: view,
            rect: null,
            map: info.map,
            cache: info.cache,
            before: info.before,
            hasHeights: false
        };
    }
    function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
        if (prepared.before)
            ch = -1;
        var key = ch + (bias || ''), found;
        if (prepared.cache.hasOwnProperty(key)) {
            found = prepared.cache[key];
        } else {
            if (!prepared.rect)
                prepared.rect = prepared.view.text.getBoundingClientRect();
            if (!prepared.hasHeights) {
                ensureLineHeights(cm, prepared.view, prepared.rect);
                prepared.hasHeights = true;
            }
            found = measureCharInner(cm, prepared, ch, bias);
            if (!found.bogus)
                prepared.cache[key] = found;
        }
        return {
            left: found.left,
            right: found.right,
            top: varHeight ? found.rtop : found.top,
            bottom: varHeight ? found.rbottom : found.bottom
        };
    }
    var nullRect = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
    };
    function nodeAndOffsetInLineMap(map, ch, bias) {
        var node, start, end, collapse;
        for (var i = 0; i < map.length; i += 3) {
            var mStart = map[i], mEnd = map[i + 1];
            if (ch < mStart) {
                start = 0;
                end = 1;
                collapse = 'left';
            } else if (ch < mEnd) {
                start = ch - mStart;
                end = start + 1;
            } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {
                end = mEnd - mStart;
                start = end - 1;
                if (ch >= mEnd)
                    collapse = 'right';
            }
            if (start != null) {
                node = map[i + 2];
                if (mStart == mEnd && bias == (node.insertLeft ? 'left' : 'right'))
                    collapse = bias;
                if (bias == 'left' && start == 0)
                    while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {
                        node = map[(i -= 3) + 2];
                        collapse = 'left';
                    }
                if (bias == 'right' && start == mEnd - mStart)
                    while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {
                        node = map[(i += 3) + 2];
                        collapse = 'right';
                    }
                break;
            }
        }
        return {
            node: node,
            start: start,
            end: end,
            collapse: collapse,
            coverStart: mStart,
            coverEnd: mEnd
        };
    }
    function measureCharInner(cm, prepared, ch, bias) {
        var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
        var node = place.node, start = place.start, end = place.end, collapse = place.collapse;
        var rect;
        if (node.nodeType == 3) {
            for (var i = 0; i < 4; i++) {
                while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start)))
                    --start;
                while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end)))
                    ++end;
                if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {
                    rect = node.parentNode.getBoundingClientRect();
                } else if (ie && cm.options.lineWrapping) {
                    var rects = range(node, start, end).getClientRects();
                    if (rects.length)
                        rect = rects[bias == 'right' ? rects.length - 1 : 0];
                    else
                        rect = nullRect;
                } else {
                    rect = range(node, start, end).getBoundingClientRect() || nullRect;
                }
                if (rect.left || rect.right || start == 0)
                    break;
                end = start;
                start = start - 1;
                collapse = 'right';
            }
            if (ie && ie_version < 11)
                rect = maybeUpdateRectForZooming(cm.display.measure, rect);
        } else {
            if (start > 0)
                collapse = bias = 'right';
            var rects;
            if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
                rect = rects[bias == 'right' ? rects.length - 1 : 0];
            else
                rect = node.getBoundingClientRect();
        }
        if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
            var rSpan = node.parentNode.getClientRects()[0];
            if (rSpan)
                rect = {
                    left: rSpan.left,
                    right: rSpan.left + charWidth(cm.display),
                    top: rSpan.top,
                    bottom: rSpan.bottom
                };
            else
                rect = nullRect;
        }
        var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
        var mid = (rtop + rbot) / 2;
        var heights = prepared.view.measure.heights;
        for (var i = 0; i < heights.length - 1; i++)
            if (mid < heights[i])
                break;
        var top = i ? heights[i - 1] : 0, bot = heights[i];
        var result = {
            left: (collapse == 'right' ? rect.right : rect.left) - prepared.rect.left,
            right: (collapse == 'left' ? rect.left : rect.right) - prepared.rect.left,
            top: top,
            bottom: bot
        };
        if (!rect.left && !rect.right)
            result.bogus = true;
        if (!cm.options.singleCursorHeightPerLine) {
            result.rtop = rtop;
            result.rbottom = rbot;
        }
        return result;
    }
    function maybeUpdateRectForZooming(measure, rect) {
        if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
            return rect;
        var scaleX = screen.logicalXDPI / screen.deviceXDPI;
        var scaleY = screen.logicalYDPI / screen.deviceYDPI;
        return {
            left: rect.left * scaleX,
            right: rect.right * scaleX,
            top: rect.top * scaleY,
            bottom: rect.bottom * scaleY
        };
    }
    function clearLineMeasurementCacheFor(lineView) {
        if (lineView.measure) {
            lineView.measure.cache = {};
            lineView.measure.heights = null;
            if (lineView.rest)
                for (var i = 0; i < lineView.rest.length; i++)
                    lineView.measure.caches[i] = {};
        }
    }
    function clearLineMeasurementCache(cm) {
        cm.display.externalMeasure = null;
        removeChildren(cm.display.lineMeasure);
        for (var i = 0; i < cm.display.view.length; i++)
            clearLineMeasurementCacheFor(cm.display.view[i]);
    }
    function clearCaches(cm) {
        clearLineMeasurementCache(cm);
        cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
        if (!cm.options.lineWrapping)
            cm.display.maxLineChanged = true;
        cm.display.lineNumChars = null;
    }
    function pageScrollX() {
        return window.pageXOffset || (document.documentElement || document.body).scrollLeft;
    }
    function pageScrollY() {
        return window.pageYOffset || (document.documentElement || document.body).scrollTop;
    }
    function intoCoordSystem(cm, lineObj, rect, context) {
        if (lineObj.widgets)
            for (var i = 0; i < lineObj.widgets.length; ++i)
                if (lineObj.widgets[i].above) {
                    var size = widgetHeight(lineObj.widgets[i]);
                    rect.top += size;
                    rect.bottom += size;
                }
        if (context == 'line')
            return rect;
        if (!context)
            context = 'local';
        var yOff = heightAtLine(lineObj);
        if (context == 'local')
            yOff += paddingTop(cm.display);
        else
            yOff -= cm.display.viewOffset;
        if (context == 'page' || context == 'window') {
            var lOff = cm.display.lineSpace.getBoundingClientRect();
            yOff += lOff.top + (context == 'window' ? 0 : pageScrollY());
            var xOff = lOff.left + (context == 'window' ? 0 : pageScrollX());
            rect.left += xOff;
            rect.right += xOff;
        }
        rect.top += yOff;
        rect.bottom += yOff;
        return rect;
    }
    function fromCoordSystem(cm, coords, context) {
        if (context == 'div')
            return coords;
        var left = coords.left, top = coords.top;
        if (context == 'page') {
            left -= pageScrollX();
            top -= pageScrollY();
        } else if (context == 'local' || !context) {
            var localBox = cm.display.sizer.getBoundingClientRect();
            left += localBox.left;
            top += localBox.top;
        }
        var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
        return {
            left: left - lineSpaceBox.left,
            top: top - lineSpaceBox.top
        };
    }
    function charCoords(cm, pos, context, lineObj, bias) {
        if (!lineObj)
            lineObj = getLine(cm.doc, pos.line);
        return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
    }
    function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
        lineObj = lineObj || getLine(cm.doc, pos.line);
        if (!preparedMeasure)
            preparedMeasure = prepareMeasureForLine(cm, lineObj);
        function get(ch, right) {
            var m = measureCharPrepared(cm, preparedMeasure, ch, right ? 'right' : 'left', varHeight);
            if (right)
                m.left = m.right;
            else
                m.right = m.left;
            return intoCoordSystem(cm, lineObj, m, context);
        }
        function getBidi(ch, partPos) {
            var part = order[partPos], right = part.level % 2;
            if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {
                part = order[--partPos];
                ch = bidiRight(part) - (part.level % 2 ? 0 : 1);
                right = true;
            } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {
                part = order[++partPos];
                ch = bidiLeft(part) - part.level % 2;
                right = false;
            }
            if (right && ch == part.to && ch > part.from)
                return get(ch - 1);
            return get(ch, right);
        }
        var order = getOrder(lineObj), ch = pos.ch;
        if (!order)
            return get(ch);
        var partPos = getBidiPartAt(order, ch);
        var val = getBidi(ch, partPos);
        if (bidiOther != null)
            val.other = getBidi(ch, bidiOther);
        return val;
    }
    function estimateCoords(cm, pos) {
        var left = 0, pos = clipPos(cm.doc, pos);
        if (!cm.options.lineWrapping)
            left = charWidth(cm.display) * pos.ch;
        var lineObj = getLine(cm.doc, pos.line);
        var top = heightAtLine(lineObj) + paddingTop(cm.display);
        return {
            left: left,
            right: left,
            top: top,
            bottom: top + lineObj.height
        };
    }
    function PosWithInfo(line, ch, outside, xRel) {
        var pos = Pos(line, ch);
        pos.xRel = xRel;
        if (outside)
            pos.outside = true;
        return pos;
    }
    function coordsChar(cm, x, y) {
        var doc = cm.doc;
        y += cm.display.viewOffset;
        if (y < 0)
            return PosWithInfo(doc.first, 0, true, -1);
        var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
        if (lineN > last)
            return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);
        if (x < 0)
            x = 0;
        var lineObj = getLine(doc, lineN);
        for (;;) {
            var found = coordsCharInner(cm, lineObj, lineN, x, y);
            var merged = collapsedSpanAtEnd(lineObj);
            var mergedPos = merged && merged.find(0, true);
            if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))
                lineN = lineNo(lineObj = mergedPos.to.line);
            else
                return found;
        }
    }
    function coordsCharInner(cm, lineObj, lineNo, x, y) {
        var innerOff = y - heightAtLine(lineObj);
        var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;
        var preparedMeasure = prepareMeasureForLine(cm, lineObj);
        function getX(ch) {
            var sp = cursorCoords(cm, Pos(lineNo, ch), 'line', lineObj, preparedMeasure);
            wrongLine = true;
            if (innerOff > sp.bottom)
                return sp.left - adjust;
            else if (innerOff < sp.top)
                return sp.left + adjust;
            else
                wrongLine = false;
            return sp.left;
        }
        var bidi = getOrder(lineObj), dist = lineObj.text.length;
        var from = lineLeft(lineObj), to = lineRight(lineObj);
        var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;
        if (x > toX)
            return PosWithInfo(lineNo, to, toOutside, 1);
        for (;;) {
            if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {
                var ch = x < fromX || x - fromX <= toX - x ? from : to;
                var xDiff = x - (ch == from ? fromX : toX);
                while (isExtendingChar(lineObj.text.charAt(ch)))
                    ++ch;
                var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside, xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);
                return pos;
            }
            var step = Math.ceil(dist / 2), middle = from + step;
            if (bidi) {
                middle = from;
                for (var i = 0; i < step; ++i)
                    middle = moveVisually(lineObj, middle, 1);
            }
            var middleX = getX(middle);
            if (middleX > x) {
                to = middle;
                toX = middleX;
                if (toOutside = wrongLine)
                    toX += 1000;
                dist = step;
            } else {
                from = middle;
                fromX = middleX;
                fromOutside = wrongLine;
                dist -= step;
            }
        }
    }
    var measureText;
    function textHeight(display) {
        if (display.cachedTextHeight != null)
            return display.cachedTextHeight;
        if (measureText == null) {
            measureText = elt('pre');
            for (var i = 0; i < 49; ++i) {
                measureText.appendChild(document.createTextNode('x'));
                measureText.appendChild(elt('br'));
            }
            measureText.appendChild(document.createTextNode('x'));
        }
        removeChildrenAndAdd(display.measure, measureText);
        var height = measureText.offsetHeight / 50;
        if (height > 3)
            display.cachedTextHeight = height;
        removeChildren(display.measure);
        return height || 1;
    }
    function charWidth(display) {
        if (display.cachedCharWidth != null)
            return display.cachedCharWidth;
        var anchor = elt('span', 'xxxxxxxxxx');
        var pre = elt('pre', [anchor]);
        removeChildrenAndAdd(display.measure, pre);
        var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
        if (width > 2)
            display.cachedCharWidth = width;
        return width || 10;
    }
    var operationGroup = null;
    var nextOpId = 0;
    function startOperation(cm) {
        cm.curOp = {
            cm: cm,
            viewChanged: false,
            startHeight: cm.doc.height,
            forceUpdate: false,
            updateInput: null,
            typing: false,
            changeObjs: null,
            cursorActivityHandlers: null,
            cursorActivityCalled: 0,
            selectionChanged: false,
            updateMaxLine: false,
            scrollLeft: null,
            scrollTop: null,
            scrollToPos: null,
            focus: false,
            id: ++nextOpId
        };
        if (operationGroup) {
            operationGroup.ops.push(cm.curOp);
        } else {
            cm.curOp.ownsGroup = operationGroup = {
                ops: [cm.curOp],
                delayedCallbacks: []
            };
        }
    }
    function fireCallbacksForOps(group) {
        var callbacks = group.delayedCallbacks, i = 0;
        do {
            for (; i < callbacks.length; i++)
                callbacks[i]();
            for (var j = 0; j < group.ops.length; j++) {
                var op = group.ops[j];
                if (op.cursorActivityHandlers)
                    while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
                        op.cursorActivityHandlers[op.cursorActivityCalled++](op.cm);
            }
        } while (i < callbacks.length);
    }
    function endOperation(cm) {
        var op = cm.curOp, group = op.ownsGroup;
        if (!group)
            return;
        try {
            fireCallbacksForOps(group);
        } finally {
            operationGroup = null;
            for (var i = 0; i < group.ops.length; i++)
                group.ops[i].cm.curOp = null;
            endOperations(group);
        }
    }
    function endOperations(group) {
        var ops = group.ops;
        for (var i = 0; i < ops.length; i++)
            endOperation_R1(ops[i]);
        for (var i = 0; i < ops.length; i++)
            endOperation_W1(ops[i]);
        for (var i = 0; i < ops.length; i++)
            endOperation_R2(ops[i]);
        for (var i = 0; i < ops.length; i++)
            endOperation_W2(ops[i]);
        for (var i = 0; i < ops.length; i++)
            endOperation_finish(ops[i]);
    }
    function endOperation_R1(op) {
        var cm = op.cm, display = cm.display;
        maybeClipScrollbars(cm);
        if (op.updateMaxLine)
            findMaxLine(cm);
        op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;
        op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && {
            top: op.scrollTop,
            ensure: op.scrollToPos
        }, op.forceUpdate);
    }
    function endOperation_W1(op) {
        op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
    }
    function endOperation_R2(op) {
        var cm = op.cm, display = cm.display;
        if (op.updatedDisplay)
            updateHeightsInViewport(cm);
        op.barMeasure = measureForScrollbars(cm);
        if (display.maxLineChanged && !cm.options.lineWrapping) {
            op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
            cm.display.sizerWidth = op.adjustWidthTo;
            op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
            op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
        }
        if (op.updatedDisplay || op.selectionChanged)
            op.preparedSelection = display.input.prepareSelection();
    }
    function endOperation_W2(op) {
        var cm = op.cm;
        if (op.adjustWidthTo != null) {
            cm.display.sizer.style.minWidth = op.adjustWidthTo + 'px';
            if (op.maxScrollLeft < cm.doc.scrollLeft)
                setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
            cm.display.maxLineChanged = false;
        }
        if (op.preparedSelection)
            cm.display.input.showSelection(op.preparedSelection);
        if (op.updatedDisplay)
            setDocumentHeight(cm, op.barMeasure);
        if (op.updatedDisplay || op.startHeight != cm.doc.height)
            updateScrollbars(cm, op.barMeasure);
        if (op.selectionChanged)
            restartBlink(cm);
        if (cm.state.focused && op.updateInput)
            cm.display.input.reset(op.typing);
        if (op.focus && op.focus == activeElt())
            ensureFocus(op.cm);
    }
    function endOperation_finish(op) {
        var cm = op.cm, display = cm.display, doc = cm.doc;
        if (op.updatedDisplay)
            postUpdateDisplay(cm, op.update);
        if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
            display.wheelStartX = display.wheelStartY = null;
        if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {
            doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));
            display.scrollbars.setScrollTop(doc.scrollTop);
            display.scroller.scrollTop = doc.scrollTop;
        }
        if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {
            doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - displayWidth(cm), op.scrollLeft));
            display.scrollbars.setScrollLeft(doc.scrollLeft);
            display.scroller.scrollLeft = doc.scrollLeft;
            alignHorizontally(cm);
        }
        if (op.scrollToPos) {
            var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from), clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
            if (op.scrollToPos.isCursor && cm.state.focused)
                maybeScrollWindow(cm, coords);
        }
        var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
        if (hidden)
            for (var i = 0; i < hidden.length; ++i)
                if (!hidden[i].lines.length)
                    signal(hidden[i], 'hide');
        if (unhidden)
            for (var i = 0; i < unhidden.length; ++i)
                if (unhidden[i].lines.length)
                    signal(unhidden[i], 'unhide');
        if (display.wrapper.offsetHeight)
            doc.scrollTop = cm.display.scroller.scrollTop;
        if (op.changeObjs)
            signal(cm, 'changes', cm, op.changeObjs);
        if (op.update)
            op.update.finish();
    }
    function runInOp(cm, f) {
        if (cm.curOp)
            return f();
        startOperation(cm);
        try {
            return f();
        } finally {
            endOperation(cm);
        }
    }
    function operation(cm, f) {
        return function () {
            if (cm.curOp)
                return f.apply(cm, arguments);
            startOperation(cm);
            try {
                return f.apply(cm, arguments);
            } finally {
                endOperation(cm);
            }
        };
    }
    function methodOp(f) {
        return function () {
            if (this.curOp)
                return f.apply(this, arguments);
            startOperation(this);
            try {
                return f.apply(this, arguments);
            } finally {
                endOperation(this);
            }
        };
    }
    function docMethodOp(f) {
        return function () {
            var cm = this.cm;
            if (!cm || cm.curOp)
                return f.apply(this, arguments);
            startOperation(cm);
            try {
                return f.apply(this, arguments);
            } finally {
                endOperation(cm);
            }
        };
    }
    function LineView(doc, line, lineN) {
        this.line = line;
        this.rest = visualLineContinued(line);
        this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
        this.node = this.text = null;
        this.hidden = lineIsHidden(doc, line);
    }
    function buildViewArray(cm, from, to) {
        var array = [], nextPos;
        for (var pos = from; pos < to; pos = nextPos) {
            var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
            nextPos = pos + view.size;
            array.push(view);
        }
        return array;
    }
    function regChange(cm, from, to, lendiff) {
        if (from == null)
            from = cm.doc.first;
        if (to == null)
            to = cm.doc.first + cm.doc.size;
        if (!lendiff)
            lendiff = 0;
        var display = cm.display;
        if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from))
            display.updateLineNumbers = from;
        cm.curOp.viewChanged = true;
        if (from >= display.viewTo) {
            if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
                resetView(cm);
        } else if (to <= display.viewFrom) {
            if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
                resetView(cm);
            } else {
                display.viewFrom += lendiff;
                display.viewTo += lendiff;
            }
        } else if (from <= display.viewFrom && to >= display.viewTo) {
            resetView(cm);
        } else if (from <= display.viewFrom) {
            var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
            if (cut) {
                display.view = display.view.slice(cut.index);
                display.viewFrom = cut.lineN;
                display.viewTo += lendiff;
            } else {
                resetView(cm);
            }
        } else if (to >= display.viewTo) {
            var cut = viewCuttingPoint(cm, from, from, -1);
            if (cut) {
                display.view = display.view.slice(0, cut.index);
                display.viewTo = cut.lineN;
            } else {
                resetView(cm);
            }
        } else {
            var cutTop = viewCuttingPoint(cm, from, from, -1);
            var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
            if (cutTop && cutBot) {
                display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));
                display.viewTo += lendiff;
            } else {
                resetView(cm);
            }
        }
        var ext = display.externalMeasured;
        if (ext) {
            if (to < ext.lineN)
                ext.lineN += lendiff;
            else if (from < ext.lineN + ext.size)
                display.externalMeasured = null;
        }
    }
    function regLineChange(cm, line, type) {
        cm.curOp.viewChanged = true;
        var display = cm.display, ext = cm.display.externalMeasured;
        if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
            display.externalMeasured = null;
        if (line < display.viewFrom || line >= display.viewTo)
            return;
        var lineView = display.view[findViewIndex(cm, line)];
        if (lineView.node == null)
            return;
        var arr = lineView.changes || (lineView.changes = []);
        if (indexOf(arr, type) == -1)
            arr.push(type);
    }
    function resetView(cm) {
        cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
        cm.display.view = [];
        cm.display.viewOffset = 0;
    }
    function findViewIndex(cm, n) {
        if (n >= cm.display.viewTo)
            return null;
        n -= cm.display.viewFrom;
        if (n < 0)
            return null;
        var view = cm.display.view;
        for (var i = 0; i < view.length; i++) {
            n -= view[i].size;
            if (n < 0)
                return i;
        }
    }
    function viewCuttingPoint(cm, oldN, newN, dir) {
        var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
        if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
            return {
                index: index,
                lineN: newN
            };
        for (var i = 0, n = cm.display.viewFrom; i < index; i++)
            n += view[i].size;
        if (n != oldN) {
            if (dir > 0) {
                if (index == view.length - 1)
                    return null;
                diff = n + view[index].size - oldN;
                index++;
            } else {
                diff = n - oldN;
            }
            oldN += diff;
            newN += diff;
        }
        while (visualLineNo(cm.doc, newN) != newN) {
            if (index == (dir < 0 ? 0 : view.length - 1))
                return null;
            newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
            index += dir;
        }
        return {
            index: index,
            lineN: newN
        };
    }
    function adjustView(cm, from, to) {
        var display = cm.display, view = display.view;
        if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
            display.view = buildViewArray(cm, from, to);
            display.viewFrom = from;
        } else {
            if (display.viewFrom > from)
                display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
            else if (display.viewFrom < from)
                display.view = display.view.slice(findViewIndex(cm, from));
            display.viewFrom = from;
            if (display.viewTo < to)
                display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
            else if (display.viewTo > to)
                display.view = display.view.slice(0, findViewIndex(cm, to));
        }
        display.viewTo = to;
    }
    function countDirtyView(cm) {
        var view = cm.display.view, dirty = 0;
        for (var i = 0; i < view.length; i++) {
            var lineView = view[i];
            if (!lineView.hidden && (!lineView.node || lineView.changes))
                ++dirty;
        }
        return dirty;
    }
    function registerEventHandlers(cm) {
        var d = cm.display;
        on(d.scroller, 'mousedown', operation(cm, onMouseDown));
        if (ie && ie_version < 11)
            on(d.scroller, 'dblclick', operation(cm, function (e) {
                if (signalDOMEvent(cm, e))
                    return;
                var pos = posFromMouse(cm, e);
                if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e))
                    return;
                e_preventDefault(e);
                var word = cm.findWordAt(pos);
                extendSelection(cm.doc, word.anchor, word.head);
            }));
        else
            on(d.scroller, 'dblclick', function (e) {
                signalDOMEvent(cm, e) || e_preventDefault(e);
            });
        if (!captureRightClick)
            on(d.scroller, 'contextmenu', function (e) {
                onContextMenu(cm, e);
            });
        var touchFinished, prevTouch = { end: 0 };
        function finishTouch() {
            if (d.activeTouch) {
                touchFinished = setTimeout(function () {
                    d.activeTouch = null;
                }, 1000);
                prevTouch = d.activeTouch;
                prevTouch.end = +new Date();
            }
        }
        ;
        function isMouseLikeTouchEvent(e) {
            if (e.touches.length != 1)
                return false;
            var touch = e.touches[0];
            return touch.radiusX <= 1 && touch.radiusY <= 1;
        }
        function farAway(touch, other) {
            if (other.left == null)
                return true;
            var dx = other.left - touch.left, dy = other.top - touch.top;
            return dx * dx + dy * dy > 20 * 20;
        }
        on(d.scroller, 'touchstart', function (e) {
            if (!isMouseLikeTouchEvent(e)) {
                clearTimeout(touchFinished);
                var now = +new Date();
                d.activeTouch = {
                    start: now,
                    moved: false,
                    prev: now - prevTouch.end <= 300 ? prevTouch : null
                };
                if (e.touches.length == 1) {
                    d.activeTouch.left = e.touches[0].pageX;
                    d.activeTouch.top = e.touches[0].pageY;
                }
            }
        });
        on(d.scroller, 'touchmove', function () {
            if (d.activeTouch)
                d.activeTouch.moved = true;
        });
        on(d.scroller, 'touchend', function (e) {
            var touch = d.activeTouch;
            if (touch && !eventInWidget(d, e) && touch.left != null && !touch.moved && new Date() - touch.start < 300) {
                var pos = cm.coordsChar(d.activeTouch, 'page'), range;
                if (!touch.prev || farAway(touch, touch.prev))
                    range = new Range(pos, pos);
                else if (!touch.prev.prev || farAway(touch, touch.prev.prev))
                    range = cm.findWordAt(pos);
                else
                    range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
                cm.setSelection(range.anchor, range.head);
                cm.focus();
                e_preventDefault(e);
            }
            finishTouch();
        });
        on(d.scroller, 'touchcancel', finishTouch);
        on(d.scroller, 'scroll', function () {
            if (d.scroller.clientHeight) {
                setScrollTop(cm, d.scroller.scrollTop);
                setScrollLeft(cm, d.scroller.scrollLeft, true);
                signal(cm, 'scroll', cm);
            }
        });
        on(d.scroller, 'mousewheel', function (e) {
            onScrollWheel(cm, e);
        });
        on(d.scroller, 'DOMMouseScroll', function (e) {
            onScrollWheel(cm, e);
        });
        on(d.wrapper, 'scroll', function () {
            d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;
        });
        d.dragFunctions = {
            simple: function (e) {
                if (!signalDOMEvent(cm, e))
                    e_stop(e);
            },
            start: function (e) {
                onDragStart(cm, e);
            },
            drop: operation(cm, onDrop)
        };
        var inp = d.input.getField();
        on(inp, 'keyup', function (e) {
            onKeyUp.call(cm, e);
        });
        on(inp, 'keydown', operation(cm, onKeyDown));
        on(inp, 'keypress', operation(cm, onKeyPress));
        on(inp, 'focus', bind(onFocus, cm));
        on(inp, 'blur', bind(onBlur, cm));
    }
    function dragDropChanged(cm, value, old) {
        var wasOn = old && old != CodeMirror.Init;
        if (!value != !wasOn) {
            var funcs = cm.display.dragFunctions;
            var toggle = value ? on : off;
            toggle(cm.display.scroller, 'dragstart', funcs.start);
            toggle(cm.display.scroller, 'dragenter', funcs.simple);
            toggle(cm.display.scroller, 'dragover', funcs.simple);
            toggle(cm.display.scroller, 'drop', funcs.drop);
        }
    }
    function onResize(cm) {
        var d = cm.display;
        if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)
            return;
        d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
        d.scrollbarsClipped = false;
        cm.setSize();
    }
    function eventInWidget(display, e) {
        for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
            if (!n || n.nodeType == 1 && n.getAttribute('cm-ignore-events') == 'true' || n.parentNode == display.sizer && n != display.mover)
                return true;
        }
    }
    function posFromMouse(cm, e, liberal, forRect) {
        var display = cm.display;
        if (!liberal && e_target(e).getAttribute('cm-not-content') == 'true')
            return null;
        var x, y, space = display.lineSpace.getBoundingClientRect();
        try {
            x = e.clientX - space.left;
            y = e.clientY - space.top;
        } catch (e) {
            return null;
        }
        var coords = coordsChar(cm, x, y), line;
        if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
            var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
            coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
        }
        return coords;
    }
    function onMouseDown(e) {
        var cm = this, display = cm.display;
        if (display.activeTouch && display.input.supportsTouch() || signalDOMEvent(cm, e))
            return;
        display.shift = e.shiftKey;
        if (eventInWidget(display, e)) {
            if (!webkit) {
                display.scroller.draggable = false;
                setTimeout(function () {
                    display.scroller.draggable = true;
                }, 100);
            }
            return;
        }
        if (clickInGutter(cm, e))
            return;
        var start = posFromMouse(cm, e);
        window.focus();
        switch (e_button(e)) {
        case 1:
            if (start)
                leftButtonDown(cm, e, start);
            else if (e_target(e) == display.scroller)
                e_preventDefault(e);
            break;
        case 2:
            if (webkit)
                cm.state.lastMiddleDown = +new Date();
            if (start)
                extendSelection(cm.doc, start);
            setTimeout(function () {
                display.input.focus();
            }, 20);
            e_preventDefault(e);
            break;
        case 3:
            if (captureRightClick)
                onContextMenu(cm, e);
            else
                delayBlurEvent(cm);
            break;
        }
    }
    var lastClick, lastDoubleClick;
    function leftButtonDown(cm, e, start) {
        if (ie)
            setTimeout(bind(ensureFocus, cm), 0);
        else
            cm.curOp.focus = activeElt();
        var now = +new Date(), type;
        if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {
            type = 'triple';
        } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {
            type = 'double';
            lastDoubleClick = {
                time: now,
                pos: start
            };
        } else {
            type = 'single';
            lastClick = {
                time: now,
                pos: start
            };
        }
        var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained;
        if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) && type == 'single' && (contained = sel.contains(start)) > -1 && !sel.ranges[contained].empty())
            leftButtonStartDrag(cm, e, start, modifier);
        else
            leftButtonSelect(cm, e, start, type, modifier);
    }
    function leftButtonStartDrag(cm, e, start, modifier) {
        var display = cm.display, startTime = +new Date();
        var dragEnd = operation(cm, function (e2) {
            if (webkit)
                display.scroller.draggable = false;
            cm.state.draggingText = false;
            off(document, 'mouseup', dragEnd);
            off(display.scroller, 'drop', dragEnd);
            if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {
                e_preventDefault(e2);
                if (!modifier && +new Date() - 200 < startTime)
                    extendSelection(cm.doc, start);
                if (webkit || ie && ie_version == 9)
                    setTimeout(function () {
                        document.body.focus();
                        display.input.focus();
                    }, 20);
                else
                    display.input.focus();
            }
        });
        if (webkit)
            display.scroller.draggable = true;
        cm.state.draggingText = dragEnd;
        if (display.scroller.dragDrop)
            display.scroller.dragDrop();
        on(document, 'mouseup', dragEnd);
        on(display.scroller, 'drop', dragEnd);
    }
    function leftButtonSelect(cm, e, start, type, addNew) {
        var display = cm.display, doc = cm.doc;
        e_preventDefault(e);
        var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
        if (addNew && !e.shiftKey) {
            ourIndex = doc.sel.contains(start);
            if (ourIndex > -1)
                ourRange = ranges[ourIndex];
            else
                ourRange = new Range(start, start);
        } else {
            ourRange = doc.sel.primary();
            ourIndex = doc.sel.primIndex;
        }
        if (e.altKey) {
            type = 'rect';
            if (!addNew)
                ourRange = new Range(start, start);
            start = posFromMouse(cm, e, true, true);
            ourIndex = -1;
        } else if (type == 'double') {
            var word = cm.findWordAt(start);
            if (cm.display.shift || doc.extend)
                ourRange = extendRange(doc, ourRange, word.anchor, word.head);
            else
                ourRange = word;
        } else if (type == 'triple') {
            var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));
            if (cm.display.shift || doc.extend)
                ourRange = extendRange(doc, ourRange, line.anchor, line.head);
            else
                ourRange = line;
        } else {
            ourRange = extendRange(doc, ourRange, start);
        }
        if (!addNew) {
            ourIndex = 0;
            setSelection(doc, new Selection([ourRange], 0), sel_mouse);
            startSel = doc.sel;
        } else if (ourIndex == -1) {
            ourIndex = ranges.length;
            setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex), {
                scroll: false,
                origin: '*mouse'
            });
        } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == 'single' && !e.shiftKey) {
            setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0));
            startSel = doc.sel;
        } else {
            replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
        }
        var lastPos = start;
        function extendTo(pos) {
            if (cmp(lastPos, pos) == 0)
                return;
            lastPos = pos;
            if (type == 'rect') {
                var ranges = [], tabSize = cm.options.tabSize;
                var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
                var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
                var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
                for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line)); line <= end; line++) {
                    var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
                    if (left == right)
                        ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));
                    else if (text.length > leftPos)
                        ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));
                }
                if (!ranges.length)
                    ranges.push(new Range(start, start));
                setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex), {
                    origin: '*mouse',
                    scroll: false
                });
                cm.scrollIntoView(pos);
            } else {
                var oldRange = ourRange;
                var anchor = oldRange.anchor, head = pos;
                if (type != 'single') {
                    if (type == 'double')
                        var range = cm.findWordAt(pos);
                    else
                        var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));
                    if (cmp(range.anchor, anchor) > 0) {
                        head = range.head;
                        anchor = minPos(oldRange.from(), range.anchor);
                    } else {
                        head = range.anchor;
                        anchor = maxPos(oldRange.to(), range.head);
                    }
                }
                var ranges = startSel.ranges.slice(0);
                ranges[ourIndex] = new Range(clipPos(doc, anchor), head);
                setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);
            }
        }
        var editorSize = display.wrapper.getBoundingClientRect();
        var counter = 0;
        function extend(e) {
            var curCount = ++counter;
            var cur = posFromMouse(cm, e, true, type == 'rect');
            if (!cur)
                return;
            if (cmp(cur, lastPos) != 0) {
                cm.curOp.focus = activeElt();
                extendTo(cur);
                var visible = visibleLines(display, doc);
                if (cur.line >= visible.to || cur.line < visible.from)
                    setTimeout(operation(cm, function () {
                        if (counter == curCount)
                            extend(e);
                    }), 150);
            } else {
                var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
                if (outside)
                    setTimeout(operation(cm, function () {
                        if (counter != curCount)
                            return;
                        display.scroller.scrollTop += outside;
                        extend(e);
                    }), 50);
            }
        }
        function done(e) {
            counter = Infinity;
            e_preventDefault(e);
            display.input.focus();
            off(document, 'mousemove', move);
            off(document, 'mouseup', up);
            doc.history.lastSelOrigin = null;
        }
        var move = operation(cm, function (e) {
            if (!e_button(e))
                done(e);
            else
                extend(e);
        });
        var up = operation(cm, done);
        on(document, 'mousemove', move);
        on(document, 'mouseup', up);
    }
    function gutterEvent(cm, e, type, prevent, signalfn) {
        try {
            var mX = e.clientX, mY = e.clientY;
        } catch (e) {
            return false;
        }
        if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right))
            return false;
        if (prevent)
            e_preventDefault(e);
        var display = cm.display;
        var lineBox = display.lineDiv.getBoundingClientRect();
        if (mY > lineBox.bottom || !hasHandler(cm, type))
            return e_defaultPrevented(e);
        mY -= lineBox.top - display.viewOffset;
        for (var i = 0; i < cm.options.gutters.length; ++i) {
            var g = display.gutters.childNodes[i];
            if (g && g.getBoundingClientRect().right >= mX) {
                var line = lineAtHeight(cm.doc, mY);
                var gutter = cm.options.gutters[i];
                signalfn(cm, type, cm, line, gutter, e);
                return e_defaultPrevented(e);
            }
        }
    }
    function clickInGutter(cm, e) {
        return gutterEvent(cm, e, 'gutterClick', true, signalLater);
    }
    var lastDrop = 0;
    function onDrop(e) {
        var cm = this;
        if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
            return;
        e_preventDefault(e);
        if (ie)
            lastDrop = +new Date();
        var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
        if (!pos || isReadOnly(cm))
            return;
        if (files && files.length && window.FileReader && window.File) {
            var n = files.length, text = Array(n), read = 0;
            var loadFile = function (file, i) {
                var reader = new FileReader();
                reader.onload = operation(cm, function () {
                    text[i] = reader.result;
                    if (++read == n) {
                        pos = clipPos(cm.doc, pos);
                        var change = {
                            from: pos,
                            to: pos,
                            text: splitLines(text.join('\n')),
                            origin: 'paste'
                        };
                        makeChange(cm.doc, change);
                        setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));
                    }
                });
                reader.readAsText(file);
            };
            for (var i = 0; i < n; ++i)
                loadFile(files[i], i);
        } else {
            if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
                cm.state.draggingText(e);
                setTimeout(function () {
                    cm.display.input.focus();
                }, 20);
                return;
            }
            try {
                var text = e.dataTransfer.getData('Text');
                if (text) {
                    if (cm.state.draggingText && !(mac ? e.altKey : e.ctrlKey))
                        var selected = cm.listSelections();
                    setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
                    if (selected)
                        for (var i = 0; i < selected.length; ++i)
                            replaceRange(cm.doc, '', selected[i].anchor, selected[i].head, 'drag');
                    cm.replaceSelection(text, 'around', 'paste');
                    cm.display.input.focus();
                }
            } catch (e) {
            }
        }
    }
    function onDragStart(cm, e) {
        if (ie && (!cm.state.draggingText || +new Date() - lastDrop < 100)) {
            e_stop(e);
            return;
        }
        if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
            return;
        e.dataTransfer.setData('Text', cm.getSelection());
        if (e.dataTransfer.setDragImage && !safari) {
            var img = elt('img', null, null, 'position: fixed; left: 0; top: 0;');
            img.src = 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';
            if (presto) {
                img.width = img.height = 1;
                cm.display.wrapper.appendChild(img);
                img._top = img.offsetTop;
            }
            e.dataTransfer.setDragImage(img, 0, 0);
            if (presto)
                img.parentNode.removeChild(img);
        }
    }
    function setScrollTop(cm, val) {
        if (Math.abs(cm.doc.scrollTop - val) < 2)
            return;
        cm.doc.scrollTop = val;
        if (!gecko)
            updateDisplaySimple(cm, { top: val });
        if (cm.display.scroller.scrollTop != val)
            cm.display.scroller.scrollTop = val;
        cm.display.scrollbars.setScrollTop(val);
        if (gecko)
            updateDisplaySimple(cm);
        startWorker(cm, 100);
    }
    function setScrollLeft(cm, val, isScroller) {
        if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2)
            return;
        val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);
        cm.doc.scrollLeft = val;
        alignHorizontally(cm);
        if (cm.display.scroller.scrollLeft != val)
            cm.display.scroller.scrollLeft = val;
        cm.display.scrollbars.setScrollLeft(val);
    }
    var wheelSamples = 0, wheelPixelsPerUnit = null;
    if (ie)
        wheelPixelsPerUnit = -0.53;
    else if (gecko)
        wheelPixelsPerUnit = 15;
    else if (chrome)
        wheelPixelsPerUnit = -0.7;
    else if (safari)
        wheelPixelsPerUnit = -1 / 3;
    var wheelEventDelta = function (e) {
        var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
        if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS)
            dx = e.detail;
        if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS)
            dy = e.detail;
        else if (dy == null)
            dy = e.wheelDelta;
        return {
            x: dx,
            y: dy
        };
    };
    CodeMirror.wheelEventPixels = function (e) {
        var delta = wheelEventDelta(e);
        delta.x *= wheelPixelsPerUnit;
        delta.y *= wheelPixelsPerUnit;
        return delta;
    };
    function onScrollWheel(cm, e) {
        var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;
        var display = cm.display, scroll = display.scroller;
        if (!(dx && scroll.scrollWidth > scroll.clientWidth || dy && scroll.scrollHeight > scroll.clientHeight))
            return;
        if (dy && mac && webkit) {
            outer:
                for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
                    for (var i = 0; i < view.length; i++) {
                        if (view[i].node == cur) {
                            cm.display.currentWheelTarget = cur;
                            break outer;
                        }
                    }
                }
        }
        if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
            if (dy)
                setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));
            setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));
            e_preventDefault(e);
            display.wheelStartX = null;
            return;
        }
        if (dy && wheelPixelsPerUnit != null) {
            var pixels = dy * wheelPixelsPerUnit;
            var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
            if (pixels < 0)
                top = Math.max(0, top + pixels - 50);
            else
                bot = Math.min(cm.doc.height, bot + pixels + 50);
            updateDisplaySimple(cm, {
                top: top,
                bottom: bot
            });
        }
        if (wheelSamples < 20) {
            if (display.wheelStartX == null) {
                display.wheelStartX = scroll.scrollLeft;
                display.wheelStartY = scroll.scrollTop;
                display.wheelDX = dx;
                display.wheelDY = dy;
                setTimeout(function () {
                    if (display.wheelStartX == null)
                        return;
                    var movedX = scroll.scrollLeft - display.wheelStartX;
                    var movedY = scroll.scrollTop - display.wheelStartY;
                    var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
                    display.wheelStartX = display.wheelStartY = null;
                    if (!sample)
                        return;
                    wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
                    ++wheelSamples;
                }, 200);
            } else {
                display.wheelDX += dx;
                display.wheelDY += dy;
            }
        }
    }
    function doHandleBinding(cm, bound, dropShift) {
        if (typeof bound == 'string') {
            bound = commands[bound];
            if (!bound)
                return false;
        }
        cm.display.input.ensurePolled();
        var prevShift = cm.display.shift, done = false;
        try {
            if (isReadOnly(cm))
                cm.state.suppressEdits = true;
            if (dropShift)
                cm.display.shift = false;
            done = bound(cm) != Pass;
        } finally {
            cm.display.shift = prevShift;
            cm.state.suppressEdits = false;
        }
        return done;
    }
    function lookupKeyForEditor(cm, name, handle) {
        for (var i = 0; i < cm.state.keyMaps.length; i++) {
            var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
            if (result)
                return result;
        }
        return cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm) || lookupKey(name, cm.options.keyMap, handle, cm);
    }
    var stopSeq = new Delayed();
    function dispatchKey(cm, name, e, handle) {
        var seq = cm.state.keySeq;
        if (seq) {
            if (isModifierKey(name))
                return 'handled';
            stopSeq.set(50, function () {
                if (cm.state.keySeq == seq) {
                    cm.state.keySeq = null;
                    cm.display.input.reset();
                }
            });
            name = seq + ' ' + name;
        }
        var result = lookupKeyForEditor(cm, name, handle);
        if (result == 'multi')
            cm.state.keySeq = name;
        if (result == 'handled')
            signalLater(cm, 'keyHandled', cm, name, e);
        if (result == 'handled' || result == 'multi') {
            e_preventDefault(e);
            restartBlink(cm);
        }
        if (seq && !result && /\'$/.test(name)) {
            e_preventDefault(e);
            return true;
        }
        return !!result;
    }
    function handleKeyBinding(cm, e) {
        var name = keyName(e, true);
        if (!name)
            return false;
        if (e.shiftKey && !cm.state.keySeq) {
            return dispatchKey(cm, 'Shift-' + name, e, function (b) {
                return doHandleBinding(cm, b, true);
            }) || dispatchKey(cm, name, e, function (b) {
                if (typeof b == 'string' ? /^go[A-Z]/.test(b) : b.motion)
                    return doHandleBinding(cm, b);
            });
        } else {
            return dispatchKey(cm, name, e, function (b) {
                return doHandleBinding(cm, b);
            });
        }
    }
    function handleCharBinding(cm, e, ch) {
        return dispatchKey(cm, '\'' + ch + '\'', e, function (b) {
            return doHandleBinding(cm, b, true);
        });
    }
    var lastStoppedKey = null;
    function onKeyDown(e) {
        var cm = this;
        cm.curOp.focus = activeElt();
        if (signalDOMEvent(cm, e))
            return;
        if (ie && ie_version < 11 && e.keyCode == 27)
            e.returnValue = false;
        var code = e.keyCode;
        cm.display.shift = code == 16 || e.shiftKey;
        var handled = handleKeyBinding(cm, e);
        if (presto) {
            lastStoppedKey = handled ? code : null;
            if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
                cm.replaceSelection('', null, 'cut');
        }
        if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
            showCrossHair(cm);
    }
    function showCrossHair(cm) {
        var lineDiv = cm.display.lineDiv;
        addClass(lineDiv, 'CodeMirror-crosshair');
        function up(e) {
            if (e.keyCode == 18 || !e.altKey) {
                rmClass(lineDiv, 'CodeMirror-crosshair');
                off(document, 'keyup', up);
                off(document, 'mouseover', up);
            }
        }
        on(document, 'keyup', up);
        on(document, 'mouseover', up);
    }
    function onKeyUp(e) {
        if (e.keyCode == 16)
            this.doc.sel.shift = false;
        signalDOMEvent(this, e);
    }
    function onKeyPress(e) {
        var cm = this;
        if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey)
            return;
        var keyCode = e.keyCode, charCode = e.charCode;
        if (presto && keyCode == lastStoppedKey) {
            lastStoppedKey = null;
            e_preventDefault(e);
            return;
        }
        if (presto && (!e.which || e.which < 10) && handleKeyBinding(cm, e))
            return;
        var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
        if (handleCharBinding(cm, e, ch))
            return;
        cm.display.input.onKeyPress(e);
    }
    function delayBlurEvent(cm) {
        cm.state.delayingBlurEvent = true;
        setTimeout(function () {
            if (cm.state.delayingBlurEvent) {
                cm.state.delayingBlurEvent = false;
                onBlur(cm);
            }
        }, 100);
    }
    function onFocus(cm) {
        if (cm.state.delayingBlurEvent)
            cm.state.delayingBlurEvent = false;
        if (cm.options.readOnly == 'nocursor')
            return;
        if (!cm.state.focused) {
            signal(cm, 'focus', cm);
            cm.state.focused = true;
            addClass(cm.display.wrapper, 'CodeMirror-focused');
            if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
                cm.display.input.reset();
                if (webkit)
                    setTimeout(function () {
                        cm.display.input.reset(true);
                    }, 20);
            }
            cm.display.input.receivedFocus();
        }
        restartBlink(cm);
    }
    function onBlur(cm) {
        if (cm.state.delayingBlurEvent)
            return;
        if (cm.state.focused) {
            signal(cm, 'blur', cm);
            cm.state.focused = false;
            rmClass(cm.display.wrapper, 'CodeMirror-focused');
        }
        clearInterval(cm.display.blinker);
        setTimeout(function () {
            if (!cm.state.focused)
                cm.display.shift = false;
        }, 150);
    }
    function onContextMenu(cm, e) {
        if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e))
            return;
        cm.display.input.onContextMenu(e);
    }
    function contextMenuInGutter(cm, e) {
        if (!hasHandler(cm, 'gutterContextMenu'))
            return false;
        return gutterEvent(cm, e, 'gutterContextMenu', false, signal);
    }
    var changeEnd = CodeMirror.changeEnd = function (change) {
        if (!change.text)
            return change.to;
        return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
    };
    function adjustForChange(pos, change) {
        if (cmp(pos, change.from) < 0)
            return pos;
        if (cmp(pos, change.to) <= 0)
            return changeEnd(change);
        var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
        if (pos.line == change.to.line)
            ch += changeEnd(change).ch - change.to.ch;
        return Pos(line, ch);
    }
    function computeSelAfterChange(doc, change) {
        var out = [];
        for (var i = 0; i < doc.sel.ranges.length; i++) {
            var range = doc.sel.ranges[i];
            out.push(new Range(adjustForChange(range.anchor, change), adjustForChange(range.head, change)));
        }
        return normalizeSelection(out, doc.sel.primIndex);
    }
    function offsetPos(pos, old, nw) {
        if (pos.line == old.line)
            return Pos(nw.line, pos.ch - old.ch + nw.ch);
        else
            return Pos(nw.line + (pos.line - old.line), pos.ch);
    }
    function computeReplacedSel(doc, changes, hint) {
        var out = [];
        var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
        for (var i = 0; i < changes.length; i++) {
            var change = changes[i];
            var from = offsetPos(change.from, oldPrev, newPrev);
            var to = offsetPos(changeEnd(change), oldPrev, newPrev);
            oldPrev = change.to;
            newPrev = to;
            if (hint == 'around') {
                var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
                out[i] = new Range(inv ? to : from, inv ? from : to);
            } else {
                out[i] = new Range(from, from);
            }
        }
        return new Selection(out, doc.sel.primIndex);
    }
    function filterChange(doc, change, update) {
        var obj = {
            canceled: false,
            from: change.from,
            to: change.to,
            text: change.text,
            origin: change.origin,
            cancel: function () {
                this.canceled = true;
            }
        };
        if (update)
            obj.update = function (from, to, text, origin) {
                if (from)
                    this.from = clipPos(doc, from);
                if (to)
                    this.to = clipPos(doc, to);
                if (text)
                    this.text = text;
                if (origin !== undefined)
                    this.origin = origin;
            };
        signal(doc, 'beforeChange', doc, obj);
        if (doc.cm)
            signal(doc.cm, 'beforeChange', doc.cm, obj);
        if (obj.canceled)
            return null;
        return {
            from: obj.from,
            to: obj.to,
            text: obj.text,
            origin: obj.origin
        };
    }
    function makeChange(doc, change, ignoreReadOnly) {
        if (doc.cm) {
            if (!doc.cm.curOp)
                return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
            if (doc.cm.state.suppressEdits)
                return;
        }
        if (hasHandler(doc, 'beforeChange') || doc.cm && hasHandler(doc.cm, 'beforeChange')) {
            change = filterChange(doc, change, true);
            if (!change)
                return;
        }
        var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
        if (split) {
            for (var i = split.length - 1; i >= 0; --i)
                makeChangeInner(doc, {
                    from: split[i].from,
                    to: split[i].to,
                    text: i ? [''] : change.text
                });
        } else {
            makeChangeInner(doc, change);
        }
    }
    function makeChangeInner(doc, change) {
        if (change.text.length == 1 && change.text[0] == '' && cmp(change.from, change.to) == 0)
            return;
        var selAfter = computeSelAfterChange(doc, change);
        addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);
        makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
        var rebased = [];
        linkedDocs(doc, function (doc, sharedHist) {
            if (!sharedHist && indexOf(rebased, doc.history) == -1) {
                rebaseHist(doc.history, change);
                rebased.push(doc.history);
            }
            makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
        });
    }
    function makeChangeFromHistory(doc, type, allowSelectionOnly) {
        if (doc.cm && doc.cm.state.suppressEdits)
            return;
        var hist = doc.history, event, selAfter = doc.sel;
        var source = type == 'undo' ? hist.done : hist.undone, dest = type == 'undo' ? hist.undone : hist.done;
        for (var i = 0; i < source.length; i++) {
            event = source[i];
            if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
                break;
        }
        if (i == source.length)
            return;
        hist.lastOrigin = hist.lastSelOrigin = null;
        for (;;) {
            event = source.pop();
            if (event.ranges) {
                pushSelectionToHistory(event, dest);
                if (allowSelectionOnly && !event.equals(doc.sel)) {
                    setSelection(doc, event, { clearRedo: false });
                    return;
                }
                selAfter = event;
            } else
                break;
        }
        var antiChanges = [];
        pushSelectionToHistory(selAfter, dest);
        dest.push({
            changes: antiChanges,
            generation: hist.generation
        });
        hist.generation = event.generation || ++hist.maxGeneration;
        var filter = hasHandler(doc, 'beforeChange') || doc.cm && hasHandler(doc.cm, 'beforeChange');
        for (var i = event.changes.length - 1; i >= 0; --i) {
            var change = event.changes[i];
            change.origin = type;
            if (filter && !filterChange(doc, change, false)) {
                source.length = 0;
                return;
            }
            antiChanges.push(historyChangeFromChange(doc, change));
            var after = i ? computeSelAfterChange(doc, change) : lst(source);
            makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
            if (!i && doc.cm)
                doc.cm.scrollIntoView({
                    from: change.from,
                    to: changeEnd(change)
                });
            var rebased = [];
            linkedDocs(doc, function (doc, sharedHist) {
                if (!sharedHist && indexOf(rebased, doc.history) == -1) {
                    rebaseHist(doc.history, change);
                    rebased.push(doc.history);
                }
                makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
            });
        }
    }
    function shiftDoc(doc, distance) {
        if (distance == 0)
            return;
        doc.first += distance;
        doc.sel = new Selection(map(doc.sel.ranges, function (range) {
            return new Range(Pos(range.anchor.line + distance, range.anchor.ch), Pos(range.head.line + distance, range.head.ch));
        }), doc.sel.primIndex);
        if (doc.cm) {
            regChange(doc.cm, doc.first, doc.first - distance, distance);
            for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
                regLineChange(doc.cm, l, 'gutter');
        }
    }
    function makeChangeSingleDoc(doc, change, selAfter, spans) {
        if (doc.cm && !doc.cm.curOp)
            return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
        if (change.to.line < doc.first) {
            shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
            return;
        }
        if (change.from.line > doc.lastLine())
            return;
        if (change.from.line < doc.first) {
            var shift = change.text.length - 1 - (doc.first - change.from.line);
            shiftDoc(doc, shift);
            change = {
                from: Pos(doc.first, 0),
                to: Pos(change.to.line + shift, change.to.ch),
                text: [lst(change.text)],
                origin: change.origin
            };
        }
        var last = doc.lastLine();
        if (change.to.line > last) {
            change = {
                from: change.from,
                to: Pos(last, getLine(doc, last).text.length),
                text: [change.text[0]],
                origin: change.origin
            };
        }
        change.removed = getBetween(doc, change.from, change.to);
        if (!selAfter)
            selAfter = computeSelAfterChange(doc, change);
        if (doc.cm)
            makeChangeSingleDocInEditor(doc.cm, change, spans);
        else
            updateDoc(doc, change, spans);
        setSelectionNoUndo(doc, selAfter, sel_dontScroll);
    }
    function makeChangeSingleDocInEditor(cm, change, spans) {
        var doc = cm.doc, display = cm.display, from = change.from, to = change.to;
        var recomputeMaxLength = false, checkWidthStart = from.line;
        if (!cm.options.lineWrapping) {
            checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
            doc.iter(checkWidthStart, to.line + 1, function (line) {
                if (line == display.maxLine) {
                    recomputeMaxLength = true;
                    return true;
                }
            });
        }
        if (doc.sel.contains(change.from, change.to) > -1)
            signalCursorActivity(cm);
        updateDoc(doc, change, spans, estimateHeight(cm));
        if (!cm.options.lineWrapping) {
            doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
                var len = lineLength(line);
                if (len > display.maxLineLength) {
                    display.maxLine = line;
                    display.maxLineLength = len;
                    display.maxLineChanged = true;
                    recomputeMaxLength = false;
                }
            });
            if (recomputeMaxLength)
                cm.curOp.updateMaxLine = true;
        }
        doc.frontier = Math.min(doc.frontier, from.line);
        startWorker(cm, 400);
        var lendiff = change.text.length - (to.line - from.line) - 1;
        if (change.full)
            regChange(cm);
        else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
            regLineChange(cm, from.line, 'text');
        else
            regChange(cm, from.line, to.line + 1, lendiff);
        var changesHandler = hasHandler(cm, 'changes'), changeHandler = hasHandler(cm, 'change');
        if (changeHandler || changesHandler) {
            var obj = {
                from: from,
                to: to,
                text: change.text,
                removed: change.removed,
                origin: change.origin
            };
            if (changeHandler)
                signalLater(cm, 'change', cm, obj);
            if (changesHandler)
                (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
        }
        cm.display.selForContextMenu = null;
    }
    function replaceRange(doc, code, from, to, origin) {
        if (!to)
            to = from;
        if (cmp(to, from) < 0) {
            var tmp = to;
            to = from;
            from = tmp;
        }
        if (typeof code == 'string')
            code = splitLines(code);
        makeChange(doc, {
            from: from,
            to: to,
            text: code,
            origin: origin
        });
    }
    function maybeScrollWindow(cm, coords) {
        if (signalDOMEvent(cm, 'scrollCursorIntoView'))
            return;
        var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
        if (coords.top + box.top < 0)
            doScroll = true;
        else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight))
            doScroll = false;
        if (doScroll != null && !phantom) {
            var scrollNode = elt('div', '\u200B', null, 'position: absolute; top: ' + (coords.top - display.viewOffset - paddingTop(cm.display)) + 'px; height: ' + (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + 'px; left: ' + coords.left + 'px; width: 2px;');
            cm.display.lineSpace.appendChild(scrollNode);
            scrollNode.scrollIntoView(doScroll);
            cm.display.lineSpace.removeChild(scrollNode);
        }
    }
    function scrollPosIntoView(cm, pos, end, margin) {
        if (margin == null)
            margin = 0;
        for (var limit = 0; limit < 5; limit++) {
            var changed = false, coords = cursorCoords(cm, pos);
            var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
            var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left), Math.min(coords.top, endCoords.top) - margin, Math.max(coords.left, endCoords.left), Math.max(coords.bottom, endCoords.bottom) + margin);
            var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
            if (scrollPos.scrollTop != null) {
                setScrollTop(cm, scrollPos.scrollTop);
                if (Math.abs(cm.doc.scrollTop - startTop) > 1)
                    changed = true;
            }
            if (scrollPos.scrollLeft != null) {
                setScrollLeft(cm, scrollPos.scrollLeft);
                if (Math.abs(cm.doc.scrollLeft - startLeft) > 1)
                    changed = true;
            }
            if (!changed)
                break;
        }
        return coords;
    }
    function scrollIntoView(cm, x1, y1, x2, y2) {
        var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);
        if (scrollPos.scrollTop != null)
            setScrollTop(cm, scrollPos.scrollTop);
        if (scrollPos.scrollLeft != null)
            setScrollLeft(cm, scrollPos.scrollLeft);
    }
    function calculateScrollPos(cm, x1, y1, x2, y2) {
        var display = cm.display, snapMargin = textHeight(cm.display);
        if (y1 < 0)
            y1 = 0;
        var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
        var screen = displayHeight(cm), result = {};
        if (y2 - y1 > screen)
            y2 = y1 + screen;
        var docBottom = cm.doc.height + paddingVert(display);
        var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;
        if (y1 < screentop) {
            result.scrollTop = atTop ? 0 : y1;
        } else if (y2 > screentop + screen) {
            var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);
            if (newTop != screentop)
                result.scrollTop = newTop;
        }
        var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;
        var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);
        var tooWide = x2 - x1 > screenw;
        if (tooWide)
            x2 = x1 + screenw;
        if (x1 < 10)
            result.scrollLeft = 0;
        else if (x1 < screenleft)
            result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10));
        else if (x2 > screenw + screenleft - 3)
            result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw;
        return result;
    }
    function addToScrollPos(cm, left, top) {
        if (left != null || top != null)
            resolveScrollToPos(cm);
        if (left != null)
            cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;
        if (top != null)
            cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
    }
    function ensureCursorVisible(cm) {
        resolveScrollToPos(cm);
        var cur = cm.getCursor(), from = cur, to = cur;
        if (!cm.options.lineWrapping) {
            from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;
            to = Pos(cur.line, cur.ch + 1);
        }
        cm.curOp.scrollToPos = {
            from: from,
            to: to,
            margin: cm.options.cursorScrollMargin,
            isCursor: true
        };
    }
    function resolveScrollToPos(cm) {
        var range = cm.curOp.scrollToPos;
        if (range) {
            cm.curOp.scrollToPos = null;
            var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);
            var sPos = calculateScrollPos(cm, Math.min(from.left, to.left), Math.min(from.top, to.top) - range.margin, Math.max(from.right, to.right), Math.max(from.bottom, to.bottom) + range.margin);
            cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);
        }
    }
    function indentLine(cm, n, how, aggressive) {
        var doc = cm.doc, state;
        if (how == null)
            how = 'add';
        if (how == 'smart') {
            if (!doc.mode.indent)
                how = 'prev';
            else
                state = getStateBefore(cm, n);
        }
        var tabSize = cm.options.tabSize;
        var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
        if (line.stateAfter)
            line.stateAfter = null;
        var curSpaceString = line.text.match(/^\s*/)[0], indentation;
        if (!aggressive && !/\S/.test(line.text)) {
            indentation = 0;
            how = 'not';
        } else if (how == 'smart') {
            indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
            if (indentation == Pass || indentation > 150) {
                if (!aggressive)
                    return;
                how = 'prev';
            }
        }
        if (how == 'prev') {
            if (n > doc.first)
                indentation = countColumn(getLine(doc, n - 1).text, null, tabSize);
            else
                indentation = 0;
        } else if (how == 'add') {
            indentation = curSpace + cm.options.indentUnit;
        } else if (how == 'subtract') {
            indentation = curSpace - cm.options.indentUnit;
        } else if (typeof how == 'number') {
            indentation = curSpace + how;
        }
        indentation = Math.max(0, indentation);
        var indentString = '', pos = 0;
        if (cm.options.indentWithTabs)
            for (var i = Math.floor(indentation / tabSize); i; --i) {
                pos += tabSize;
                indentString += '\t';
            }
        if (pos < indentation)
            indentString += spaceStr(indentation - pos);
        if (indentString != curSpaceString) {
            replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), '+input');
            line.stateAfter = null;
            return true;
        } else {
            for (var i = 0; i < doc.sel.ranges.length; i++) {
                var range = doc.sel.ranges[i];
                if (range.head.line == n && range.head.ch < curSpaceString.length) {
                    var pos = Pos(n, curSpaceString.length);
                    replaceOneSelection(doc, i, new Range(pos, pos));
                    break;
                }
            }
        }
    }
    function changeLine(doc, handle, changeType, op) {
        var no = handle, line = handle;
        if (typeof handle == 'number')
            line = getLine(doc, clipLine(doc, handle));
        else
            no = lineNo(handle);
        if (no == null)
            return null;
        if (op(line, no) && doc.cm)
            regLineChange(doc.cm, no, changeType);
        return line;
    }
    function deleteNearSelection(cm, compute) {
        var ranges = cm.doc.sel.ranges, kill = [];
        for (var i = 0; i < ranges.length; i++) {
            var toKill = compute(ranges[i]);
            while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
                var replaced = kill.pop();
                if (cmp(replaced.from, toKill.from) < 0) {
                    toKill.from = replaced.from;
                    break;
                }
            }
            kill.push(toKill);
        }
        runInOp(cm, function () {
            for (var i = kill.length - 1; i >= 0; i--)
                replaceRange(cm.doc, '', kill[i].from, kill[i].to, '+delete');
            ensureCursorVisible(cm);
        });
    }
    function findPosH(doc, pos, dir, unit, visually) {
        var line = pos.line, ch = pos.ch, origDir = dir;
        var lineObj = getLine(doc, line);
        var possible = true;
        function findNextLine() {
            var l = line + dir;
            if (l < doc.first || l >= doc.first + doc.size)
                return possible = false;
            line = l;
            return lineObj = getLine(doc, l);
        }
        function moveOnce(boundToLine) {
            var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);
            if (next == null) {
                if (!boundToLine && findNextLine()) {
                    if (visually)
                        ch = (dir < 0 ? lineRight : lineLeft)(lineObj);
                    else
                        ch = dir < 0 ? lineObj.text.length : 0;
                } else
                    return possible = false;
            } else
                ch = next;
            return true;
        }
        if (unit == 'char')
            moveOnce();
        else if (unit == 'column')
            moveOnce(true);
        else if (unit == 'word' || unit == 'group') {
            var sawType = null, group = unit == 'group';
            var helper = doc.cm && doc.cm.getHelper(pos, 'wordChars');
            for (var first = true;; first = false) {
                if (dir < 0 && !moveOnce(!first))
                    break;
                var cur = lineObj.text.charAt(ch) || '\n';
                var type = isWordChar(cur, helper) ? 'w' : group && cur == '\n' ? 'n' : !group || /\s/.test(cur) ? null : 'p';
                if (group && !first && !type)
                    type = 's';
                if (sawType && sawType != type) {
                    if (dir < 0) {
                        dir = 1;
                        moveOnce();
                    }
                    break;
                }
                if (type)
                    sawType = type;
                if (dir > 0 && !moveOnce(!first))
                    break;
            }
        }
        var result = skipAtomic(doc, Pos(line, ch), origDir, true);
        if (!possible)
            result.hitSide = true;
        return result;
    }
    function findPosV(cm, pos, dir, unit) {
        var doc = cm.doc, x = pos.left, y;
        if (unit == 'page') {
            var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
            y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : 0.5) * textHeight(cm.display));
        } else if (unit == 'line') {
            y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
        }
        for (;;) {
            var target = coordsChar(cm, x, y);
            if (!target.outside)
                break;
            if (dir < 0 ? y <= 0 : y >= doc.height) {
                target.hitSide = true;
                break;
            }
            y += dir * 5;
        }
        return target;
    }
    CodeMirror.prototype = {
        constructor: CodeMirror,
        focus: function () {
            window.focus();
            this.display.input.focus();
        },
        setOption: function (option, value) {
            var options = this.options, old = options[option];
            if (options[option] == value && option != 'mode')
                return;
            options[option] = value;
            if (optionHandlers.hasOwnProperty(option))
                operation(this, optionHandlers[option])(this, value, old);
        },
        getOption: function (option) {
            return this.options[option];
        },
        getDoc: function () {
            return this.doc;
        },
        addKeyMap: function (map, bottom) {
            this.state.keyMaps[bottom ? 'push' : 'unshift'](getKeyMap(map));
        },
        removeKeyMap: function (map) {
            var maps = this.state.keyMaps;
            for (var i = 0; i < maps.length; ++i)
                if (maps[i] == map || maps[i].name == map) {
                    maps.splice(i, 1);
                    return true;
                }
        },
        addOverlay: methodOp(function (spec, options) {
            var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
            if (mode.startState)
                throw new Error('Overlays may not be stateful.');
            this.state.overlays.push({
                mode: mode,
                modeSpec: spec,
                opaque: options && options.opaque
            });
            this.state.modeGen++;
            regChange(this);
        }),
        removeOverlay: methodOp(function (spec) {
            var overlays = this.state.overlays;
            for (var i = 0; i < overlays.length; ++i) {
                var cur = overlays[i].modeSpec;
                if (cur == spec || typeof spec == 'string' && cur.name == spec) {
                    overlays.splice(i, 1);
                    this.state.modeGen++;
                    regChange(this);
                    return;
                }
            }
        }),
        indentLine: methodOp(function (n, dir, aggressive) {
            if (typeof dir != 'string' && typeof dir != 'number') {
                if (dir == null)
                    dir = this.options.smartIndent ? 'smart' : 'prev';
                else
                    dir = dir ? 'add' : 'subtract';
            }
            if (isLine(this.doc, n))
                indentLine(this, n, dir, aggressive);
        }),
        indentSelection: methodOp(function (how) {
            var ranges = this.doc.sel.ranges, end = -1;
            for (var i = 0; i < ranges.length; i++) {
                var range = ranges[i];
                if (!range.empty()) {
                    var from = range.from(), to = range.to();
                    var start = Math.max(end, from.line);
                    end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
                    for (var j = start; j < end; ++j)
                        indentLine(this, j, how);
                    var newRanges = this.doc.sel.ranges;
                    if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
                        replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);
                } else if (range.head.line > end) {
                    indentLine(this, range.head.line, how, true);
                    end = range.head.line;
                    if (i == this.doc.sel.primIndex)
                        ensureCursorVisible(this);
                }
            }
        }),
        getTokenAt: function (pos, precise) {
            return takeToken(this, pos, precise);
        },
        getLineTokens: function (line, precise) {
            return takeToken(this, Pos(line), precise, true);
        },
        getTokenTypeAt: function (pos) {
            pos = clipPos(this.doc, pos);
            var styles = getLineStyles(this, getLine(this.doc, pos.line));
            var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
            var type;
            if (ch == 0)
                type = styles[2];
            else
                for (;;) {
                    var mid = before + after >> 1;
                    if ((mid ? styles[mid * 2 - 1] : 0) >= ch)
                        after = mid;
                    else if (styles[mid * 2 + 1] < ch)
                        before = mid + 1;
                    else {
                        type = styles[mid * 2 + 2];
                        break;
                    }
                }
            var cut = type ? type.indexOf('cm-overlay ') : -1;
            return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);
        },
        getModeAt: function (pos) {
            var mode = this.doc.mode;
            if (!mode.innerMode)
                return mode;
            return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;
        },
        getHelper: function (pos, type) {
            return this.getHelpers(pos, type)[0];
        },
        getHelpers: function (pos, type) {
            var found = [];
            if (!helpers.hasOwnProperty(type))
                return found;
            var help = helpers[type], mode = this.getModeAt(pos);
            if (typeof mode[type] == 'string') {
                if (help[mode[type]])
                    found.push(help[mode[type]]);
            } else if (mode[type]) {
                for (var i = 0; i < mode[type].length; i++) {
                    var val = help[mode[type][i]];
                    if (val)
                        found.push(val);
                }
            } else if (mode.helperType && help[mode.helperType]) {
                found.push(help[mode.helperType]);
            } else if (help[mode.name]) {
                found.push(help[mode.name]);
            }
            for (var i = 0; i < help._global.length; i++) {
                var cur = help._global[i];
                if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)
                    found.push(cur.val);
            }
            return found;
        },
        getStateAfter: function (line, precise) {
            var doc = this.doc;
            line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);
            return getStateBefore(this, line + 1, precise);
        },
        cursorCoords: function (start, mode) {
            var pos, range = this.doc.sel.primary();
            if (start == null)
                pos = range.head;
            else if (typeof start == 'object')
                pos = clipPos(this.doc, start);
            else
                pos = start ? range.from() : range.to();
            return cursorCoords(this, pos, mode || 'page');
        },
        charCoords: function (pos, mode) {
            return charCoords(this, clipPos(this.doc, pos), mode || 'page');
        },
        coordsChar: function (coords, mode) {
            coords = fromCoordSystem(this, coords, mode || 'page');
            return coordsChar(this, coords.left, coords.top);
        },
        lineAtHeight: function (height, mode) {
            height = fromCoordSystem(this, {
                top: height,
                left: 0
            }, mode || 'page').top;
            return lineAtHeight(this.doc, height + this.display.viewOffset);
        },
        heightAtLine: function (line, mode) {
            var end = false, lineObj;
            if (typeof line == 'number') {
                var last = this.doc.first + this.doc.size - 1;
                if (line < this.doc.first)
                    line = this.doc.first;
                else if (line > last) {
                    line = last;
                    end = true;
                }
                lineObj = getLine(this.doc, line);
            } else {
                lineObj = line;
            }
            return intoCoordSystem(this, lineObj, {
                top: 0,
                left: 0
            }, mode || 'page').top + (end ? this.doc.height - heightAtLine(lineObj) : 0);
        },
        defaultTextHeight: function () {
            return textHeight(this.display);
        },
        defaultCharWidth: function () {
            return charWidth(this.display);
        },
        setGutterMarker: methodOp(function (line, gutterID, value) {
            return changeLine(this.doc, line, 'gutter', function (line) {
                var markers = line.gutterMarkers || (line.gutterMarkers = {});
                markers[gutterID] = value;
                if (!value && isEmpty(markers))
                    line.gutterMarkers = null;
                return true;
            });
        }),
        clearGutter: methodOp(function (gutterID) {
            var cm = this, doc = cm.doc, i = doc.first;
            doc.iter(function (line) {
                if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
                    line.gutterMarkers[gutterID] = null;
                    regLineChange(cm, i, 'gutter');
                    if (isEmpty(line.gutterMarkers))
                        line.gutterMarkers = null;
                }
                ++i;
            });
        }),
        lineInfo: function (line) {
            if (typeof line == 'number') {
                if (!isLine(this.doc, line))
                    return null;
                var n = line;
                line = getLine(this.doc, line);
                if (!line)
                    return null;
            } else {
                var n = lineNo(line);
                if (n == null)
                    return null;
            }
            return {
                line: n,
                handle: line,
                text: line.text,
                gutterMarkers: line.gutterMarkers,
                textClass: line.textClass,
                bgClass: line.bgClass,
                wrapClass: line.wrapClass,
                widgets: line.widgets
            };
        },
        getViewport: function () {
            return {
                from: this.display.viewFrom,
                to: this.display.viewTo
            };
        },
        addWidget: function (pos, node, scroll, vert, horiz) {
            var display = this.display;
            pos = cursorCoords(this, clipPos(this.doc, pos));
            var top = pos.bottom, left = pos.left;
            node.style.position = 'absolute';
            node.setAttribute('cm-ignore-events', 'true');
            this.display.input.setUneditable(node);
            display.sizer.appendChild(node);
            if (vert == 'over') {
                top = pos.top;
            } else if (vert == 'above' || vert == 'near') {
                var vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
                if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
                    top = pos.top - node.offsetHeight;
                else if (pos.bottom + node.offsetHeight <= vspace)
                    top = pos.bottom;
                if (left + node.offsetWidth > hspace)
                    left = hspace - node.offsetWidth;
            }
            node.style.top = top + 'px';
            node.style.left = node.style.right = '';
            if (horiz == 'right') {
                left = display.sizer.clientWidth - node.offsetWidth;
                node.style.right = '0px';
            } else {
                if (horiz == 'left')
                    left = 0;
                else if (horiz == 'middle')
                    left = (display.sizer.clientWidth - node.offsetWidth) / 2;
                node.style.left = left + 'px';
            }
            if (scroll)
                scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);
        },
        triggerOnKeyDown: methodOp(onKeyDown),
        triggerOnKeyPress: methodOp(onKeyPress),
        triggerOnKeyUp: onKeyUp,
        execCommand: function (cmd) {
            if (commands.hasOwnProperty(cmd))
                return commands[cmd](this);
        },
        findPosH: function (from, amount, unit, visually) {
            var dir = 1;
            if (amount < 0) {
                dir = -1;
                amount = -amount;
            }
            for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
                cur = findPosH(this.doc, cur, dir, unit, visually);
                if (cur.hitSide)
                    break;
            }
            return cur;
        },
        moveH: methodOp(function (dir, unit) {
            var cm = this;
            cm.extendSelectionsBy(function (range) {
                if (cm.display.shift || cm.doc.extend || range.empty())
                    return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);
                else
                    return dir < 0 ? range.from() : range.to();
            }, sel_move);
        }),
        deleteH: methodOp(function (dir, unit) {
            var sel = this.doc.sel, doc = this.doc;
            if (sel.somethingSelected())
                doc.replaceSelection('', null, '+delete');
            else
                deleteNearSelection(this, function (range) {
                    var other = findPosH(doc, range.head, dir, unit, false);
                    return dir < 0 ? {
                        from: other,
                        to: range.head
                    } : {
                        from: range.head,
                        to: other
                    };
                });
        }),
        findPosV: function (from, amount, unit, goalColumn) {
            var dir = 1, x = goalColumn;
            if (amount < 0) {
                dir = -1;
                amount = -amount;
            }
            for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {
                var coords = cursorCoords(this, cur, 'div');
                if (x == null)
                    x = coords.left;
                else
                    coords.left = x;
                cur = findPosV(this, coords, dir, unit);
                if (cur.hitSide)
                    break;
            }
            return cur;
        },
        moveV: methodOp(function (dir, unit) {
            var cm = this, doc = this.doc, goals = [];
            var collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();
            doc.extendSelectionsBy(function (range) {
                if (collapse)
                    return dir < 0 ? range.from() : range.to();
                var headPos = cursorCoords(cm, range.head, 'div');
                if (range.goalColumn != null)
                    headPos.left = range.goalColumn;
                goals.push(headPos.left);
                var pos = findPosV(cm, headPos, dir, unit);
                if (unit == 'page' && range == doc.sel.primary())
                    addToScrollPos(cm, null, charCoords(cm, pos, 'div').top - headPos.top);
                return pos;
            }, sel_move);
            if (goals.length)
                for (var i = 0; i < doc.sel.ranges.length; i++)
                    doc.sel.ranges[i].goalColumn = goals[i];
        }),
        findWordAt: function (pos) {
            var doc = this.doc, line = getLine(doc, pos.line).text;
            var start = pos.ch, end = pos.ch;
            if (line) {
                var helper = this.getHelper(pos, 'wordChars');
                if ((pos.xRel < 0 || end == line.length) && start)
                    --start;
                else
                    ++end;
                var startChar = line.charAt(start);
                var check = isWordChar(startChar, helper) ? function (ch) {
                    return isWordChar(ch, helper);
                } : /\s/.test(startChar) ? function (ch) {
                    return /\s/.test(ch);
                } : function (ch) {
                    return !/\s/.test(ch) && !isWordChar(ch);
                };
                while (start > 0 && check(line.charAt(start - 1)))
                    --start;
                while (end < line.length && check(line.charAt(end)))
                    ++end;
            }
            return new Range(Pos(pos.line, start), Pos(pos.line, end));
        },
        toggleOverwrite: function (value) {
            if (value != null && value == this.state.overwrite)
                return;
            if (this.state.overwrite = !this.state.overwrite)
                addClass(this.display.cursorDiv, 'CodeMirror-overwrite');
            else
                rmClass(this.display.cursorDiv, 'CodeMirror-overwrite');
            signal(this, 'overwriteToggle', this, this.state.overwrite);
        },
        hasFocus: function () {
            return this.display.input.getField() == activeElt();
        },
        scrollTo: methodOp(function (x, y) {
            if (x != null || y != null)
                resolveScrollToPos(this);
            if (x != null)
                this.curOp.scrollLeft = x;
            if (y != null)
                this.curOp.scrollTop = y;
        }),
        getScrollInfo: function () {
            var scroller = this.display.scroller;
            return {
                left: scroller.scrollLeft,
                top: scroller.scrollTop,
                height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
                width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
                clientHeight: displayHeight(this),
                clientWidth: displayWidth(this)
            };
        },
        scrollIntoView: methodOp(function (range, margin) {
            if (range == null) {
                range = {
                    from: this.doc.sel.primary().head,
                    to: null
                };
                if (margin == null)
                    margin = this.options.cursorScrollMargin;
            } else if (typeof range == 'number') {
                range = {
                    from: Pos(range, 0),
                    to: null
                };
            } else if (range.from == null) {
                range = {
                    from: range,
                    to: null
                };
            }
            if (!range.to)
                range.to = range.from;
            range.margin = margin || 0;
            if (range.from.line != null) {
                resolveScrollToPos(this);
                this.curOp.scrollToPos = range;
            } else {
                var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left), Math.min(range.from.top, range.to.top) - range.margin, Math.max(range.from.right, range.to.right), Math.max(range.from.bottom, range.to.bottom) + range.margin);
                this.scrollTo(sPos.scrollLeft, sPos.scrollTop);
            }
        }),
        setSize: methodOp(function (width, height) {
            var cm = this;
            function interpret(val) {
                return typeof val == 'number' || /^\d+$/.test(String(val)) ? val + 'px' : val;
            }
            if (width != null)
                cm.display.wrapper.style.width = interpret(width);
            if (height != null)
                cm.display.wrapper.style.height = interpret(height);
            if (cm.options.lineWrapping)
                clearLineMeasurementCache(this);
            var lineNo = cm.display.viewFrom;
            cm.doc.iter(lineNo, cm.display.viewTo, function (line) {
                if (line.widgets)
                    for (var i = 0; i < line.widgets.length; i++)
                        if (line.widgets[i].noHScroll) {
                            regLineChange(cm, lineNo, 'widget');
                            break;
                        }
                ++lineNo;
            });
            cm.curOp.forceUpdate = true;
            signal(cm, 'refresh', this);
        }),
        operation: function (f) {
            return runInOp(this, f);
        },
        refresh: methodOp(function () {
            var oldHeight = this.display.cachedTextHeight;
            regChange(this);
            this.curOp.forceUpdate = true;
            clearCaches(this);
            this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);
            updateGutterSpace(this);
            if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > 0.5)
                estimateLineHeights(this);
            signal(this, 'refresh', this);
        }),
        swapDoc: methodOp(function (doc) {
            var old = this.doc;
            old.cm = null;
            attachDoc(this, doc);
            clearCaches(this);
            this.display.input.reset();
            this.scrollTo(doc.scrollLeft, doc.scrollTop);
            this.curOp.forceScroll = true;
            signalLater(this, 'swapDoc', this, old);
            return old;
        }),
        getInputField: function () {
            return this.display.input.getField();
        },
        getWrapperElement: function () {
            return this.display.wrapper;
        },
        getScrollerElement: function () {
            return this.display.scroller;
        },
        getGutterElement: function () {
            return this.display.gutters;
        }
    };
    eventMixin(CodeMirror);
    var defaults = CodeMirror.defaults = {};
    var optionHandlers = CodeMirror.optionHandlers = {};
    function option(name, deflt, handle, notOnInit) {
        CodeMirror.defaults[name] = deflt;
        if (handle)
            optionHandlers[name] = notOnInit ? function (cm, val, old) {
                if (old != Init)
                    handle(cm, val, old);
            } : handle;
    }
    var Init = CodeMirror.Init = {
        toString: function () {
            return 'CodeMirror.Init';
        }
    };
    option('value', '', function (cm, val) {
        cm.setValue(val);
    }, true);
    option('mode', null, function (cm, val) {
        cm.doc.modeOption = val;
        loadMode(cm);
    }, true);
    option('indentUnit', 2, loadMode, true);
    option('indentWithTabs', false);
    option('smartIndent', true);
    option('tabSize', 4, function (cm) {
        resetModeState(cm);
        clearCaches(cm);
        regChange(cm);
    }, true);
    option('specialChars', /[\t\u0000-\u0019\u00ad\u200b-\u200f\u2028\u2029\ufeff]/g, function (cm, val, old) {
        cm.state.specialChars = new RegExp(val.source + (val.test('\t') ? '' : '|\t'), 'g');
        if (old != CodeMirror.Init)
            cm.refresh();
    });
    option('specialCharPlaceholder', defaultSpecialCharPlaceholder, function (cm) {
        cm.refresh();
    }, true);
    option('electricChars', true);
    option('inputStyle', mobile ? 'contenteditable' : 'textarea', function () {
        throw new Error('inputStyle can not (yet) be changed in a running editor');
    }, true);
    option('rtlMoveVisually', !windows);
    option('wholeLineUpdateBefore', true);
    option('theme', 'default', function (cm) {
        themeChanged(cm);
        guttersChanged(cm);
    }, true);
    option('keyMap', 'default', function (cm, val, old) {
        var next = getKeyMap(val);
        var prev = old != CodeMirror.Init && getKeyMap(old);
        if (prev && prev.detach)
            prev.detach(cm, next);
        if (next.attach)
            next.attach(cm, prev || null);
    });
    option('extraKeys', null);
    option('lineWrapping', false, wrappingChanged, true);
    option('gutters', [], function (cm) {
        setGuttersForLineNumbers(cm.options);
        guttersChanged(cm);
    }, true);
    option('fixedGutter', true, function (cm, val) {
        cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + 'px' : '0';
        cm.refresh();
    }, true);
    option('coverGutterNextToScrollbar', false, function (cm) {
        updateScrollbars(cm);
    }, true);
    option('scrollbarStyle', 'native', function (cm) {
        initScrollbars(cm);
        updateScrollbars(cm);
        cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
        cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
    }, true);
    option('lineNumbers', false, function (cm) {
        setGuttersForLineNumbers(cm.options);
        guttersChanged(cm);
    }, true);
    option('firstLineNumber', 1, guttersChanged, true);
    option('lineNumberFormatter', function (integer) {
        return integer;
    }, guttersChanged, true);
    option('showCursorWhenSelecting', false, updateSelection, true);
    option('resetSelectionOnContextMenu', true);
    option('lineWiseCopyCut', true);
    option('readOnly', false, function (cm, val) {
        if (val == 'nocursor') {
            onBlur(cm);
            cm.display.input.blur();
            cm.display.disabled = true;
        } else {
            cm.display.disabled = false;
            if (!val)
                cm.display.input.reset();
        }
    });
    option('disableInput', false, function (cm, val) {
        if (!val)
            cm.display.input.reset();
    }, true);
    option('dragDrop', true, dragDropChanged);
    option('cursorBlinkRate', 530);
    option('cursorScrollMargin', 0);
    option('cursorHeight', 1, updateSelection, true);
    option('singleCursorHeightPerLine', true, updateSelection, true);
    option('workTime', 100);
    option('workDelay', 100);
    option('flattenSpans', true, resetModeState, true);
    option('addModeClass', false, resetModeState, true);
    option('pollInterval', 100);
    option('undoDepth', 200, function (cm, val) {
        cm.doc.history.undoDepth = val;
    });
    option('historyEventDelay', 1250);
    option('viewportMargin', 10, function (cm) {
        cm.refresh();
    }, true);
    option('maxHighlightLength', 10000, resetModeState, true);
    option('moveInputWithCursor', true, function (cm, val) {
        if (!val)
            cm.display.input.resetPosition();
    });
    option('tabindex', null, function (cm, val) {
        cm.display.input.getField().tabIndex = val || '';
    });
    option('autofocus', null);
    var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};
    CodeMirror.defineMode = function (name, mode) {
        if (!CodeMirror.defaults.mode && name != 'null')
            CodeMirror.defaults.mode = name;
        if (arguments.length > 2)
            mode.dependencies = Array.prototype.slice.call(arguments, 2);
        modes[name] = mode;
    };
    CodeMirror.defineMIME = function (mime, spec) {
        mimeModes[mime] = spec;
    };
    CodeMirror.resolveMode = function (spec) {
        if (typeof spec == 'string' && mimeModes.hasOwnProperty(spec)) {
            spec = mimeModes[spec];
        } else if (spec && typeof spec.name == 'string' && mimeModes.hasOwnProperty(spec.name)) {
            var found = mimeModes[spec.name];
            if (typeof found == 'string')
                found = { name: found };
            spec = createObj(found, spec);
            spec.name = found.name;
        } else if (typeof spec == 'string' && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
            return CodeMirror.resolveMode('application/xml');
        }
        if (typeof spec == 'string')
            return { name: spec };
        else
            return spec || { name: 'null' };
    };
    CodeMirror.getMode = function (options, spec) {
        var spec = CodeMirror.resolveMode(spec);
        var mfactory = modes[spec.name];
        if (!mfactory)
            return CodeMirror.getMode(options, 'text/plain');
        var modeObj = mfactory(options, spec);
        if (modeExtensions.hasOwnProperty(spec.name)) {
            var exts = modeExtensions[spec.name];
            for (var prop in exts) {
                if (!exts.hasOwnProperty(prop))
                    continue;
                if (modeObj.hasOwnProperty(prop))
                    modeObj['_' + prop] = modeObj[prop];
                modeObj[prop] = exts[prop];
            }
        }
        modeObj.name = spec.name;
        if (spec.helperType)
            modeObj.helperType = spec.helperType;
        if (spec.modeProps)
            for (var prop in spec.modeProps)
                modeObj[prop] = spec.modeProps[prop];
        return modeObj;
    };
    CodeMirror.defineMode('null', function () {
        return {
            token: function (stream) {
                stream.skipToEnd();
            }
        };
    });
    CodeMirror.defineMIME('text/plain', 'null');
    var modeExtensions = CodeMirror.modeExtensions = {};
    CodeMirror.extendMode = function (mode, properties) {
        var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
        copyObj(properties, exts);
    };
    CodeMirror.defineExtension = function (name, func) {
        CodeMirror.prototype[name] = func;
    };
    CodeMirror.defineDocExtension = function (name, func) {
        Doc.prototype[name] = func;
    };
    CodeMirror.defineOption = option;
    var initHooks = [];
    CodeMirror.defineInitHook = function (f) {
        initHooks.push(f);
    };
    var helpers = CodeMirror.helpers = {};
    CodeMirror.registerHelper = function (type, name, value) {
        if (!helpers.hasOwnProperty(type))
            helpers[type] = CodeMirror[type] = { _global: [] };
        helpers[type][name] = value;
    };
    CodeMirror.registerGlobalHelper = function (type, name, predicate, value) {
        CodeMirror.registerHelper(type, name, value);
        helpers[type]._global.push({
            pred: predicate,
            val: value
        });
    };
    var copyState = CodeMirror.copyState = function (mode, state) {
        if (state === true)
            return state;
        if (mode.copyState)
            return mode.copyState(state);
        var nstate = {};
        for (var n in state) {
            var val = state[n];
            if (val instanceof Array)
                val = val.concat([]);
            nstate[n] = val;
        }
        return nstate;
    };
    var startState = CodeMirror.startState = function (mode, a1, a2) {
        return mode.startState ? mode.startState(a1, a2) : true;
    };
    CodeMirror.innerMode = function (mode, state) {
        while (mode.innerMode) {
            var info = mode.innerMode(state);
            if (!info || info.mode == mode)
                break;
            state = info.state;
            mode = info.mode;
        }
        return info || {
            mode: mode,
            state: state
        };
    };
    var commands = CodeMirror.commands = {
        selectAll: function (cm) {
            cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
        },
        singleSelection: function (cm) {
            cm.setSelection(cm.getCursor('anchor'), cm.getCursor('head'), sel_dontScroll);
        },
        killLine: function (cm) {
            deleteNearSelection(cm, function (range) {
                if (range.empty()) {
                    var len = getLine(cm.doc, range.head.line).text.length;
                    if (range.head.ch == len && range.head.line < cm.lastLine())
                        return {
                            from: range.head,
                            to: Pos(range.head.line + 1, 0)
                        };
                    else
                        return {
                            from: range.head,
                            to: Pos(range.head.line, len)
                        };
                } else {
                    return {
                        from: range.from(),
                        to: range.to()
                    };
                }
            });
        },
        deleteLine: function (cm) {
            deleteNearSelection(cm, function (range) {
                return {
                    from: Pos(range.from().line, 0),
                    to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
                };
            });
        },
        delLineLeft: function (cm) {
            deleteNearSelection(cm, function (range) {
                return {
                    from: Pos(range.from().line, 0),
                    to: range.from()
                };
            });
        },
        delWrappedLineLeft: function (cm) {
            deleteNearSelection(cm, function (range) {
                var top = cm.charCoords(range.head, 'div').top + 5;
                var leftPos = cm.coordsChar({
                    left: 0,
                    top: top
                }, 'div');
                return {
                    from: leftPos,
                    to: range.from()
                };
            });
        },
        delWrappedLineRight: function (cm) {
            deleteNearSelection(cm, function (range) {
                var top = cm.charCoords(range.head, 'div').top + 5;
                var rightPos = cm.coordsChar({
                    left: cm.display.lineDiv.offsetWidth + 100,
                    top: top
                }, 'div');
                return {
                    from: range.from(),
                    to: rightPos
                };
            });
        },
        undo: function (cm) {
            cm.undo();
        },
        redo: function (cm) {
            cm.redo();
        },
        undoSelection: function (cm) {
            cm.undoSelection();
        },
        redoSelection: function (cm) {
            cm.redoSelection();
        },
        goDocStart: function (cm) {
            cm.extendSelection(Pos(cm.firstLine(), 0));
        },
        goDocEnd: function (cm) {
            cm.extendSelection(Pos(cm.lastLine()));
        },
        goLineStart: function (cm) {
            cm.extendSelectionsBy(function (range) {
                return lineStart(cm, range.head.line);
            }, {
                origin: '+move',
                bias: 1
            });
        },
        goLineStartSmart: function (cm) {
            cm.extendSelectionsBy(function (range) {
                return lineStartSmart(cm, range.head);
            }, {
                origin: '+move',
                bias: 1
            });
        },
        goLineEnd: function (cm) {
            cm.extendSelectionsBy(function (range) {
                return lineEnd(cm, range.head.line);
            }, {
                origin: '+move',
                bias: -1
            });
        },
        goLineRight: function (cm) {
            cm.extendSelectionsBy(function (range) {
                var top = cm.charCoords(range.head, 'div').top + 5;
                return cm.coordsChar({
                    left: cm.display.lineDiv.offsetWidth + 100,
                    top: top
                }, 'div');
            }, sel_move);
        },
        goLineLeft: function (cm) {
            cm.extendSelectionsBy(function (range) {
                var top = cm.charCoords(range.head, 'div').top + 5;
                return cm.coordsChar({
                    left: 0,
                    top: top
                }, 'div');
            }, sel_move);
        },
        goLineLeftSmart: function (cm) {
            cm.extendSelectionsBy(function (range) {
                var top = cm.charCoords(range.head, 'div').top + 5;
                var pos = cm.coordsChar({
                    left: 0,
                    top: top
                }, 'div');
                if (pos.ch < cm.getLine(pos.line).search(/\S/))
                    return lineStartSmart(cm, range.head);
                return pos;
            }, sel_move);
        },
        goLineUp: function (cm) {
            cm.moveV(-1, 'line');
        },
        goLineDown: function (cm) {
            cm.moveV(1, 'line');
        },
        goPageUp: function (cm) {
            cm.moveV(-1, 'page');
        },
        goPageDown: function (cm) {
            cm.moveV(1, 'page');
        },
        goCharLeft: function (cm) {
            cm.moveH(-1, 'char');
        },
        goCharRight: function (cm) {
            cm.moveH(1, 'char');
        },
        goColumnLeft: function (cm) {
            cm.moveH(-1, 'column');
        },
        goColumnRight: function (cm) {
            cm.moveH(1, 'column');
        },
        goWordLeft: function (cm) {
            cm.moveH(-1, 'word');
        },
        goGroupRight: function (cm) {
            cm.moveH(1, 'group');
        },
        goGroupLeft: function (cm) {
            cm.moveH(-1, 'group');
        },
        goWordRight: function (cm) {
            cm.moveH(1, 'word');
        },
        delCharBefore: function (cm) {
            cm.deleteH(-1, 'char');
        },
        delCharAfter: function (cm) {
            cm.deleteH(1, 'char');
        },
        delWordBefore: function (cm) {
            cm.deleteH(-1, 'word');
        },
        delWordAfter: function (cm) {
            cm.deleteH(1, 'word');
        },
        delGroupBefore: function (cm) {
            cm.deleteH(-1, 'group');
        },
        delGroupAfter: function (cm) {
            cm.deleteH(1, 'group');
        },
        indentAuto: function (cm) {
            cm.indentSelection('smart');
        },
        indentMore: function (cm) {
            cm.indentSelection('add');
        },
        indentLess: function (cm) {
            cm.indentSelection('subtract');
        },
        insertTab: function (cm) {
            cm.replaceSelection('\t');
        },
        insertSoftTab: function (cm) {
            var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
            for (var i = 0; i < ranges.length; i++) {
                var pos = ranges[i].from();
                var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
                spaces.push(new Array(tabSize - col % tabSize + 1).join(' '));
            }
            cm.replaceSelections(spaces);
        },
        defaultTab: function (cm) {
            if (cm.somethingSelected())
                cm.indentSelection('add');
            else
                cm.execCommand('insertTab');
        },
        transposeChars: function (cm) {
            runInOp(cm, function () {
                var ranges = cm.listSelections(), newSel = [];
                for (var i = 0; i < ranges.length; i++) {
                    var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
                    if (line) {
                        if (cur.ch == line.length)
                            cur = new Pos(cur.line, cur.ch - 1);
                        if (cur.ch > 0) {
                            cur = new Pos(cur.line, cur.ch + 1);
                            cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, '+transpose');
                        } else if (cur.line > cm.doc.first) {
                            var prev = getLine(cm.doc, cur.line - 1).text;
                            if (prev)
                                cm.replaceRange(line.charAt(0) + '\n' + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), '+transpose');
                        }
                    }
                    newSel.push(new Range(cur, cur));
                }
                cm.setSelections(newSel);
            });
        },
        newlineAndIndent: function (cm) {
            runInOp(cm, function () {
                var len = cm.listSelections().length;
                for (var i = 0; i < len; i++) {
                    var range = cm.listSelections()[i];
                    cm.replaceRange('\n', range.anchor, range.head, '+input');
                    cm.indentLine(range.from().line + 1, null, true);
                    ensureCursorVisible(cm);
                }
            });
        },
        toggleOverwrite: function (cm) {
            cm.toggleOverwrite();
        }
    };
    var keyMap = CodeMirror.keyMap = {};
    keyMap.basic = {
        'Left': 'goCharLeft',
        'Right': 'goCharRight',
        'Up': 'goLineUp',
        'Down': 'goLineDown',
        'End': 'goLineEnd',
        'Home': 'goLineStartSmart',
        'PageUp': 'goPageUp',
        'PageDown': 'goPageDown',
        'Delete': 'delCharAfter',
        'Backspace': 'delCharBefore',
        'Shift-Backspace': 'delCharBefore',
        'Tab': 'defaultTab',
        'Shift-Tab': 'indentAuto',
        'Enter': 'newlineAndIndent',
        'Insert': 'toggleOverwrite',
        'Esc': 'singleSelection'
    };
    keyMap.pcDefault = {
        'Ctrl-A': 'selectAll',
        'Ctrl-D': 'deleteLine',
        'Ctrl-Z': 'undo',
        'Shift-Ctrl-Z': 'redo',
        'Ctrl-Y': 'redo',
        'Ctrl-Home': 'goDocStart',
        'Ctrl-End': 'goDocEnd',
        'Ctrl-Up': 'goLineUp',
        'Ctrl-Down': 'goLineDown',
        'Ctrl-Left': 'goGroupLeft',
        'Ctrl-Right': 'goGroupRight',
        'Alt-Left': 'goLineStart',
        'Alt-Right': 'goLineEnd',
        'Ctrl-Backspace': 'delGroupBefore',
        'Ctrl-Delete': 'delGroupAfter',
        'Ctrl-S': 'save',
        'Ctrl-F': 'find',
        'Ctrl-G': 'findNext',
        'Shift-Ctrl-G': 'findPrev',
        'Shift-Ctrl-F': 'replace',
        'Shift-Ctrl-R': 'replaceAll',
        'Ctrl-[': 'indentLess',
        'Ctrl-]': 'indentMore',
        'Ctrl-U': 'undoSelection',
        'Shift-Ctrl-U': 'redoSelection',
        'Alt-U': 'redoSelection',
        fallthrough: 'basic'
    };
    keyMap.emacsy = {
        'Ctrl-F': 'goCharRight',
        'Ctrl-B': 'goCharLeft',
        'Ctrl-P': 'goLineUp',
        'Ctrl-N': 'goLineDown',
        'Alt-F': 'goWordRight',
        'Alt-B': 'goWordLeft',
        'Ctrl-A': 'goLineStart',
        'Ctrl-E': 'goLineEnd',
        'Ctrl-V': 'goPageDown',
        'Shift-Ctrl-V': 'goPageUp',
        'Ctrl-D': 'delCharAfter',
        'Ctrl-H': 'delCharBefore',
        'Alt-D': 'delWordAfter',
        'Alt-Backspace': 'delWordBefore',
        'Ctrl-K': 'killLine',
        'Ctrl-T': 'transposeChars'
    };
    keyMap.macDefault = {
        'Cmd-A': 'selectAll',
        'Cmd-D': 'deleteLine',
        'Cmd-Z': 'undo',
        'Shift-Cmd-Z': 'redo',
        'Cmd-Y': 'redo',
        'Cmd-Home': 'goDocStart',
        'Cmd-Up': 'goDocStart',
        'Cmd-End': 'goDocEnd',
        'Cmd-Down': 'goDocEnd',
        'Alt-Left': 'goGroupLeft',
        'Alt-Right': 'goGroupRight',
        'Cmd-Left': 'goLineLeft',
        'Cmd-Right': 'goLineRight',
        'Alt-Backspace': 'delGroupBefore',
        'Ctrl-Alt-Backspace': 'delGroupAfter',
        'Alt-Delete': 'delGroupAfter',
        'Cmd-S': 'save',
        'Cmd-F': 'find',
        'Cmd-G': 'findNext',
        'Shift-Cmd-G': 'findPrev',
        'Cmd-Alt-F': 'replace',
        'Shift-Cmd-Alt-F': 'replaceAll',
        'Cmd-[': 'indentLess',
        'Cmd-]': 'indentMore',
        'Cmd-Backspace': 'delWrappedLineLeft',
        'Cmd-Delete': 'delWrappedLineRight',
        'Cmd-U': 'undoSelection',
        'Shift-Cmd-U': 'redoSelection',
        'Ctrl-Up': 'goDocStart',
        'Ctrl-Down': 'goDocEnd',
        fallthrough: [
            'basic',
            'emacsy'
        ]
    };
    keyMap['default'] = mac ? keyMap.macDefault : keyMap.pcDefault;
    function normalizeKeyName(name) {
        var parts = name.split(/-(?!$)/), name = parts[parts.length - 1];
        var alt, ctrl, shift, cmd;
        for (var i = 0; i < parts.length - 1; i++) {
            var mod = parts[i];
            if (/^(cmd|meta|m)$/i.test(mod))
                cmd = true;
            else if (/^a(lt)?$/i.test(mod))
                alt = true;
            else if (/^(c|ctrl|control)$/i.test(mod))
                ctrl = true;
            else if (/^s(hift)$/i.test(mod))
                shift = true;
            else
                throw new Error('Unrecognized modifier name: ' + mod);
        }
        if (alt)
            name = 'Alt-' + name;
        if (ctrl)
            name = 'Ctrl-' + name;
        if (cmd)
            name = 'Cmd-' + name;
        if (shift)
            name = 'Shift-' + name;
        return name;
    }
    CodeMirror.normalizeKeyMap = function (keymap) {
        var copy = {};
        for (var keyname in keymap)
            if (keymap.hasOwnProperty(keyname)) {
                var value = keymap[keyname];
                if (/^(name|fallthrough|(de|at)tach)$/.test(keyname))
                    continue;
                if (value == '...') {
                    delete keymap[keyname];
                    continue;
                }
                var keys = map(keyname.split(' '), normalizeKeyName);
                for (var i = 0; i < keys.length; i++) {
                    var val, name;
                    if (i == keys.length - 1) {
                        name = keyname;
                        val = value;
                    } else {
                        name = keys.slice(0, i + 1).join(' ');
                        val = '...';
                    }
                    var prev = copy[name];
                    if (!prev)
                        copy[name] = val;
                    else if (prev != val)
                        throw new Error('Inconsistent bindings for ' + name);
                }
                delete keymap[keyname];
            }
        for (var prop in copy)
            keymap[prop] = copy[prop];
        return keymap;
    };
    var lookupKey = CodeMirror.lookupKey = function (key, map, handle, context) {
        map = getKeyMap(map);
        var found = map.call ? map.call(key, context) : map[key];
        if (found === false)
            return 'nothing';
        if (found === '...')
            return 'multi';
        if (found != null && handle(found))
            return 'handled';
        if (map.fallthrough) {
            if (Object.prototype.toString.call(map.fallthrough) != '[object Array]')
                return lookupKey(key, map.fallthrough, handle, context);
            for (var i = 0; i < map.fallthrough.length; i++) {
                var result = lookupKey(key, map.fallthrough[i], handle, context);
                if (result)
                    return result;
            }
        }
    };
    var isModifierKey = CodeMirror.isModifierKey = function (value) {
        var name = typeof value == 'string' ? value : keyNames[value.keyCode];
        return name == 'Ctrl' || name == 'Alt' || name == 'Shift' || name == 'Mod';
    };
    var keyName = CodeMirror.keyName = function (event, noShift) {
        if (presto && event.keyCode == 34 && event['char'])
            return false;
        var base = keyNames[event.keyCode], name = base;
        if (name == null || event.altGraphKey)
            return false;
        if (event.altKey && base != 'Alt')
            name = 'Alt-' + name;
        if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != 'Ctrl')
            name = 'Ctrl-' + name;
        if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != 'Cmd')
            name = 'Cmd-' + name;
        if (!noShift && event.shiftKey && base != 'Shift')
            name = 'Shift-' + name;
        return name;
    };
    function getKeyMap(val) {
        return typeof val == 'string' ? keyMap[val] : val;
    }
    CodeMirror.fromTextArea = function (textarea, options) {
        options = options ? copyObj(options) : {};
        options.value = textarea.value;
        if (!options.tabindex && textarea.tabIndex)
            options.tabindex = textarea.tabIndex;
        if (!options.placeholder && textarea.placeholder)
            options.placeholder = textarea.placeholder;
        if (options.autofocus == null) {
            var hasFocus = activeElt();
            options.autofocus = hasFocus == textarea || textarea.getAttribute('autofocus') != null && hasFocus == document.body;
        }
        function save() {
            textarea.value = cm.getValue();
        }
        if (textarea.form) {
            on(textarea.form, 'submit', save);
            if (!options.leaveSubmitMethodAlone) {
                var form = textarea.form, realSubmit = form.submit;
                try {
                    var wrappedSubmit = form.submit = function () {
                        save();
                        form.submit = realSubmit;
                        form.submit();
                        form.submit = wrappedSubmit;
                    };
                } catch (e) {
                }
            }
        }
        options.finishInit = function (cm) {
            cm.save = save;
            cm.getTextArea = function () {
                return textarea;
            };
            cm.toTextArea = function () {
                cm.toTextArea = isNaN;
                save();
                textarea.parentNode.removeChild(cm.getWrapperElement());
                textarea.style.display = '';
                if (textarea.form) {
                    off(textarea.form, 'submit', save);
                    if (typeof textarea.form.submit == 'function')
                        textarea.form.submit = realSubmit;
                }
            };
        };
        textarea.style.display = 'none';
        var cm = CodeMirror(function (node) {
            textarea.parentNode.insertBefore(node, textarea.nextSibling);
        }, options);
        return cm;
    };
    var StringStream = CodeMirror.StringStream = function (string, tabSize) {
        this.pos = this.start = 0;
        this.string = string;
        this.tabSize = tabSize || 8;
        this.lastColumnPos = this.lastColumnValue = 0;
        this.lineStart = 0;
    };
    StringStream.prototype = {
        eol: function () {
            return this.pos >= this.string.length;
        },
        sol: function () {
            return this.pos == this.lineStart;
        },
        peek: function () {
            return this.string.charAt(this.pos) || undefined;
        },
        next: function () {
            if (this.pos < this.string.length)
                return this.string.charAt(this.pos++);
        },
        eat: function (match) {
            var ch = this.string.charAt(this.pos);
            if (typeof match == 'string')
                var ok = ch == match;
            else
                var ok = ch && (match.test ? match.test(ch) : match(ch));
            if (ok) {
                ++this.pos;
                return ch;
            }
        },
        eatWhile: function (match) {
            var start = this.pos;
            while (this.eat(match)) {
            }
            return this.pos > start;
        },
        eatSpace: function () {
            var start = this.pos;
            while (/[\s\u00a0]/.test(this.string.charAt(this.pos)))
                ++this.pos;
            return this.pos > start;
        },
        skipToEnd: function () {
            this.pos = this.string.length;
        },
        skipTo: function (ch) {
            var found = this.string.indexOf(ch, this.pos);
            if (found > -1) {
                this.pos = found;
                return true;
            }
        },
        backUp: function (n) {
            this.pos -= n;
        },
        column: function () {
            if (this.lastColumnPos < this.start) {
                this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
                this.lastColumnPos = this.start;
            }
            return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
        },
        indentation: function () {
            return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
        },
        match: function (pattern, consume, caseInsensitive) {
            if (typeof pattern == 'string') {
                var cased = function (str) {
                    return caseInsensitive ? str.toLowerCase() : str;
                };
                var substr = this.string.substr(this.pos, pattern.length);
                if (cased(substr) == cased(pattern)) {
                    if (consume !== false)
                        this.pos += pattern.length;
                    return true;
                }
            } else {
                var match = this.string.slice(this.pos).match(pattern);
                if (match && match.index > 0)
                    return null;
                if (match && consume !== false)
                    this.pos += match[0].length;
                return match;
            }
        },
        current: function () {
            return this.string.slice(this.start, this.pos);
        },
        hideFirstChars: function (n, inner) {
            this.lineStart += n;
            try {
                return inner();
            } finally {
                this.lineStart -= n;
            }
        }
    };
    var nextMarkerId = 0;
    var TextMarker = CodeMirror.TextMarker = function (doc, type) {
        this.lines = [];
        this.type = type;
        this.doc = doc;
        this.id = ++nextMarkerId;
    };
    eventMixin(TextMarker);
    TextMarker.prototype.clear = function () {
        if (this.explicitlyCleared)
            return;
        var cm = this.doc.cm, withOp = cm && !cm.curOp;
        if (withOp)
            startOperation(cm);
        if (hasHandler(this, 'clear')) {
            var found = this.find();
            if (found)
                signalLater(this, 'clear', found.from, found.to);
        }
        var min = null, max = null;
        for (var i = 0; i < this.lines.length; ++i) {
            var line = this.lines[i];
            var span = getMarkedSpanFor(line.markedSpans, this);
            if (cm && !this.collapsed)
                regLineChange(cm, lineNo(line), 'text');
            else if (cm) {
                if (span.to != null)
                    max = lineNo(line);
                if (span.from != null)
                    min = lineNo(line);
            }
            line.markedSpans = removeMarkedSpan(line.markedSpans, span);
            if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)
                updateLineHeight(line, textHeight(cm.display));
        }
        if (cm && this.collapsed && !cm.options.lineWrapping)
            for (var i = 0; i < this.lines.length; ++i) {
                var visual = visualLine(this.lines[i]), len = lineLength(visual);
                if (len > cm.display.maxLineLength) {
                    cm.display.maxLine = visual;
                    cm.display.maxLineLength = len;
                    cm.display.maxLineChanged = true;
                }
            }
        if (min != null && cm && this.collapsed)
            regChange(cm, min, max + 1);
        this.lines.length = 0;
        this.explicitlyCleared = true;
        if (this.atomic && this.doc.cantEdit) {
            this.doc.cantEdit = false;
            if (cm)
                reCheckSelection(cm.doc);
        }
        if (cm)
            signalLater(cm, 'markerCleared', cm, this);
        if (withOp)
            endOperation(cm);
        if (this.parent)
            this.parent.clear();
    };
    TextMarker.prototype.find = function (side, lineObj) {
        if (side == null && this.type == 'bookmark')
            side = 1;
        var from, to;
        for (var i = 0; i < this.lines.length; ++i) {
            var line = this.lines[i];
            var span = getMarkedSpanFor(line.markedSpans, this);
            if (span.from != null) {
                from = Pos(lineObj ? line : lineNo(line), span.from);
                if (side == -1)
                    return from;
            }
            if (span.to != null) {
                to = Pos(lineObj ? line : lineNo(line), span.to);
                if (side == 1)
                    return to;
            }
        }
        return from && {
            from: from,
            to: to
        };
    };
    TextMarker.prototype.changed = function () {
        var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
        if (!pos || !cm)
            return;
        runInOp(cm, function () {
            var line = pos.line, lineN = lineNo(pos.line);
            var view = findViewForLine(cm, lineN);
            if (view) {
                clearLineMeasurementCacheFor(view);
                cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
            }
            cm.curOp.updateMaxLine = true;
            if (!lineIsHidden(widget.doc, line) && widget.height != null) {
                var oldHeight = widget.height;
                widget.height = null;
                var dHeight = widgetHeight(widget) - oldHeight;
                if (dHeight)
                    updateLineHeight(line, line.height + dHeight);
            }
        });
    };
    TextMarker.prototype.attachLine = function (line) {
        if (!this.lines.length && this.doc.cm) {
            var op = this.doc.cm.curOp;
            if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
                (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
        }
        this.lines.push(line);
    };
    TextMarker.prototype.detachLine = function (line) {
        this.lines.splice(indexOf(this.lines, line), 1);
        if (!this.lines.length && this.doc.cm) {
            var op = this.doc.cm.curOp;
            (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
        }
    };
    var nextMarkerId = 0;
    function markText(doc, from, to, options, type) {
        if (options && options.shared)
            return markTextShared(doc, from, to, options, type);
        if (doc.cm && !doc.cm.curOp)
            return operation(doc.cm, markText)(doc, from, to, options, type);
        var marker = new TextMarker(doc, type), diff = cmp(from, to);
        if (options)
            copyObj(options, marker, false);
        if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
            return marker;
        if (marker.replacedWith) {
            marker.collapsed = true;
            marker.widgetNode = elt('span', [marker.replacedWith], 'CodeMirror-widget');
            if (!options.handleMouseEvents)
                marker.widgetNode.setAttribute('cm-ignore-events', 'true');
            if (options.insertLeft)
                marker.widgetNode.insertLeft = true;
        }
        if (marker.collapsed) {
            if (conflictingCollapsedRange(doc, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
                throw new Error('Inserting collapsed marker partially overlapping an existing one');
            sawCollapsedSpans = true;
        }
        if (marker.addToHistory)
            addChangeToHistory(doc, {
                from: from,
                to: to,
                origin: 'markText'
            }, doc.sel, NaN);
        var curLine = from.line, cm = doc.cm, updateMaxLine;
        doc.iter(curLine, to.line + 1, function (line) {
            if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
                updateMaxLine = true;
            if (marker.collapsed && curLine != from.line)
                updateLineHeight(line, 0);
            addMarkedSpan(line, new MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null));
            ++curLine;
        });
        if (marker.collapsed)
            doc.iter(from.line, to.line + 1, function (line) {
                if (lineIsHidden(doc, line))
                    updateLineHeight(line, 0);
            });
        if (marker.clearOnEnter)
            on(marker, 'beforeCursorEnter', function () {
                marker.clear();
            });
        if (marker.readOnly) {
            sawReadOnlySpans = true;
            if (doc.history.done.length || doc.history.undone.length)
                doc.clearHistory();
        }
        if (marker.collapsed) {
            marker.id = ++nextMarkerId;
            marker.atomic = true;
        }
        if (cm) {
            if (updateMaxLine)
                cm.curOp.updateMaxLine = true;
            if (marker.collapsed)
                regChange(cm, from.line, to.line + 1);
            else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)
                for (var i = from.line; i <= to.line; i++)
                    regLineChange(cm, i, 'text');
            if (marker.atomic)
                reCheckSelection(cm.doc);
            signalLater(cm, 'markerAdded', cm, marker);
        }
        return marker;
    }
    var SharedTextMarker = CodeMirror.SharedTextMarker = function (markers, primary) {
        this.markers = markers;
        this.primary = primary;
        for (var i = 0; i < markers.length; ++i)
            markers[i].parent = this;
    };
    eventMixin(SharedTextMarker);
    SharedTextMarker.prototype.clear = function () {
        if (this.explicitlyCleared)
            return;
        this.explicitlyCleared = true;
        for (var i = 0; i < this.markers.length; ++i)
            this.markers[i].clear();
        signalLater(this, 'clear');
    };
    SharedTextMarker.prototype.find = function (side, lineObj) {
        return this.primary.find(side, lineObj);
    };
    function markTextShared(doc, from, to, options, type) {
        options = copyObj(options);
        options.shared = false;
        var markers = [markText(doc, from, to, options, type)], primary = markers[0];
        var widget = options.widgetNode;
        linkedDocs(doc, function (doc) {
            if (widget)
                options.widgetNode = widget.cloneNode(true);
            markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
            for (var i = 0; i < doc.linked.length; ++i)
                if (doc.linked[i].isParent)
                    return;
            primary = lst(markers);
        });
        return new SharedTextMarker(markers, primary);
    }
    function findSharedMarkers(doc) {
        return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) {
            return m.parent;
        });
    }
    function copySharedMarkers(doc, markers) {
        for (var i = 0; i < markers.length; i++) {
            var marker = markers[i], pos = marker.find();
            var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
            if (cmp(mFrom, mTo)) {
                var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
                marker.markers.push(subMark);
                subMark.parent = marker;
            }
        }
    }
    function detachSharedMarkers(markers) {
        for (var i = 0; i < markers.length; i++) {
            var marker = markers[i], linked = [marker.primary.doc];
            ;
            linkedDocs(marker.primary.doc, function (d) {
                linked.push(d);
            });
            for (var j = 0; j < marker.markers.length; j++) {
                var subMarker = marker.markers[j];
                if (indexOf(linked, subMarker.doc) == -1) {
                    subMarker.parent = null;
                    marker.markers.splice(j--, 1);
                }
            }
        }
    }
    function MarkedSpan(marker, from, to) {
        this.marker = marker;
        this.from = from;
        this.to = to;
    }
    function getMarkedSpanFor(spans, marker) {
        if (spans)
            for (var i = 0; i < spans.length; ++i) {
                var span = spans[i];
                if (span.marker == marker)
                    return span;
            }
    }
    function removeMarkedSpan(spans, span) {
        for (var r, i = 0; i < spans.length; ++i)
            if (spans[i] != span)
                (r || (r = [])).push(spans[i]);
        return r;
    }
    function addMarkedSpan(line, span) {
        line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
        span.marker.attachLine(line);
    }
    function markedSpansBefore(old, startCh, isInsert) {
        if (old)
            for (var i = 0, nw; i < old.length; ++i) {
                var span = old[i], marker = span.marker;
                var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
                if (startsBefore || span.from == startCh && marker.type == 'bookmark' && (!isInsert || !span.marker.insertLeft)) {
                    var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
                    (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
                }
            }
        return nw;
    }
    function markedSpansAfter(old, endCh, isInsert) {
        if (old)
            for (var i = 0, nw; i < old.length; ++i) {
                var span = old[i], marker = span.marker;
                var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
                if (endsAfter || span.from == endCh && marker.type == 'bookmark' && (!isInsert || span.marker.insertLeft)) {
                    var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
                    (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, span.to == null ? null : span.to - endCh));
                }
            }
        return nw;
    }
    function stretchSpansOverChange(doc, change) {
        if (change.full)
            return null;
        var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
        var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
        if (!oldFirst && !oldLast)
            return null;
        var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
        var first = markedSpansBefore(oldFirst, startCh, isInsert);
        var last = markedSpansAfter(oldLast, endCh, isInsert);
        var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
        if (first) {
            for (var i = 0; i < first.length; ++i) {
                var span = first[i];
                if (span.to == null) {
                    var found = getMarkedSpanFor(last, span.marker);
                    if (!found)
                        span.to = startCh;
                    else if (sameLine)
                        span.to = found.to == null ? null : found.to + offset;
                }
            }
        }
        if (last) {
            for (var i = 0; i < last.length; ++i) {
                var span = last[i];
                if (span.to != null)
                    span.to += offset;
                if (span.from == null) {
                    var found = getMarkedSpanFor(first, span.marker);
                    if (!found) {
                        span.from = offset;
                        if (sameLine)
                            (first || (first = [])).push(span);
                    }
                } else {
                    span.from += offset;
                    if (sameLine)
                        (first || (first = [])).push(span);
                }
            }
        }
        if (first)
            first = clearEmptySpans(first);
        if (last && last != first)
            last = clearEmptySpans(last);
        var newMarkers = [first];
        if (!sameLine) {
            var gap = change.text.length - 2, gapMarkers;
            if (gap > 0 && first)
                for (var i = 0; i < first.length; ++i)
                    if (first[i].to == null)
                        (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));
            for (var i = 0; i < gap; ++i)
                newMarkers.push(gapMarkers);
            newMarkers.push(last);
        }
        return newMarkers;
    }
    function clearEmptySpans(spans) {
        for (var i = 0; i < spans.length; ++i) {
            var span = spans[i];
            if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
                spans.splice(i--, 1);
        }
        if (!spans.length)
            return null;
        return spans;
    }
    function mergeOldSpans(doc, change) {
        var old = getOldSpans(doc, change);
        var stretched = stretchSpansOverChange(doc, change);
        if (!old)
            return stretched;
        if (!stretched)
            return old;
        for (var i = 0; i < old.length; ++i) {
            var oldCur = old[i], stretchCur = stretched[i];
            if (oldCur && stretchCur) {
                spans:
                    for (var j = 0; j < stretchCur.length; ++j) {
                        var span = stretchCur[j];
                        for (var k = 0; k < oldCur.length; ++k)
                            if (oldCur[k].marker == span.marker)
                                continue spans;
                        oldCur.push(span);
                    }
            } else if (stretchCur) {
                old[i] = stretchCur;
            }
        }
        return old;
    }
    function removeReadOnlyRanges(doc, from, to) {
        var markers = null;
        doc.iter(from.line, to.line + 1, function (line) {
            if (line.markedSpans)
                for (var i = 0; i < line.markedSpans.length; ++i) {
                    var mark = line.markedSpans[i].marker;
                    if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
                        (markers || (markers = [])).push(mark);
                }
        });
        if (!markers)
            return null;
        var parts = [{
                from: from,
                to: to
            }];
        for (var i = 0; i < markers.length; ++i) {
            var mk = markers[i], m = mk.find(0);
            for (var j = 0; j < parts.length; ++j) {
                var p = parts[j];
                if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0)
                    continue;
                var newParts = [
                        j,
                        1
                    ], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
                if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
                    newParts.push({
                        from: p.from,
                        to: m.from
                    });
                if (dto > 0 || !mk.inclusiveRight && !dto)
                    newParts.push({
                        from: m.to,
                        to: p.to
                    });
                parts.splice.apply(parts, newParts);
                j += newParts.length - 1;
            }
        }
        return parts;
    }
    function detachMarkedSpans(line) {
        var spans = line.markedSpans;
        if (!spans)
            return;
        for (var i = 0; i < spans.length; ++i)
            spans[i].marker.detachLine(line);
        line.markedSpans = null;
    }
    function attachMarkedSpans(line, spans) {
        if (!spans)
            return;
        for (var i = 0; i < spans.length; ++i)
            spans[i].marker.attachLine(line);
        line.markedSpans = spans;
    }
    function extraLeft(marker) {
        return marker.inclusiveLeft ? -1 : 0;
    }
    function extraRight(marker) {
        return marker.inclusiveRight ? 1 : 0;
    }
    function compareCollapsedMarkers(a, b) {
        var lenDiff = a.lines.length - b.lines.length;
        if (lenDiff != 0)
            return lenDiff;
        var aPos = a.find(), bPos = b.find();
        var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
        if (fromCmp)
            return -fromCmp;
        var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
        if (toCmp)
            return toCmp;
        return b.id - a.id;
    }
    function collapsedSpanAtSide(line, start) {
        var sps = sawCollapsedSpans && line.markedSpans, found;
        if (sps)
            for (var sp, i = 0; i < sps.length; ++i) {
                sp = sps[i];
                if (sp.marker.collapsed && (start ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0))
                    found = sp.marker;
            }
        return found;
    }
    function collapsedSpanAtStart(line) {
        return collapsedSpanAtSide(line, true);
    }
    function collapsedSpanAtEnd(line) {
        return collapsedSpanAtSide(line, false);
    }
    function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
        var line = getLine(doc, lineNo);
        var sps = sawCollapsedSpans && line.markedSpans;
        if (sps)
            for (var i = 0; i < sps.length; ++i) {
                var sp = sps[i];
                if (!sp.marker.collapsed)
                    continue;
                var found = sp.marker.find(0);
                var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
                var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
                if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0)
                    continue;
                if (fromCmp <= 0 && (cmp(found.to, from) > 0 || sp.marker.inclusiveRight && marker.inclusiveLeft) || fromCmp >= 0 && (cmp(found.from, to) < 0 || sp.marker.inclusiveLeft && marker.inclusiveRight))
                    return true;
            }
    }
    function visualLine(line) {
        var merged;
        while (merged = collapsedSpanAtStart(line))
            line = merged.find(-1, true).line;
        return line;
    }
    function visualLineContinued(line) {
        var merged, lines;
        while (merged = collapsedSpanAtEnd(line)) {
            line = merged.find(1, true).line;
            (lines || (lines = [])).push(line);
        }
        return lines;
    }
    function visualLineNo(doc, lineN) {
        var line = getLine(doc, lineN), vis = visualLine(line);
        if (line == vis)
            return lineN;
        return lineNo(vis);
    }
    function visualLineEndNo(doc, lineN) {
        if (lineN > doc.lastLine())
            return lineN;
        var line = getLine(doc, lineN), merged;
        if (!lineIsHidden(doc, line))
            return lineN;
        while (merged = collapsedSpanAtEnd(line))
            line = merged.find(1, true).line;
        return lineNo(line) + 1;
    }
    function lineIsHidden(doc, line) {
        var sps = sawCollapsedSpans && line.markedSpans;
        if (sps)
            for (var sp, i = 0; i < sps.length; ++i) {
                sp = sps[i];
                if (!sp.marker.collapsed)
                    continue;
                if (sp.from == null)
                    return true;
                if (sp.marker.widgetNode)
                    continue;
                if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
                    return true;
            }
    }
    function lineIsHiddenInner(doc, line, span) {
        if (span.to == null) {
            var end = span.marker.find(1, true);
            return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
        }
        if (span.marker.inclusiveRight && span.to == line.text.length)
            return true;
        for (var sp, i = 0; i < line.markedSpans.length; ++i) {
            sp = line.markedSpans[i];
            if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp))
                return true;
        }
    }
    var LineWidget = CodeMirror.LineWidget = function (doc, node, options) {
        if (options)
            for (var opt in options)
                if (options.hasOwnProperty(opt))
                    this[opt] = options[opt];
        this.doc = doc;
        this.node = node;
    };
    eventMixin(LineWidget);
    function adjustScrollWhenAboveVisible(cm, line, diff) {
        if (heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop))
            addToScrollPos(cm, null, diff);
    }
    LineWidget.prototype.clear = function () {
        var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
        if (no == null || !ws)
            return;
        for (var i = 0; i < ws.length; ++i)
            if (ws[i] == this)
                ws.splice(i--, 1);
        if (!ws.length)
            line.widgets = null;
        var height = widgetHeight(this);
        updateLineHeight(line, Math.max(0, line.height - height));
        if (cm)
            runInOp(cm, function () {
                adjustScrollWhenAboveVisible(cm, line, -height);
                regLineChange(cm, no, 'widget');
            });
    };
    LineWidget.prototype.changed = function () {
        var oldH = this.height, cm = this.doc.cm, line = this.line;
        this.height = null;
        var diff = widgetHeight(this) - oldH;
        if (!diff)
            return;
        updateLineHeight(line, line.height + diff);
        if (cm)
            runInOp(cm, function () {
                cm.curOp.forceUpdate = true;
                adjustScrollWhenAboveVisible(cm, line, diff);
            });
    };
    function widgetHeight(widget) {
        if (widget.height != null)
            return widget.height;
        var cm = widget.doc.cm;
        if (!cm)
            return 0;
        if (!contains(document.body, widget.node)) {
            var parentStyle = 'position: relative;';
            if (widget.coverGutter)
                parentStyle += 'margin-left: -' + cm.display.gutters.offsetWidth + 'px;';
            if (widget.noHScroll)
                parentStyle += 'width: ' + cm.display.wrapper.clientWidth + 'px;';
            removeChildrenAndAdd(cm.display.measure, elt('div', [widget.node], null, parentStyle));
        }
        return widget.height = widget.node.offsetHeight;
    }
    function addLineWidget(doc, handle, node, options) {
        var widget = new LineWidget(doc, node, options);
        var cm = doc.cm;
        if (cm && widget.noHScroll)
            cm.display.alignWidgets = true;
        changeLine(doc, handle, 'widget', function (line) {
            var widgets = line.widgets || (line.widgets = []);
            if (widget.insertAt == null)
                widgets.push(widget);
            else
                widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);
            widget.line = line;
            if (cm && !lineIsHidden(doc, line)) {
                var aboveVisible = heightAtLine(line) < doc.scrollTop;
                updateLineHeight(line, line.height + widgetHeight(widget));
                if (aboveVisible)
                    addToScrollPos(cm, null, widget.height);
                cm.curOp.forceUpdate = true;
            }
            return true;
        });
        return widget;
    }
    var Line = CodeMirror.Line = function (text, markedSpans, estimateHeight) {
        this.text = text;
        attachMarkedSpans(this, markedSpans);
        this.height = estimateHeight ? estimateHeight(this) : 1;
    };
    eventMixin(Line);
    Line.prototype.lineNo = function () {
        return lineNo(this);
    };
    function updateLine(line, text, markedSpans, estimateHeight) {
        line.text = text;
        if (line.stateAfter)
            line.stateAfter = null;
        if (line.styles)
            line.styles = null;
        if (line.order != null)
            line.order = null;
        detachMarkedSpans(line);
        attachMarkedSpans(line, markedSpans);
        var estHeight = estimateHeight ? estimateHeight(line) : 1;
        if (estHeight != line.height)
            updateLineHeight(line, estHeight);
    }
    function cleanUpLine(line) {
        line.parent = null;
        detachMarkedSpans(line);
    }
    function extractLineClasses(type, output) {
        if (type)
            for (;;) {
                var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
                if (!lineClass)
                    break;
                type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
                var prop = lineClass[1] ? 'bgClass' : 'textClass';
                if (output[prop] == null)
                    output[prop] = lineClass[2];
                else if (!new RegExp('(?:^|s)' + lineClass[2] + '(?:$|s)').test(output[prop]))
                    output[prop] += ' ' + lineClass[2];
            }
        return type;
    }
    function callBlankLine(mode, state) {
        if (mode.blankLine)
            return mode.blankLine(state);
        if (!mode.innerMode)
            return;
        var inner = CodeMirror.innerMode(mode, state);
        if (inner.mode.blankLine)
            return inner.mode.blankLine(inner.state);
    }
    function readToken(mode, stream, state, inner) {
        for (var i = 0; i < 10; i++) {
            if (inner)
                inner[0] = CodeMirror.innerMode(mode, state).mode;
            var style = mode.token(stream, state);
            if (stream.pos > stream.start)
                return style;
        }
        throw new Error('Mode ' + mode.name + ' failed to advance stream.');
    }
    function takeToken(cm, pos, precise, asArray) {
        function getObj(copy) {
            return {
                start: stream.start,
                end: stream.pos,
                string: stream.current(),
                type: style || null,
                state: copy ? copyState(doc.mode, state) : state
            };
        }
        var doc = cm.doc, mode = doc.mode, style;
        pos = clipPos(doc, pos);
        var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise);
        var stream = new StringStream(line.text, cm.options.tabSize), tokens;
        if (asArray)
            tokens = [];
        while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
            stream.start = stream.pos;
            style = readToken(mode, stream, state);
            if (asArray)
                tokens.push(getObj(true));
        }
        return asArray ? tokens : getObj();
    }
    function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {
        var flattenSpans = mode.flattenSpans;
        if (flattenSpans == null)
            flattenSpans = cm.options.flattenSpans;
        var curStart = 0, curStyle = null;
        var stream = new StringStream(text, cm.options.tabSize), style;
        var inner = cm.options.addModeClass && [null];
        if (text == '')
            extractLineClasses(callBlankLine(mode, state), lineClasses);
        while (!stream.eol()) {
            if (stream.pos > cm.options.maxHighlightLength) {
                flattenSpans = false;
                if (forceToEnd)
                    processLine(cm, text, state, stream.pos);
                stream.pos = text.length;
                style = null;
            } else {
                style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);
            }
            if (inner) {
                var mName = inner[0].name;
                if (mName)
                    style = 'm-' + (style ? mName + ' ' + style : mName);
            }
            if (!flattenSpans || curStyle != style) {
                while (curStart < stream.start) {
                    curStart = Math.min(stream.start, curStart + 50000);
                    f(curStart, curStyle);
                }
                curStyle = style;
            }
            stream.start = stream.pos;
        }
        while (curStart < stream.pos) {
            var pos = Math.min(stream.pos, curStart + 50000);
            f(pos, curStyle);
            curStart = pos;
        }
    }
    function highlightLine(cm, line, state, forceToEnd) {
        var st = [cm.state.modeGen], lineClasses = {};
        runMode(cm, line.text, cm.doc.mode, state, function (end, style) {
            st.push(end, style);
        }, lineClasses, forceToEnd);
        for (var o = 0; o < cm.state.overlays.length; ++o) {
            var overlay = cm.state.overlays[o], i = 1, at = 0;
            runMode(cm, line.text, overlay.mode, true, function (end, style) {
                var start = i;
                while (at < end) {
                    var i_end = st[i];
                    if (i_end > end)
                        st.splice(i, 1, end, st[i + 1], i_end);
                    i += 2;
                    at = Math.min(end, i_end);
                }
                if (!style)
                    return;
                if (overlay.opaque) {
                    st.splice(start, i - start, end, 'cm-overlay ' + style);
                    i = start + 2;
                } else {
                    for (; start < i; start += 2) {
                        var cur = st[start + 1];
                        st[start + 1] = (cur ? cur + ' ' : '') + 'cm-overlay ' + style;
                    }
                }
            }, lineClasses);
        }
        return {
            styles: st,
            classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null
        };
    }
    function getLineStyles(cm, line, updateFrontier) {
        if (!line.styles || line.styles[0] != cm.state.modeGen) {
            var result = highlightLine(cm, line, line.stateAfter = getStateBefore(cm, lineNo(line)));
            line.styles = result.styles;
            if (result.classes)
                line.styleClasses = result.classes;
            else if (line.styleClasses)
                line.styleClasses = null;
            if (updateFrontier === cm.doc.frontier)
                cm.doc.frontier++;
        }
        return line.styles;
    }
    function processLine(cm, text, state, startAt) {
        var mode = cm.doc.mode;
        var stream = new StringStream(text, cm.options.tabSize);
        stream.start = stream.pos = startAt || 0;
        if (text == '')
            callBlankLine(mode, state);
        while (!stream.eol() && stream.pos <= cm.options.maxHighlightLength) {
            readToken(mode, stream, state);
            stream.start = stream.pos;
        }
    }
    var styleToClassCache = {}, styleToClassCacheWithMode = {};
    function interpretTokenStyle(style, options) {
        if (!style || /^\s*$/.test(style))
            return null;
        var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
        return cache[style] || (cache[style] = style.replace(/\S+/g, 'cm-$&'));
    }
    function buildLineContent(cm, lineView) {
        var content = elt('span', null, null, webkit ? 'padding-right: .1px' : null);
        var builder = {
            pre: elt('pre', [content]),
            content: content,
            col: 0,
            pos: 0,
            cm: cm,
            splitSpaces: (ie || webkit) && cm.getOption('lineWrapping')
        };
        lineView.measure = {};
        for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
            var line = i ? lineView.rest[i - 1] : lineView.line, order;
            builder.pos = 0;
            builder.addToken = buildToken;
            if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))
                builder.addToken = buildTokenBadBidi(builder.addToken, order);
            builder.map = [];
            var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
            insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
            if (line.styleClasses) {
                if (line.styleClasses.bgClass)
                    builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || '');
                if (line.styleClasses.textClass)
                    builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || '');
            }
            if (builder.map.length == 0)
                builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));
            if (i == 0) {
                lineView.measure.map = builder.map;
                lineView.measure.cache = {};
            } else {
                (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
                (lineView.measure.caches || (lineView.measure.caches = [])).push({});
            }
        }
        if (webkit && /\bcm-tab\b/.test(builder.content.lastChild.className))
            builder.content.className = 'cm-tab-wrap-hack';
        signal(cm, 'renderLine', cm, lineView.line, builder.pre);
        if (builder.pre.className)
            builder.textClass = joinClasses(builder.pre.className, builder.textClass || '');
        return builder;
    }
    function defaultSpecialCharPlaceholder(ch) {
        var token = elt('span', '\u2022', 'cm-invalidchar');
        token.title = '\\u' + ch.charCodeAt(0).toString(16);
        token.setAttribute('aria-label', token.title);
        return token;
    }
    function buildToken(builder, text, style, startStyle, endStyle, title, css) {
        if (!text)
            return;
        var displayText = builder.splitSpaces ? text.replace(/ {3,}/g, splitSpaces) : text;
        var special = builder.cm.state.specialChars, mustWrap = false;
        if (!special.test(text)) {
            builder.col += text.length;
            var content = document.createTextNode(displayText);
            builder.map.push(builder.pos, builder.pos + text.length, content);
            if (ie && ie_version < 9)
                mustWrap = true;
            builder.pos += text.length;
        } else {
            var content = document.createDocumentFragment(), pos = 0;
            while (true) {
                special.lastIndex = pos;
                var m = special.exec(text);
                var skipped = m ? m.index - pos : text.length - pos;
                if (skipped) {
                    var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
                    if (ie && ie_version < 9)
                        content.appendChild(elt('span', [txt]));
                    else
                        content.appendChild(txt);
                    builder.map.push(builder.pos, builder.pos + skipped, txt);
                    builder.col += skipped;
                    builder.pos += skipped;
                }
                if (!m)
                    break;
                pos += skipped + 1;
                if (m[0] == '\t') {
                    var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
                    var txt = content.appendChild(elt('span', spaceStr(tabWidth), 'cm-tab'));
                    txt.setAttribute('role', 'presentation');
                    txt.setAttribute('cm-text', '\t');
                    builder.col += tabWidth;
                } else {
                    var txt = builder.cm.options.specialCharPlaceholder(m[0]);
                    txt.setAttribute('cm-text', m[0]);
                    if (ie && ie_version < 9)
                        content.appendChild(elt('span', [txt]));
                    else
                        content.appendChild(txt);
                    builder.col += 1;
                }
                builder.map.push(builder.pos, builder.pos + 1, txt);
                builder.pos++;
            }
        }
        if (style || startStyle || endStyle || mustWrap || css) {
            var fullStyle = style || '';
            if (startStyle)
                fullStyle += startStyle;
            if (endStyle)
                fullStyle += endStyle;
            var token = elt('span', [content], fullStyle, css);
            if (title)
                token.title = title;
            return builder.content.appendChild(token);
        }
        builder.content.appendChild(content);
    }
    function splitSpaces(old) {
        var out = ' ';
        for (var i = 0; i < old.length - 2; ++i)
            out += i % 2 ? ' ' : '\xA0';
        out += ' ';
        return out;
    }
    function buildTokenBadBidi(inner, order) {
        return function (builder, text, style, startStyle, endStyle, title, css) {
            style = style ? style + ' cm-force-border' : 'cm-force-border';
            var start = builder.pos, end = start + text.length;
            for (;;) {
                for (var i = 0; i < order.length; i++) {
                    var part = order[i];
                    if (part.to > start && part.from <= start)
                        break;
                }
                if (part.to >= end)
                    return inner(builder, text, style, startStyle, endStyle, title, css);
                inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);
                startStyle = null;
                text = text.slice(part.to - start);
                start = part.to;
            }
        };
    }
    function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
        var widget = !ignoreWidget && marker.widgetNode;
        if (widget)
            builder.map.push(builder.pos, builder.pos + size, widget);
        if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
            if (!widget)
                widget = builder.content.appendChild(document.createElement('span'));
            widget.setAttribute('cm-marker', marker.id);
        }
        if (widget) {
            builder.cm.display.input.setUneditable(widget);
            builder.content.appendChild(widget);
        }
        builder.pos += size;
    }
    function insertLineContent(line, builder, styles) {
        var spans = line.markedSpans, allText = line.text, at = 0;
        if (!spans) {
            for (var i = 1; i < styles.length; i += 2)
                builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i + 1], builder.cm.options));
            return;
        }
        var len = allText.length, pos = 0, i = 1, text = '', style, css;
        var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;
        for (;;) {
            if (nextChange == pos) {
                spanStyle = spanEndStyle = spanStartStyle = title = css = '';
                collapsed = null;
                nextChange = Infinity;
                var foundBookmarks = [];
                for (var j = 0; j < spans.length; ++j) {
                    var sp = spans[j], m = sp.marker;
                    if (m.type == 'bookmark' && sp.from == pos && m.widgetNode) {
                        foundBookmarks.push(m);
                    } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
                        if (sp.to != null && sp.to != pos && nextChange > sp.to) {
                            nextChange = sp.to;
                            spanEndStyle = '';
                        }
                        if (m.className)
                            spanStyle += ' ' + m.className;
                        if (m.css)
                            css = m.css;
                        if (m.startStyle && sp.from == pos)
                            spanStartStyle += ' ' + m.startStyle;
                        if (m.endStyle && sp.to == nextChange)
                            spanEndStyle += ' ' + m.endStyle;
                        if (m.title && !title)
                            title = m.title;
                        if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
                            collapsed = sp;
                    } else if (sp.from > pos && nextChange > sp.from) {
                        nextChange = sp.from;
                    }
                }
                if (collapsed && (collapsed.from || 0) == pos) {
                    buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos, collapsed.marker, collapsed.from == null);
                    if (collapsed.to == null)
                        return;
                    if (collapsed.to == pos)
                        collapsed = false;
                }
                if (!collapsed && foundBookmarks.length)
                    for (var j = 0; j < foundBookmarks.length; ++j)
                        buildCollapsedSpan(builder, 0, foundBookmarks[j]);
            }
            if (pos >= len)
                break;
            var upto = Math.min(len, nextChange);
            while (true) {
                if (text) {
                    var end = pos + text.length;
                    if (!collapsed) {
                        var tokenText = end > upto ? text.slice(0, upto - pos) : text;
                        builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : '', title, css);
                    }
                    if (end >= upto) {
                        text = text.slice(upto - pos);
                        pos = upto;
                        break;
                    }
                    pos = end;
                    spanStartStyle = '';
                }
                text = allText.slice(at, at = styles[i++]);
                style = interpretTokenStyle(styles[i++], builder.cm.options);
            }
        }
    }
    function isWholeLineUpdate(doc, change) {
        return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == '' && (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
    }
    function updateDoc(doc, change, markedSpans, estimateHeight) {
        function spansFor(n) {
            return markedSpans ? markedSpans[n] : null;
        }
        function update(line, text, spans) {
            updateLine(line, text, spans, estimateHeight);
            signalLater(line, 'change', line, change);
        }
        function linesFor(start, end) {
            for (var i = start, result = []; i < end; ++i)
                result.push(new Line(text[i], spansFor(i), estimateHeight));
            return result;
        }
        var from = change.from, to = change.to, text = change.text;
        var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
        var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;
        if (change.full) {
            doc.insert(0, linesFor(0, text.length));
            doc.remove(text.length, doc.size - text.length);
        } else if (isWholeLineUpdate(doc, change)) {
            var added = linesFor(0, text.length - 1);
            update(lastLine, lastLine.text, lastSpans);
            if (nlines)
                doc.remove(from.line, nlines);
            if (added.length)
                doc.insert(from.line, added);
        } else if (firstLine == lastLine) {
            if (text.length == 1) {
                update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
            } else {
                var added = linesFor(1, text.length - 1);
                added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
                update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
                doc.insert(from.line + 1, added);
            }
        } else if (text.length == 1) {
            update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
            doc.remove(from.line + 1, nlines);
        } else {
            update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
            update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
            var added = linesFor(1, text.length - 1);
            if (nlines > 1)
                doc.remove(from.line + 1, nlines - 1);
            doc.insert(from.line + 1, added);
        }
        signalLater(doc, 'change', doc, change);
    }
    function LeafChunk(lines) {
        this.lines = lines;
        this.parent = null;
        for (var i = 0, height = 0; i < lines.length; ++i) {
            lines[i].parent = this;
            height += lines[i].height;
        }
        this.height = height;
    }
    LeafChunk.prototype = {
        chunkSize: function () {
            return this.lines.length;
        },
        removeInner: function (at, n) {
            for (var i = at, e = at + n; i < e; ++i) {
                var line = this.lines[i];
                this.height -= line.height;
                cleanUpLine(line);
                signalLater(line, 'delete');
            }
            this.lines.splice(at, n);
        },
        collapse: function (lines) {
            lines.push.apply(lines, this.lines);
        },
        insertInner: function (at, lines, height) {
            this.height += height;
            this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
            for (var i = 0; i < lines.length; ++i)
                lines[i].parent = this;
        },
        iterN: function (at, n, op) {
            for (var e = at + n; at < e; ++at)
                if (op(this.lines[at]))
                    return true;
        }
    };
    function BranchChunk(children) {
        this.children = children;
        var size = 0, height = 0;
        for (var i = 0; i < children.length; ++i) {
            var ch = children[i];
            size += ch.chunkSize();
            height += ch.height;
            ch.parent = this;
        }
        this.size = size;
        this.height = height;
        this.parent = null;
    }
    BranchChunk.prototype = {
        chunkSize: function () {
            return this.size;
        },
        removeInner: function (at, n) {
            this.size -= n;
            for (var i = 0; i < this.children.length; ++i) {
                var child = this.children[i], sz = child.chunkSize();
                if (at < sz) {
                    var rm = Math.min(n, sz - at), oldHeight = child.height;
                    child.removeInner(at, rm);
                    this.height -= oldHeight - child.height;
                    if (sz == rm) {
                        this.children.splice(i--, 1);
                        child.parent = null;
                    }
                    if ((n -= rm) == 0)
                        break;
                    at = 0;
                } else
                    at -= sz;
            }
            if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
                var lines = [];
                this.collapse(lines);
                this.children = [new LeafChunk(lines)];
                this.children[0].parent = this;
            }
        },
        collapse: function (lines) {
            for (var i = 0; i < this.children.length; ++i)
                this.children[i].collapse(lines);
        },
        insertInner: function (at, lines, height) {
            this.size += lines.length;
            this.height += height;
            for (var i = 0; i < this.children.length; ++i) {
                var child = this.children[i], sz = child.chunkSize();
                if (at <= sz) {
                    child.insertInner(at, lines, height);
                    if (child.lines && child.lines.length > 50) {
                        while (child.lines.length > 50) {
                            var spilled = child.lines.splice(child.lines.length - 25, 25);
                            var newleaf = new LeafChunk(spilled);
                            child.height -= newleaf.height;
                            this.children.splice(i + 1, 0, newleaf);
                            newleaf.parent = this;
                        }
                        this.maybeSpill();
                    }
                    break;
                }
                at -= sz;
            }
        },
        maybeSpill: function () {
            if (this.children.length <= 10)
                return;
            var me = this;
            do {
                var spilled = me.children.splice(me.children.length - 5, 5);
                var sibling = new BranchChunk(spilled);
                if (!me.parent) {
                    var copy = new BranchChunk(me.children);
                    copy.parent = me;
                    me.children = [
                        copy,
                        sibling
                    ];
                    me = copy;
                } else {
                    me.size -= sibling.size;
                    me.height -= sibling.height;
                    var myIndex = indexOf(me.parent.children, me);
                    me.parent.children.splice(myIndex + 1, 0, sibling);
                }
                sibling.parent = me.parent;
            } while (me.children.length > 10);
            me.parent.maybeSpill();
        },
        iterN: function (at, n, op) {
            for (var i = 0; i < this.children.length; ++i) {
                var child = this.children[i], sz = child.chunkSize();
                if (at < sz) {
                    var used = Math.min(n, sz - at);
                    if (child.iterN(at, used, op))
                        return true;
                    if ((n -= used) == 0)
                        break;
                    at = 0;
                } else
                    at -= sz;
            }
        }
    };
    var nextDocId = 0;
    var Doc = CodeMirror.Doc = function (text, mode, firstLine) {
        if (!(this instanceof Doc))
            return new Doc(text, mode, firstLine);
        if (firstLine == null)
            firstLine = 0;
        BranchChunk.call(this, [new LeafChunk([new Line('', null)])]);
        this.first = firstLine;
        this.scrollTop = this.scrollLeft = 0;
        this.cantEdit = false;
        this.cleanGeneration = 1;
        this.frontier = firstLine;
        var start = Pos(firstLine, 0);
        this.sel = simpleSelection(start);
        this.history = new History(null);
        this.id = ++nextDocId;
        this.modeOption = mode;
        if (typeof text == 'string')
            text = splitLines(text);
        updateDoc(this, {
            from: start,
            to: start,
            text: text
        });
        setSelection(this, simpleSelection(start), sel_dontScroll);
    };
    Doc.prototype = createObj(BranchChunk.prototype, {
        constructor: Doc,
        iter: function (from, to, op) {
            if (op)
                this.iterN(from - this.first, to - from, op);
            else
                this.iterN(this.first, this.first + this.size, from);
        },
        insert: function (at, lines) {
            var height = 0;
            for (var i = 0; i < lines.length; ++i)
                height += lines[i].height;
            this.insertInner(at - this.first, lines, height);
        },
        remove: function (at, n) {
            this.removeInner(at - this.first, n);
        },
        getValue: function (lineSep) {
            var lines = getLines(this, this.first, this.first + this.size);
            if (lineSep === false)
                return lines;
            return lines.join(lineSep || '\n');
        },
        setValue: docMethodOp(function (code) {
            var top = Pos(this.first, 0), last = this.first + this.size - 1;
            makeChange(this, {
                from: top,
                to: Pos(last, getLine(this, last).text.length),
                text: splitLines(code),
                origin: 'setValue',
                full: true
            }, true);
            setSelection(this, simpleSelection(top));
        }),
        replaceRange: function (code, from, to, origin) {
            from = clipPos(this, from);
            to = to ? clipPos(this, to) : from;
            replaceRange(this, code, from, to, origin);
        },
        getRange: function (from, to, lineSep) {
            var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
            if (lineSep === false)
                return lines;
            return lines.join(lineSep || '\n');
        },
        getLine: function (line) {
            var l = this.getLineHandle(line);
            return l && l.text;
        },
        getLineHandle: function (line) {
            if (isLine(this, line))
                return getLine(this, line);
        },
        getLineNumber: function (line) {
            return lineNo(line);
        },
        getLineHandleVisualStart: function (line) {
            if (typeof line == 'number')
                line = getLine(this, line);
            return visualLine(line);
        },
        lineCount: function () {
            return this.size;
        },
        firstLine: function () {
            return this.first;
        },
        lastLine: function () {
            return this.first + this.size - 1;
        },
        clipPos: function (pos) {
            return clipPos(this, pos);
        },
        getCursor: function (start) {
            var range = this.sel.primary(), pos;
            if (start == null || start == 'head')
                pos = range.head;
            else if (start == 'anchor')
                pos = range.anchor;
            else if (start == 'end' || start == 'to' || start === false)
                pos = range.to();
            else
                pos = range.from();
            return pos;
        },
        listSelections: function () {
            return this.sel.ranges;
        },
        somethingSelected: function () {
            return this.sel.somethingSelected();
        },
        setCursor: docMethodOp(function (line, ch, options) {
            setSimpleSelection(this, clipPos(this, typeof line == 'number' ? Pos(line, ch || 0) : line), null, options);
        }),
        setSelection: docMethodOp(function (anchor, head, options) {
            setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
        }),
        extendSelection: docMethodOp(function (head, other, options) {
            extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
        }),
        extendSelections: docMethodOp(function (heads, options) {
            extendSelections(this, clipPosArray(this, heads, options));
        }),
        extendSelectionsBy: docMethodOp(function (f, options) {
            extendSelections(this, map(this.sel.ranges, f), options);
        }),
        setSelections: docMethodOp(function (ranges, primary, options) {
            if (!ranges.length)
                return;
            for (var i = 0, out = []; i < ranges.length; i++)
                out[i] = new Range(clipPos(this, ranges[i].anchor), clipPos(this, ranges[i].head));
            if (primary == null)
                primary = Math.min(ranges.length - 1, this.sel.primIndex);
            setSelection(this, normalizeSelection(out, primary), options);
        }),
        addSelection: docMethodOp(function (anchor, head, options) {
            var ranges = this.sel.ranges.slice(0);
            ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
            setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);
        }),
        getSelection: function (lineSep) {
            var ranges = this.sel.ranges, lines;
            for (var i = 0; i < ranges.length; i++) {
                var sel = getBetween(this, ranges[i].from(), ranges[i].to());
                lines = lines ? lines.concat(sel) : sel;
            }
            if (lineSep === false)
                return lines;
            else
                return lines.join(lineSep || '\n');
        },
        getSelections: function (lineSep) {
            var parts = [], ranges = this.sel.ranges;
            for (var i = 0; i < ranges.length; i++) {
                var sel = getBetween(this, ranges[i].from(), ranges[i].to());
                if (lineSep !== false)
                    sel = sel.join(lineSep || '\n');
                parts[i] = sel;
            }
            return parts;
        },
        replaceSelection: function (code, collapse, origin) {
            var dup = [];
            for (var i = 0; i < this.sel.ranges.length; i++)
                dup[i] = code;
            this.replaceSelections(dup, collapse, origin || '+input');
        },
        replaceSelections: docMethodOp(function (code, collapse, origin) {
            var changes = [], sel = this.sel;
            for (var i = 0; i < sel.ranges.length; i++) {
                var range = sel.ranges[i];
                changes[i] = {
                    from: range.from(),
                    to: range.to(),
                    text: splitLines(code[i]),
                    origin: origin
                };
            }
            var newSel = collapse && collapse != 'end' && computeReplacedSel(this, changes, collapse);
            for (var i = changes.length - 1; i >= 0; i--)
                makeChange(this, changes[i]);
            if (newSel)
                setSelectionReplaceHistory(this, newSel);
            else if (this.cm)
                ensureCursorVisible(this.cm);
        }),
        undo: docMethodOp(function () {
            makeChangeFromHistory(this, 'undo');
        }),
        redo: docMethodOp(function () {
            makeChangeFromHistory(this, 'redo');
        }),
        undoSelection: docMethodOp(function () {
            makeChangeFromHistory(this, 'undo', true);
        }),
        redoSelection: docMethodOp(function () {
            makeChangeFromHistory(this, 'redo', true);
        }),
        setExtending: function (val) {
            this.extend = val;
        },
        getExtending: function () {
            return this.extend;
        },
        historySize: function () {
            var hist = this.history, done = 0, undone = 0;
            for (var i = 0; i < hist.done.length; i++)
                if (!hist.done[i].ranges)
                    ++done;
            for (var i = 0; i < hist.undone.length; i++)
                if (!hist.undone[i].ranges)
                    ++undone;
            return {
                undo: done,
                redo: undone
            };
        },
        clearHistory: function () {
            this.history = new History(this.history.maxGeneration);
        },
        markClean: function () {
            this.cleanGeneration = this.changeGeneration(true);
        },
        changeGeneration: function (forceSplit) {
            if (forceSplit)
                this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
            return this.history.generation;
        },
        isClean: function (gen) {
            return this.history.generation == (gen || this.cleanGeneration);
        },
        getHistory: function () {
            return {
                done: copyHistoryArray(this.history.done),
                undone: copyHistoryArray(this.history.undone)
            };
        },
        setHistory: function (histData) {
            var hist = this.history = new History(this.history.maxGeneration);
            hist.done = copyHistoryArray(histData.done.slice(0), null, true);
            hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
        },
        addLineClass: docMethodOp(function (handle, where, cls) {
            return changeLine(this, handle, where == 'gutter' ? 'gutter' : 'class', function (line) {
                var prop = where == 'text' ? 'textClass' : where == 'background' ? 'bgClass' : where == 'gutter' ? 'gutterClass' : 'wrapClass';
                if (!line[prop])
                    line[prop] = cls;
                else if (classTest(cls).test(line[prop]))
                    return false;
                else
                    line[prop] += ' ' + cls;
                return true;
            });
        }),
        removeLineClass: docMethodOp(function (handle, where, cls) {
            return changeLine(this, handle, where == 'gutter' ? 'gutter' : 'class', function (line) {
                var prop = where == 'text' ? 'textClass' : where == 'background' ? 'bgClass' : where == 'gutter' ? 'gutterClass' : 'wrapClass';
                var cur = line[prop];
                if (!cur)
                    return false;
                else if (cls == null)
                    line[prop] = null;
                else {
                    var found = cur.match(classTest(cls));
                    if (!found)
                        return false;
                    var end = found.index + found[0].length;
                    line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? '' : ' ') + cur.slice(end) || null;
                }
                return true;
            });
        }),
        addLineWidget: docMethodOp(function (handle, node, options) {
            return addLineWidget(this, handle, node, options);
        }),
        removeLineWidget: function (widget) {
            widget.clear();
        },
        markText: function (from, to, options) {
            return markText(this, clipPos(this, from), clipPos(this, to), options, 'range');
        },
        setBookmark: function (pos, options) {
            var realOpts = {
                replacedWith: options && (options.nodeType == null ? options.widget : options),
                insertLeft: options && options.insertLeft,
                clearWhenEmpty: false,
                shared: options && options.shared,
                handleMouseEvents: options && options.handleMouseEvents
            };
            pos = clipPos(this, pos);
            return markText(this, pos, pos, realOpts, 'bookmark');
        },
        findMarksAt: function (pos) {
            pos = clipPos(this, pos);
            var markers = [], spans = getLine(this, pos.line).markedSpans;
            if (spans)
                for (var i = 0; i < spans.length; ++i) {
                    var span = spans[i];
                    if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch))
                        markers.push(span.marker.parent || span.marker);
                }
            return markers;
        },
        findMarks: function (from, to, filter) {
            from = clipPos(this, from);
            to = clipPos(this, to);
            var found = [], lineNo = from.line;
            this.iter(from.line, to.line + 1, function (line) {
                var spans = line.markedSpans;
                if (spans)
                    for (var i = 0; i < spans.length; i++) {
                        var span = spans[i];
                        if (!(lineNo == from.line && from.ch > span.to || span.from == null && lineNo != from.line || lineNo == to.line && span.from > to.ch) && (!filter || filter(span.marker)))
                            found.push(span.marker.parent || span.marker);
                    }
                ++lineNo;
            });
            return found;
        },
        getAllMarks: function () {
            var markers = [];
            this.iter(function (line) {
                var sps = line.markedSpans;
                if (sps)
                    for (var i = 0; i < sps.length; ++i)
                        if (sps[i].from != null)
                            markers.push(sps[i].marker);
            });
            return markers;
        },
        posFromIndex: function (off) {
            var ch, lineNo = this.first;
            this.iter(function (line) {
                var sz = line.text.length + 1;
                if (sz > off) {
                    ch = off;
                    return true;
                }
                off -= sz;
                ++lineNo;
            });
            return clipPos(this, Pos(lineNo, ch));
        },
        indexFromPos: function (coords) {
            coords = clipPos(this, coords);
            var index = coords.ch;
            if (coords.line < this.first || coords.ch < 0)
                return 0;
            this.iter(this.first, coords.line, function (line) {
                index += line.text.length + 1;
            });
            return index;
        },
        copy: function (copyHistory) {
            var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first);
            doc.scrollTop = this.scrollTop;
            doc.scrollLeft = this.scrollLeft;
            doc.sel = this.sel;
            doc.extend = false;
            if (copyHistory) {
                doc.history.undoDepth = this.history.undoDepth;
                doc.setHistory(this.getHistory());
            }
            return doc;
        },
        linkedDoc: function (options) {
            if (!options)
                options = {};
            var from = this.first, to = this.first + this.size;
            if (options.from != null && options.from > from)
                from = options.from;
            if (options.to != null && options.to < to)
                to = options.to;
            var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from);
            if (options.sharedHist)
                copy.history = this.history;
            (this.linked || (this.linked = [])).push({
                doc: copy,
                sharedHist: options.sharedHist
            });
            copy.linked = [{
                    doc: this,
                    isParent: true,
                    sharedHist: options.sharedHist
                }];
            copySharedMarkers(copy, findSharedMarkers(this));
            return copy;
        },
        unlinkDoc: function (other) {
            if (other instanceof CodeMirror)
                other = other.doc;
            if (this.linked)
                for (var i = 0; i < this.linked.length; ++i) {
                    var link = this.linked[i];
                    if (link.doc != other)
                        continue;
                    this.linked.splice(i, 1);
                    other.unlinkDoc(this);
                    detachSharedMarkers(findSharedMarkers(this));
                    break;
                }
            if (other.history == this.history) {
                var splitIds = [other.id];
                linkedDocs(other, function (doc) {
                    splitIds.push(doc.id);
                }, true);
                other.history = new History(null);
                other.history.done = copyHistoryArray(this.history.done, splitIds);
                other.history.undone = copyHistoryArray(this.history.undone, splitIds);
            }
        },
        iterLinkedDocs: function (f) {
            linkedDocs(this, f);
        },
        getMode: function () {
            return this.mode;
        },
        getEditor: function () {
            return this.cm;
        }
    });
    Doc.prototype.eachLine = Doc.prototype.iter;
    var dontDelegate = 'iter insert remove copy getEditor'.split(' ');
    for (var prop in Doc.prototype)
        if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
            CodeMirror.prototype[prop] = function (method) {
                return function () {
                    return method.apply(this.doc, arguments);
                };
            }(Doc.prototype[prop]);
    eventMixin(Doc);
    function linkedDocs(doc, f, sharedHistOnly) {
        function propagate(doc, skip, sharedHist) {
            if (doc.linked)
                for (var i = 0; i < doc.linked.length; ++i) {
                    var rel = doc.linked[i];
                    if (rel.doc == skip)
                        continue;
                    var shared = sharedHist && rel.sharedHist;
                    if (sharedHistOnly && !shared)
                        continue;
                    f(rel.doc, shared);
                    propagate(rel.doc, doc, shared);
                }
        }
        propagate(doc, null, true);
    }
    function attachDoc(cm, doc) {
        if (doc.cm)
            throw new Error('This document is already in use.');
        cm.doc = doc;
        doc.cm = cm;
        estimateLineHeights(cm);
        loadMode(cm);
        if (!cm.options.lineWrapping)
            findMaxLine(cm);
        cm.options.mode = doc.modeOption;
        regChange(cm);
    }
    function getLine(doc, n) {
        n -= doc.first;
        if (n < 0 || n >= doc.size)
            throw new Error('There is no line ' + (n + doc.first) + ' in the document.');
        for (var chunk = doc; !chunk.lines;) {
            for (var i = 0;; ++i) {
                var child = chunk.children[i], sz = child.chunkSize();
                if (n < sz) {
                    chunk = child;
                    break;
                }
                n -= sz;
            }
        }
        return chunk.lines[n];
    }
    function getBetween(doc, start, end) {
        var out = [], n = start.line;
        doc.iter(start.line, end.line + 1, function (line) {
            var text = line.text;
            if (n == end.line)
                text = text.slice(0, end.ch);
            if (n == start.line)
                text = text.slice(start.ch);
            out.push(text);
            ++n;
        });
        return out;
    }
    function getLines(doc, from, to) {
        var out = [];
        doc.iter(from, to, function (line) {
            out.push(line.text);
        });
        return out;
    }
    function updateLineHeight(line, height) {
        var diff = height - line.height;
        if (diff)
            for (var n = line; n; n = n.parent)
                n.height += diff;
    }
    function lineNo(line) {
        if (line.parent == null)
            return null;
        var cur = line.parent, no = indexOf(cur.lines, line);
        for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
            for (var i = 0;; ++i) {
                if (chunk.children[i] == cur)
                    break;
                no += chunk.children[i].chunkSize();
            }
        }
        return no + cur.first;
    }
    function lineAtHeight(chunk, h) {
        var n = chunk.first;
        outer:
            do {
                for (var i = 0; i < chunk.children.length; ++i) {
                    var child = chunk.children[i], ch = child.height;
                    if (h < ch) {
                        chunk = child;
                        continue outer;
                    }
                    h -= ch;
                    n += child.chunkSize();
                }
                return n;
            } while (!chunk.lines);
        for (var i = 0; i < chunk.lines.length; ++i) {
            var line = chunk.lines[i], lh = line.height;
            if (h < lh)
                break;
            h -= lh;
        }
        return n + i;
    }
    function heightAtLine(lineObj) {
        lineObj = visualLine(lineObj);
        var h = 0, chunk = lineObj.parent;
        for (var i = 0; i < chunk.lines.length; ++i) {
            var line = chunk.lines[i];
            if (line == lineObj)
                break;
            else
                h += line.height;
        }
        for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
            for (var i = 0; i < p.children.length; ++i) {
                var cur = p.children[i];
                if (cur == chunk)
                    break;
                else
                    h += cur.height;
            }
        }
        return h;
    }
    function getOrder(line) {
        var order = line.order;
        if (order == null)
            order = line.order = bidiOrdering(line.text);
        return order;
    }
    function History(startGen) {
        this.done = [];
        this.undone = [];
        this.undoDepth = Infinity;
        this.lastModTime = this.lastSelTime = 0;
        this.lastOp = this.lastSelOp = null;
        this.lastOrigin = this.lastSelOrigin = null;
        this.generation = this.maxGeneration = startGen || 1;
    }
    function historyChangeFromChange(doc, change) {
        var histChange = {
            from: copyPos(change.from),
            to: changeEnd(change),
            text: getBetween(doc, change.from, change.to)
        };
        attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
        linkedDocs(doc, function (doc) {
            attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
        }, true);
        return histChange;
    }
    function clearSelectionEvents(array) {
        while (array.length) {
            var last = lst(array);
            if (last.ranges)
                array.pop();
            else
                break;
        }
    }
    function lastChangeEvent(hist, force) {
        if (force) {
            clearSelectionEvents(hist.done);
            return lst(hist.done);
        } else if (hist.done.length && !lst(hist.done).ranges) {
            return lst(hist.done);
        } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
            hist.done.pop();
            return lst(hist.done);
        }
    }
    function addChangeToHistory(doc, change, selAfter, opId) {
        var hist = doc.history;
        hist.undone.length = 0;
        var time = +new Date(), cur;
        if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == '+' && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay || change.origin.charAt(0) == '*')) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
            var last = lst(cur.changes);
            if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
                last.to = changeEnd(change);
            } else {
                cur.changes.push(historyChangeFromChange(doc, change));
            }
        } else {
            var before = lst(hist.done);
            if (!before || !before.ranges)
                pushSelectionToHistory(doc.sel, hist.done);
            cur = {
                changes: [historyChangeFromChange(doc, change)],
                generation: hist.generation
            };
            hist.done.push(cur);
            while (hist.done.length > hist.undoDepth) {
                hist.done.shift();
                if (!hist.done[0].ranges)
                    hist.done.shift();
            }
        }
        hist.done.push(selAfter);
        hist.generation = ++hist.maxGeneration;
        hist.lastModTime = hist.lastSelTime = time;
        hist.lastOp = hist.lastSelOp = opId;
        hist.lastOrigin = hist.lastSelOrigin = change.origin;
        if (!last)
            signal(doc, 'historyAdded');
    }
    function selectionEventCanBeMerged(doc, origin, prev, sel) {
        var ch = origin.charAt(0);
        return ch == '*' || ch == '+' && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date() - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
    }
    function addSelectionToHistory(doc, sel, opId, options) {
        var hist = doc.history, origin = options && options.origin;
        if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, lst(hist.done), sel)))
            hist.done[hist.done.length - 1] = sel;
        else
            pushSelectionToHistory(sel, hist.done);
        hist.lastSelTime = +new Date();
        hist.lastSelOrigin = origin;
        hist.lastSelOp = opId;
        if (options && options.clearRedo !== false)
            clearSelectionEvents(hist.undone);
    }
    function pushSelectionToHistory(sel, dest) {
        var top = lst(dest);
        if (!(top && top.ranges && top.equals(sel)))
            dest.push(sel);
    }
    function attachLocalSpans(doc, change, from, to) {
        var existing = change['spans_' + doc.id], n = 0;
        doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
            if (line.markedSpans)
                (existing || (existing = change['spans_' + doc.id] = {}))[n] = line.markedSpans;
            ++n;
        });
    }
    function removeClearedSpans(spans) {
        if (!spans)
            return null;
        for (var i = 0, out; i < spans.length; ++i) {
            if (spans[i].marker.explicitlyCleared) {
                if (!out)
                    out = spans.slice(0, i);
            } else if (out)
                out.push(spans[i]);
        }
        return !out ? spans : out.length ? out : null;
    }
    function getOldSpans(doc, change) {
        var found = change['spans_' + doc.id];
        if (!found)
            return null;
        for (var i = 0, nw = []; i < change.text.length; ++i)
            nw.push(removeClearedSpans(found[i]));
        return nw;
    }
    function copyHistoryArray(events, newGroup, instantiateSel) {
        for (var i = 0, copy = []; i < events.length; ++i) {
            var event = events[i];
            if (event.ranges) {
                copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
                continue;
            }
            var changes = event.changes, newChanges = [];
            copy.push({ changes: newChanges });
            for (var j = 0; j < changes.length; ++j) {
                var change = changes[j], m;
                newChanges.push({
                    from: change.from,
                    to: change.to,
                    text: change.text
                });
                if (newGroup)
                    for (var prop in change)
                        if (m = prop.match(/^spans_(\d+)$/)) {
                            if (indexOf(newGroup, Number(m[1])) > -1) {
                                lst(newChanges)[prop] = change[prop];
                                delete change[prop];
                            }
                        }
            }
        }
        return copy;
    }
    function rebaseHistSelSingle(pos, from, to, diff) {
        if (to < pos.line) {
            pos.line += diff;
        } else if (from < pos.line) {
            pos.line = from;
            pos.ch = 0;
        }
    }
    function rebaseHistArray(array, from, to, diff) {
        for (var i = 0; i < array.length; ++i) {
            var sub = array[i], ok = true;
            if (sub.ranges) {
                if (!sub.copied) {
                    sub = array[i] = sub.deepCopy();
                    sub.copied = true;
                }
                for (var j = 0; j < sub.ranges.length; j++) {
                    rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
                    rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
                }
                continue;
            }
            for (var j = 0; j < sub.changes.length; ++j) {
                var cur = sub.changes[j];
                if (to < cur.from.line) {
                    cur.from = Pos(cur.from.line + diff, cur.from.ch);
                    cur.to = Pos(cur.to.line + diff, cur.to.ch);
                } else if (from <= cur.to.line) {
                    ok = false;
                    break;
                }
            }
            if (!ok) {
                array.splice(0, i + 1);
                i = 0;
            }
        }
    }
    function rebaseHist(hist, change) {
        var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
        rebaseHistArray(hist.done, from, to, diff);
        rebaseHistArray(hist.undone, from, to, diff);
    }
    var e_preventDefault = CodeMirror.e_preventDefault = function (e) {
        if (e.preventDefault)
            e.preventDefault();
        else
            e.returnValue = false;
    };
    var e_stopPropagation = CodeMirror.e_stopPropagation = function (e) {
        if (e.stopPropagation)
            e.stopPropagation();
        else
            e.cancelBubble = true;
    };
    function e_defaultPrevented(e) {
        return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
    }
    var e_stop = CodeMirror.e_stop = function (e) {
        e_preventDefault(e);
        e_stopPropagation(e);
    };
    function e_target(e) {
        return e.target || e.srcElement;
    }
    function e_button(e) {
        var b = e.which;
        if (b == null) {
            if (e.button & 1)
                b = 1;
            else if (e.button & 2)
                b = 3;
            else if (e.button & 4)
                b = 2;
        }
        if (mac && e.ctrlKey && b == 1)
            b = 3;
        return b;
    }
    var on = CodeMirror.on = function (emitter, type, f) {
        if (emitter.addEventListener)
            emitter.addEventListener(type, f, false);
        else if (emitter.attachEvent)
            emitter.attachEvent('on' + type, f);
        else {
            var map = emitter._handlers || (emitter._handlers = {});
            var arr = map[type] || (map[type] = []);
            arr.push(f);
        }
    };
    var off = CodeMirror.off = function (emitter, type, f) {
        if (emitter.removeEventListener)
            emitter.removeEventListener(type, f, false);
        else if (emitter.detachEvent)
            emitter.detachEvent('on' + type, f);
        else {
            var arr = emitter._handlers && emitter._handlers[type];
            if (!arr)
                return;
            for (var i = 0; i < arr.length; ++i)
                if (arr[i] == f) {
                    arr.splice(i, 1);
                    break;
                }
        }
    };
    var signal = CodeMirror.signal = function (emitter, type) {
        var arr = emitter._handlers && emitter._handlers[type];
        if (!arr)
            return;
        var args = Array.prototype.slice.call(arguments, 2);
        for (var i = 0; i < arr.length; ++i)
            arr[i].apply(null, args);
    };
    var orphanDelayedCallbacks = null;
    function signalLater(emitter, type) {
        var arr = emitter._handlers && emitter._handlers[type];
        if (!arr)
            return;
        var args = Array.prototype.slice.call(arguments, 2), list;
        if (operationGroup) {
            list = operationGroup.delayedCallbacks;
        } else if (orphanDelayedCallbacks) {
            list = orphanDelayedCallbacks;
        } else {
            list = orphanDelayedCallbacks = [];
            setTimeout(fireOrphanDelayed, 0);
        }
        function bnd(f) {
            return function () {
                f.apply(null, args);
            };
        }
        ;
        for (var i = 0; i < arr.length; ++i)
            list.push(bnd(arr[i]));
    }
    function fireOrphanDelayed() {
        var delayed = orphanDelayedCallbacks;
        orphanDelayedCallbacks = null;
        for (var i = 0; i < delayed.length; ++i)
            delayed[i]();
    }
    function signalDOMEvent(cm, e, override) {
        if (typeof e == 'string')
            e = {
                type: e,
                preventDefault: function () {
                    this.defaultPrevented = true;
                }
            };
        signal(cm, override || e.type, cm, e);
        return e_defaultPrevented(e) || e.codemirrorIgnore;
    }
    function signalCursorActivity(cm) {
        var arr = cm._handlers && cm._handlers.cursorActivity;
        if (!arr)
            return;
        var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
        for (var i = 0; i < arr.length; ++i)
            if (indexOf(set, arr[i]) == -1)
                set.push(arr[i]);
    }
    function hasHandler(emitter, type) {
        var arr = emitter._handlers && emitter._handlers[type];
        return arr && arr.length > 0;
    }
    function eventMixin(ctor) {
        ctor.prototype.on = function (type, f) {
            on(this, type, f);
        };
        ctor.prototype.off = function (type, f) {
            off(this, type, f);
        };
    }
    var scrollerGap = 30;
    var Pass = CodeMirror.Pass = {
        toString: function () {
            return 'CodeMirror.Pass';
        }
    };
    var sel_dontScroll = { scroll: false }, sel_mouse = { origin: '*mouse' }, sel_move = { origin: '+move' };
    function Delayed() {
        this.id = null;
    }
    Delayed.prototype.set = function (ms, f) {
        clearTimeout(this.id);
        this.id = setTimeout(f, ms);
    };
    var countColumn = CodeMirror.countColumn = function (string, end, tabSize, startIndex, startValue) {
        if (end == null) {
            end = string.search(/[^\s\u00a0]/);
            if (end == -1)
                end = string.length;
        }
        for (var i = startIndex || 0, n = startValue || 0;;) {
            var nextTab = string.indexOf('\t', i);
            if (nextTab < 0 || nextTab >= end)
                return n + (end - i);
            n += nextTab - i;
            n += tabSize - n % tabSize;
            i = nextTab + 1;
        }
    };
    function findColumn(string, goal, tabSize) {
        for (var pos = 0, col = 0;;) {
            var nextTab = string.indexOf('\t', pos);
            if (nextTab == -1)
                nextTab = string.length;
            var skipped = nextTab - pos;
            if (nextTab == string.length || col + skipped >= goal)
                return pos + Math.min(skipped, goal - col);
            col += nextTab - pos;
            col += tabSize - col % tabSize;
            pos = nextTab + 1;
            if (col >= goal)
                return pos;
        }
    }
    var spaceStrs = [''];
    function spaceStr(n) {
        while (spaceStrs.length <= n)
            spaceStrs.push(lst(spaceStrs) + ' ');
        return spaceStrs[n];
    }
    function lst(arr) {
        return arr[arr.length - 1];
    }
    var selectInput = function (node) {
        node.select();
    };
    if (ios)
        selectInput = function (node) {
            node.selectionStart = 0;
            node.selectionEnd = node.value.length;
        };
    else if (ie)
        selectInput = function (node) {
            try {
                node.select();
            } catch (_e) {
            }
        };
    function indexOf(array, elt) {
        for (var i = 0; i < array.length; ++i)
            if (array[i] == elt)
                return i;
        return -1;
    }
    function map(array, f) {
        var out = [];
        for (var i = 0; i < array.length; i++)
            out[i] = f(array[i], i);
        return out;
    }
    function nothing() {
    }
    function createObj(base, props) {
        var inst;
        if (Object.create) {
            inst = Object.create(base);
        } else {
            nothing.prototype = base;
            inst = new nothing();
        }
        if (props)
            copyObj(props, inst);
        return inst;
    }
    ;
    function copyObj(obj, target, overwrite) {
        if (!target)
            target = {};
        for (var prop in obj)
            if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
                target[prop] = obj[prop];
        return target;
    }
    function bind(f) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return f.apply(null, args);
        };
    }
    var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
    var isWordCharBasic = CodeMirror.isWordChar = function (ch) {
        return /\w/.test(ch) || ch > '\x80' && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
    };
    function isWordChar(ch, helper) {
        if (!helper)
            return isWordCharBasic(ch);
        if (helper.source.indexOf('\\w') > -1 && isWordCharBasic(ch))
            return true;
        return helper.test(ch);
    }
    function isEmpty(obj) {
        for (var n in obj)
            if (obj.hasOwnProperty(n) && obj[n])
                return false;
        return true;
    }
    var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
    function isExtendingChar(ch) {
        return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
    }
    function elt(tag, content, className, style) {
        var e = document.createElement(tag);
        if (className)
            e.className = className;
        if (style)
            e.style.cssText = style;
        if (typeof content == 'string')
            e.appendChild(document.createTextNode(content));
        else if (content)
            for (var i = 0; i < content.length; ++i)
                e.appendChild(content[i]);
        return e;
    }
    var range;
    if (document.createRange)
        range = function (node, start, end, endNode) {
            var r = document.createRange();
            r.setEnd(endNode || node, end);
            r.setStart(node, start);
            return r;
        };
    else
        range = function (node, start, end) {
            var r = document.body.createTextRange();
            try {
                r.moveToElementText(node.parentNode);
            } catch (e) {
                return r;
            }
            r.collapse(true);
            r.moveEnd('character', end);
            r.moveStart('character', start);
            return r;
        };
    function removeChildren(e) {
        for (var count = e.childNodes.length; count > 0; --count)
            e.removeChild(e.firstChild);
        return e;
    }
    function removeChildrenAndAdd(parent, e) {
        return removeChildren(parent).appendChild(e);
    }
    var contains = CodeMirror.contains = function (parent, child) {
        if (child.nodeType == 3)
            child = child.parentNode;
        if (parent.contains)
            return parent.contains(child);
        do {
            if (child.nodeType == 11)
                child = child.host;
            if (child == parent)
                return true;
        } while (child = child.parentNode);
    };
    function activeElt() {
        return document.activeElement;
    }
    if (ie && ie_version < 11)
        activeElt = function () {
            try {
                return document.activeElement;
            } catch (e) {
                return document.body;
            }
        };
    function classTest(cls) {
        return new RegExp('(^|\\s)' + cls + '(?:$|\\s)\\s*');
    }
    var rmClass = CodeMirror.rmClass = function (node, cls) {
        var current = node.className;
        var match = classTest(cls).exec(current);
        if (match) {
            var after = current.slice(match.index + match[0].length);
            node.className = current.slice(0, match.index) + (after ? match[1] + after : '');
        }
    };
    var addClass = CodeMirror.addClass = function (node, cls) {
        var current = node.className;
        if (!classTest(cls).test(current))
            node.className += (current ? ' ' : '') + cls;
    };
    function joinClasses(a, b) {
        var as = a.split(' ');
        for (var i = 0; i < as.length; i++)
            if (as[i] && !classTest(as[i]).test(b))
                b += ' ' + as[i];
        return b;
    }
    function forEachCodeMirror(f) {
        if (!document.body.getElementsByClassName)
            return;
        var byClass = document.body.getElementsByClassName('CodeMirror');
        for (var i = 0; i < byClass.length; i++) {
            var cm = byClass[i].CodeMirror;
            if (cm)
                f(cm);
        }
    }
    var globalsRegistered = false;
    function ensureGlobalHandlers() {
        if (globalsRegistered)
            return;
        registerGlobalHandlers();
        globalsRegistered = true;
    }
    function registerGlobalHandlers() {
        var resizeTimer;
        on(window, 'resize', function () {
            if (resizeTimer == null)
                resizeTimer = setTimeout(function () {
                    resizeTimer = null;
                    forEachCodeMirror(onResize);
                }, 100);
        });
        on(window, 'blur', function () {
            forEachCodeMirror(onBlur);
        });
    }
    var dragAndDrop = function () {
        if (ie && ie_version < 9)
            return false;
        var div = elt('div');
        return 'draggable' in div || 'dragDrop' in div;
    }();
    var zwspSupported;
    function zeroWidthElement(measure) {
        if (zwspSupported == null) {
            var test = elt('span', '\u200B');
            removeChildrenAndAdd(measure, elt('span', [
                test,
                document.createTextNode('x')
            ]));
            if (measure.firstChild.offsetHeight != 0)
                zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);
        }
        var node = zwspSupported ? elt('span', '\u200B') : elt('span', '\xA0', null, 'display: inline-block; width: 1px; margin-right: -1px');
        node.setAttribute('cm-text', '');
        return node;
    }
    var badBidiRects;
    function hasBadBidiRects(measure) {
        if (badBidiRects != null)
            return badBidiRects;
        var txt = removeChildrenAndAdd(measure, document.createTextNode('A\u062EA'));
        var r0 = range(txt, 0, 1).getBoundingClientRect();
        if (!r0 || r0.left == r0.right)
            return false;
        var r1 = range(txt, 1, 2).getBoundingClientRect();
        return badBidiRects = r1.right - r0.right < 3;
    }
    var splitLines = CodeMirror.splitLines = '\n\nb'.split(/\n/).length != 3 ? function (string) {
        var pos = 0, result = [], l = string.length;
        while (pos <= l) {
            var nl = string.indexOf('\n', pos);
            if (nl == -1)
                nl = string.length;
            var line = string.slice(pos, string.charAt(nl - 1) == '\r' ? nl - 1 : nl);
            var rt = line.indexOf('\r');
            if (rt != -1) {
                result.push(line.slice(0, rt));
                pos += rt + 1;
            } else {
                result.push(line);
                pos = nl + 1;
            }
        }
        return result;
    } : function (string) {
        return string.split(/\r\n?|\n/);
    };
    var hasSelection = window.getSelection ? function (te) {
        try {
            return te.selectionStart != te.selectionEnd;
        } catch (e) {
            return false;
        }
    } : function (te) {
        try {
            var range = te.ownerDocument.selection.createRange();
        } catch (e) {
        }
        if (!range || range.parentElement() != te)
            return false;
        return range.compareEndPoints('StartToEnd', range) != 0;
    };
    var hasCopyEvent = function () {
        var e = elt('div');
        if ('oncopy' in e)
            return true;
        e.setAttribute('oncopy', 'return;');
        return typeof e.oncopy == 'function';
    }();
    var badZoomedRects = null;
    function hasBadZoomedRects(measure) {
        if (badZoomedRects != null)
            return badZoomedRects;
        var node = removeChildrenAndAdd(measure, elt('span', 'x'));
        var normal = node.getBoundingClientRect();
        var fromRange = range(node, 0, 1).getBoundingClientRect();
        return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
    }
    var keyNames = {
        3: 'Enter',
        8: 'Backspace',
        9: 'Tab',
        13: 'Enter',
        16: 'Shift',
        17: 'Ctrl',
        18: 'Alt',
        19: 'Pause',
        20: 'CapsLock',
        27: 'Esc',
        32: 'Space',
        33: 'PageUp',
        34: 'PageDown',
        35: 'End',
        36: 'Home',
        37: 'Left',
        38: 'Up',
        39: 'Right',
        40: 'Down',
        44: 'PrintScrn',
        45: 'Insert',
        46: 'Delete',
        59: ';',
        61: '=',
        91: 'Mod',
        92: 'Mod',
        93: 'Mod',
        107: '=',
        109: '-',
        127: 'Delete',
        173: '-',
        186: ';',
        187: '=',
        188: ',',
        189: '-',
        190: '.',
        191: '/',
        192: '`',
        219: '[',
        220: '\\',
        221: ']',
        222: '\'',
        63232: 'Up',
        63233: 'Down',
        63234: 'Left',
        63235: 'Right',
        63272: 'Delete',
        63273: 'Home',
        63275: 'End',
        63276: 'PageUp',
        63277: 'PageDown',
        63302: 'Insert'
    };
    CodeMirror.keyNames = keyNames;
    (function () {
        for (var i = 0; i < 10; i++)
            keyNames[i + 48] = keyNames[i + 96] = String(i);
        for (var i = 65; i <= 90; i++)
            keyNames[i] = String.fromCharCode(i);
        for (var i = 1; i <= 12; i++)
            keyNames[i + 111] = keyNames[i + 63235] = 'F' + i;
    }());
    function iterateBidiSections(order, from, to, f) {
        if (!order)
            return f(from, to, 'ltr');
        var found = false;
        for (var i = 0; i < order.length; ++i) {
            var part = order[i];
            if (part.from < to && part.to > from || from == to && part.to == from) {
                f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? 'rtl' : 'ltr');
                found = true;
            }
        }
        if (!found)
            f(from, to, 'ltr');
    }
    function bidiLeft(part) {
        return part.level % 2 ? part.to : part.from;
    }
    function bidiRight(part) {
        return part.level % 2 ? part.from : part.to;
    }
    function lineLeft(line) {
        var order = getOrder(line);
        return order ? bidiLeft(order[0]) : 0;
    }
    function lineRight(line) {
        var order = getOrder(line);
        if (!order)
            return line.text.length;
        return bidiRight(lst(order));
    }
    function lineStart(cm, lineN) {
        var line = getLine(cm.doc, lineN);
        var visual = visualLine(line);
        if (visual != line)
            lineN = lineNo(visual);
        var order = getOrder(visual);
        var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);
        return Pos(lineN, ch);
    }
    function lineEnd(cm, lineN) {
        var merged, line = getLine(cm.doc, lineN);
        while (merged = collapsedSpanAtEnd(line)) {
            line = merged.find(1, true).line;
            lineN = null;
        }
        var order = getOrder(line);
        var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);
        return Pos(lineN == null ? lineNo(line) : lineN, ch);
    }
    function lineStartSmart(cm, pos) {
        var start = lineStart(cm, pos.line);
        var line = getLine(cm.doc, start.line);
        var order = getOrder(line);
        if (!order || order[0].level == 0) {
            var firstNonWS = Math.max(0, line.text.search(/\S/));
            var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
            return Pos(start.line, inWS ? 0 : firstNonWS);
        }
        return start;
    }
    function compareBidiLevel(order, a, b) {
        var linedir = order[0].level;
        if (a == linedir)
            return true;
        if (b == linedir)
            return false;
        return a < b;
    }
    var bidiOther;
    function getBidiPartAt(order, pos) {
        bidiOther = null;
        for (var i = 0, found; i < order.length; ++i) {
            var cur = order[i];
            if (cur.from < pos && cur.to > pos)
                return i;
            if (cur.from == pos || cur.to == pos) {
                if (found == null) {
                    found = i;
                } else if (compareBidiLevel(order, cur.level, order[found].level)) {
                    if (cur.from != cur.to)
                        bidiOther = found;
                    return i;
                } else {
                    if (cur.from != cur.to)
                        bidiOther = i;
                    return found;
                }
            }
        }
        return found;
    }
    function moveInLine(line, pos, dir, byUnit) {
        if (!byUnit)
            return pos + dir;
        do
            pos += dir;
        while (pos > 0 && isExtendingChar(line.text.charAt(pos)));
        return pos;
    }
    function moveVisually(line, start, dir, byUnit) {
        var bidi = getOrder(line);
        if (!bidi)
            return moveLogically(line, start, dir, byUnit);
        var pos = getBidiPartAt(bidi, start), part = bidi[pos];
        var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);
        for (;;) {
            if (target > part.from && target < part.to)
                return target;
            if (target == part.from || target == part.to) {
                if (getBidiPartAt(bidi, target) == pos)
                    return target;
                part = bidi[pos += dir];
                return dir > 0 == part.level % 2 ? part.to : part.from;
            } else {
                part = bidi[pos += dir];
                if (!part)
                    return null;
                if (dir > 0 == part.level % 2)
                    target = moveInLine(line, part.to, -1, byUnit);
                else
                    target = moveInLine(line, part.from, 1, byUnit);
            }
        }
    }
    function moveLogically(line, start, dir, byUnit) {
        var target = start + dir;
        if (byUnit)
            while (target > 0 && isExtendingChar(line.text.charAt(target)))
                target += dir;
        return target < 0 || target > line.text.length ? null : target;
    }
    var bidiOrdering = function () {
        var lowTypes = 'bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN';
        var arabicTypes = 'rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm';
        function charType(code) {
            if (code <= 247)
                return lowTypes.charAt(code);
            else if (1424 <= code && code <= 1524)
                return 'R';
            else if (1536 <= code && code <= 1773)
                return arabicTypes.charAt(code - 1536);
            else if (1774 <= code && code <= 2220)
                return 'r';
            else if (8192 <= code && code <= 8203)
                return 'w';
            else if (code == 8204)
                return 'b';
            else
                return 'L';
        }
        var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
        var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
        var outerType = 'L';
        function BidiSpan(level, from, to) {
            this.level = level;
            this.from = from;
            this.to = to;
        }
        return function (str) {
            if (!bidiRE.test(str))
                return false;
            var len = str.length, types = [];
            for (var i = 0, type; i < len; ++i)
                types.push(type = charType(str.charCodeAt(i)));
            for (var i = 0, prev = outerType; i < len; ++i) {
                var type = types[i];
                if (type == 'm')
                    types[i] = prev;
                else
                    prev = type;
            }
            for (var i = 0, cur = outerType; i < len; ++i) {
                var type = types[i];
                if (type == '1' && cur == 'r')
                    types[i] = 'n';
                else if (isStrong.test(type)) {
                    cur = type;
                    if (type == 'r')
                        types[i] = 'R';
                }
            }
            for (var i = 1, prev = types[0]; i < len - 1; ++i) {
                var type = types[i];
                if (type == '+' && prev == '1' && types[i + 1] == '1')
                    types[i] = '1';
                else if (type == ',' && prev == types[i + 1] && (prev == '1' || prev == 'n'))
                    types[i] = prev;
                prev = type;
            }
            for (var i = 0; i < len; ++i) {
                var type = types[i];
                if (type == ',')
                    types[i] = 'N';
                else if (type == '%') {
                    for (var end = i + 1; end < len && types[end] == '%'; ++end) {
                    }
                    var replace = i && types[i - 1] == '!' || end < len && types[end] == '1' ? '1' : 'N';
                    for (var j = i; j < end; ++j)
                        types[j] = replace;
                    i = end - 1;
                }
            }
            for (var i = 0, cur = outerType; i < len; ++i) {
                var type = types[i];
                if (cur == 'L' && type == '1')
                    types[i] = 'L';
                else if (isStrong.test(type))
                    cur = type;
            }
            for (var i = 0; i < len; ++i) {
                if (isNeutral.test(types[i])) {
                    for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {
                    }
                    var before = (i ? types[i - 1] : outerType) == 'L';
                    var after = (end < len ? types[end] : outerType) == 'L';
                    var replace = before || after ? 'L' : 'R';
                    for (var j = i; j < end; ++j)
                        types[j] = replace;
                    i = end - 1;
                }
            }
            var order = [], m;
            for (var i = 0; i < len;) {
                if (countsAsLeft.test(types[i])) {
                    var start = i;
                    for (++i; i < len && countsAsLeft.test(types[i]); ++i) {
                    }
                    order.push(new BidiSpan(0, start, i));
                } else {
                    var pos = i, at = order.length;
                    for (++i; i < len && types[i] != 'L'; ++i) {
                    }
                    for (var j = pos; j < i;) {
                        if (countsAsNum.test(types[j])) {
                            if (pos < j)
                                order.splice(at, 0, new BidiSpan(1, pos, j));
                            var nstart = j;
                            for (++j; j < i && countsAsNum.test(types[j]); ++j) {
                            }
                            order.splice(at, 0, new BidiSpan(2, nstart, j));
                            pos = j;
                        } else
                            ++j;
                    }
                    if (pos < i)
                        order.splice(at, 0, new BidiSpan(1, pos, i));
                }
            }
            if (order[0].level == 1 && (m = str.match(/^\s+/))) {
                order[0].from = m[0].length;
                order.unshift(new BidiSpan(0, 0, m[0].length));
            }
            if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
                lst(order).to -= m[0].length;
                order.push(new BidiSpan(0, len - m[0].length, len));
            }
            if (order[0].level == 2)
                order.unshift(new BidiSpan(1, order[0].to, order[0].to));
            if (order[0].level != lst(order).level)
                order.push(new BidiSpan(order[0].level, len, len));
            return order;
        };
    }();
    CodeMirror.version = '5.2.0';
    return CodeMirror;
}));
(function (mod) {
    if (typeof exports == 'object' && typeof module == 'object')
        mod(require('../../lib/codemirror'));
    else if (typeof define == 'function' && define.amd)
        define('bower_components/codemirror/mode/javascript/javascript', ['bower_components/codemirror/lib/codemirror'], mod);
    else
        mod(CodeMirror);
}(function (CodeMirror) {
    'use strict';
    CodeMirror.defineMode('javascript', function (config, parserConfig) {
        var indentUnit = config.indentUnit;
        var statementIndent = parserConfig.statementIndent;
        var jsonldMode = parserConfig.jsonld;
        var jsonMode = parserConfig.json || jsonldMode;
        var isTS = parserConfig.typescript;
        var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/;
        var keywords = function () {
            function kw(type) {
                return {
                    type: type,
                    style: 'keyword'
                };
            }
            var A = kw('keyword a'), B = kw('keyword b'), C = kw('keyword c');
            var operator = kw('operator'), atom = {
                    type: 'atom',
                    style: 'atom'
                };
            var jsKeywords = {
                'if': kw('if'),
                'while': A,
                'with': A,
                'else': B,
                'do': B,
                'try': B,
                'finally': B,
                'return': C,
                'break': C,
                'continue': C,
                'new': C,
                'delete': C,
                'throw': C,
                'debugger': C,
                'var': kw('var'),
                'const': kw('var'),
                'let': kw('var'),
                'function': kw('function'),
                'catch': kw('catch'),
                'for': kw('for'),
                'switch': kw('switch'),
                'case': kw('case'),
                'default': kw('default'),
                'in': operator,
                'typeof': operator,
                'instanceof': operator,
                'true': atom,
                'false': atom,
                'null': atom,
                'undefined': atom,
                'NaN': atom,
                'Infinity': atom,
                'this': kw('this'),
                'module': kw('module'),
                'class': kw('class'),
                'super': kw('atom'),
                'yield': C,
                'export': kw('export'),
                'import': kw('import'),
                'extends': C
            };
            if (isTS) {
                var type = {
                    type: 'variable',
                    style: 'variable-3'
                };
                var tsKeywords = {
                    'interface': kw('interface'),
                    'extends': kw('extends'),
                    'constructor': kw('constructor'),
                    'public': kw('public'),
                    'private': kw('private'),
                    'protected': kw('protected'),
                    'static': kw('static'),
                    'string': type,
                    'number': type,
                    'bool': type,
                    'any': type
                };
                for (var attr in tsKeywords) {
                    jsKeywords[attr] = tsKeywords[attr];
                }
            }
            return jsKeywords;
        }();
        var isOperatorChar = /[+\-*&%=<>!?|~^]/;
        var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;
        function readRegexp(stream) {
            var escaped = false, next, inSet = false;
            while ((next = stream.next()) != null) {
                if (!escaped) {
                    if (next == '/' && !inSet)
                        return;
                    if (next == '[')
                        inSet = true;
                    else if (inSet && next == ']')
                        inSet = false;
                }
                escaped = !escaped && next == '\\';
            }
        }
        var type, content;
        function ret(tp, style, cont) {
            type = tp;
            content = cont;
            return style;
        }
        function tokenBase(stream, state) {
            var ch = stream.next();
            if (ch == '"' || ch == '\'') {
                state.tokenize = tokenString(ch);
                return state.tokenize(stream, state);
            } else if (ch == '.' && stream.match(/^\d+(?:[eE][+\-]?\d+)?/)) {
                return ret('number', 'number');
            } else if (ch == '.' && stream.match('..')) {
                return ret('spread', 'meta');
            } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
                return ret(ch);
            } else if (ch == '=' && stream.eat('>')) {
                return ret('=>', 'operator');
            } else if (ch == '0' && stream.eat(/x/i)) {
                stream.eatWhile(/[\da-f]/i);
                return ret('number', 'number');
            } else if (/\d/.test(ch)) {
                stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/);
                return ret('number', 'number');
            } else if (ch == '/') {
                if (stream.eat('*')) {
                    state.tokenize = tokenComment;
                    return tokenComment(stream, state);
                } else if (stream.eat('/')) {
                    stream.skipToEnd();
                    return ret('comment', 'comment');
                } else if (state.lastType == 'operator' || state.lastType == 'keyword c' || state.lastType == 'sof' || /^[\[{}\(,;:]$/.test(state.lastType)) {
                    readRegexp(stream);
                    stream.match(/^\b(([gimyu])(?![gimyu]*\2))+\b/);
                    return ret('regexp', 'string-2');
                } else {
                    stream.eatWhile(isOperatorChar);
                    return ret('operator', 'operator', stream.current());
                }
            } else if (ch == '`') {
                state.tokenize = tokenQuasi;
                return tokenQuasi(stream, state);
            } else if (ch == '#') {
                stream.skipToEnd();
                return ret('error', 'error');
            } else if (isOperatorChar.test(ch)) {
                stream.eatWhile(isOperatorChar);
                return ret('operator', 'operator', stream.current());
            } else if (wordRE.test(ch)) {
                stream.eatWhile(wordRE);
                var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];
                return known && state.lastType != '.' ? ret(known.type, known.style, word) : ret('variable', 'variable', word);
            }
        }
        function tokenString(quote) {
            return function (stream, state) {
                var escaped = false, next;
                if (jsonldMode && stream.peek() == '@' && stream.match(isJsonldKeyword)) {
                    state.tokenize = tokenBase;
                    return ret('jsonld-keyword', 'meta');
                }
                while ((next = stream.next()) != null) {
                    if (next == quote && !escaped)
                        break;
                    escaped = !escaped && next == '\\';
                }
                if (!escaped)
                    state.tokenize = tokenBase;
                return ret('string', 'string');
            };
        }
        function tokenComment(stream, state) {
            var maybeEnd = false, ch;
            while (ch = stream.next()) {
                if (ch == '/' && maybeEnd) {
                    state.tokenize = tokenBase;
                    break;
                }
                maybeEnd = ch == '*';
            }
            return ret('comment', 'comment');
        }
        function tokenQuasi(stream, state) {
            var escaped = false, next;
            while ((next = stream.next()) != null) {
                if (!escaped && (next == '`' || next == '$' && stream.eat('{'))) {
                    state.tokenize = tokenBase;
                    break;
                }
                escaped = !escaped && next == '\\';
            }
            return ret('quasi', 'string-2', stream.current());
        }
        var brackets = '([{}])';
        function findFatArrow(stream, state) {
            if (state.fatArrowAt)
                state.fatArrowAt = null;
            var arrow = stream.string.indexOf('=>', stream.start);
            if (arrow < 0)
                return;
            var depth = 0, sawSomething = false;
            for (var pos = arrow - 1; pos >= 0; --pos) {
                var ch = stream.string.charAt(pos);
                var bracket = brackets.indexOf(ch);
                if (bracket >= 0 && bracket < 3) {
                    if (!depth) {
                        ++pos;
                        break;
                    }
                    if (--depth == 0)
                        break;
                } else if (bracket >= 3 && bracket < 6) {
                    ++depth;
                } else if (wordRE.test(ch)) {
                    sawSomething = true;
                } else if (/["'\/]/.test(ch)) {
                    return;
                } else if (sawSomething && !depth) {
                    ++pos;
                    break;
                }
            }
            if (sawSomething && !depth)
                state.fatArrowAt = pos;
        }
        var atomicTypes = {
            'atom': true,
            'number': true,
            'variable': true,
            'string': true,
            'regexp': true,
            'this': true,
            'jsonld-keyword': true
        };
        function JSLexical(indented, column, type, align, prev, info) {
            this.indented = indented;
            this.column = column;
            this.type = type;
            this.prev = prev;
            this.info = info;
            if (align != null)
                this.align = align;
        }
        function inScope(state, varname) {
            for (var v = state.localVars; v; v = v.next)
                if (v.name == varname)
                    return true;
            for (var cx = state.context; cx; cx = cx.prev) {
                for (var v = cx.vars; v; v = v.next)
                    if (v.name == varname)
                        return true;
            }
        }
        function parseJS(state, style, type, content, stream) {
            var cc = state.cc;
            cx.state = state;
            cx.stream = stream;
            cx.marked = null, cx.cc = cc;
            cx.style = style;
            if (!state.lexical.hasOwnProperty('align'))
                state.lexical.align = true;
            while (true) {
                var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
                if (combinator(type, content)) {
                    while (cc.length && cc[cc.length - 1].lex)
                        cc.pop()();
                    if (cx.marked)
                        return cx.marked;
                    if (type == 'variable' && inScope(state, content))
                        return 'variable-2';
                    return style;
                }
            }
        }
        var cx = {
            state: null,
            column: null,
            marked: null,
            cc: null
        };
        function pass() {
            for (var i = arguments.length - 1; i >= 0; i--)
                cx.cc.push(arguments[i]);
        }
        function cont() {
            pass.apply(null, arguments);
            return true;
        }
        function register(varname) {
            function inList(list) {
                for (var v = list; v; v = v.next)
                    if (v.name == varname)
                        return true;
                return false;
            }
            var state = cx.state;
            if (state.context) {
                cx.marked = 'def';
                if (inList(state.localVars))
                    return;
                state.localVars = {
                    name: varname,
                    next: state.localVars
                };
            } else {
                if (inList(state.globalVars))
                    return;
                if (parserConfig.globalVars)
                    state.globalVars = {
                        name: varname,
                        next: state.globalVars
                    };
            }
        }
        var defaultVars = {
            name: 'this',
            next: { name: 'arguments' }
        };
        function pushcontext() {
            cx.state.context = {
                prev: cx.state.context,
                vars: cx.state.localVars
            };
            cx.state.localVars = defaultVars;
        }
        function popcontext() {
            cx.state.localVars = cx.state.context.vars;
            cx.state.context = cx.state.context.prev;
        }
        function pushlex(type, info) {
            var result = function () {
                var state = cx.state, indent = state.indented;
                if (state.lexical.type == 'stat')
                    indent = state.lexical.indented;
                else
                    for (var outer = state.lexical; outer && outer.type == ')' && outer.align; outer = outer.prev)
                        indent = outer.indented;
                state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
            };
            result.lex = true;
            return result;
        }
        function poplex() {
            var state = cx.state;
            if (state.lexical.prev) {
                if (state.lexical.type == ')')
                    state.indented = state.lexical.indented;
                state.lexical = state.lexical.prev;
            }
        }
        poplex.lex = true;
        function expect(wanted) {
            function exp(type) {
                if (type == wanted)
                    return cont();
                else if (wanted == ';')
                    return pass();
                else
                    return cont(exp);
            }
            ;
            return exp;
        }
        function statement(type, value) {
            if (type == 'var')
                return cont(pushlex('vardef', value.length), vardef, expect(';'), poplex);
            if (type == 'keyword a')
                return cont(pushlex('form'), expression, statement, poplex);
            if (type == 'keyword b')
                return cont(pushlex('form'), statement, poplex);
            if (type == '{')
                return cont(pushlex('}'), block, poplex);
            if (type == ';')
                return cont();
            if (type == 'if') {
                if (cx.state.lexical.info == 'else' && cx.state.cc[cx.state.cc.length - 1] == poplex)
                    cx.state.cc.pop()();
                return cont(pushlex('form'), expression, statement, poplex, maybeelse);
            }
            if (type == 'function')
                return cont(functiondef);
            if (type == 'for')
                return cont(pushlex('form'), forspec, statement, poplex);
            if (type == 'variable')
                return cont(pushlex('stat'), maybelabel);
            if (type == 'switch')
                return cont(pushlex('form'), expression, pushlex('}', 'switch'), expect('{'), block, poplex, poplex);
            if (type == 'case')
                return cont(expression, expect(':'));
            if (type == 'default')
                return cont(expect(':'));
            if (type == 'catch')
                return cont(pushlex('form'), pushcontext, expect('('), funarg, expect(')'), statement, poplex, popcontext);
            if (type == 'module')
                return cont(pushlex('form'), pushcontext, afterModule, popcontext, poplex);
            if (type == 'class')
                return cont(pushlex('form'), className, poplex);
            if (type == 'export')
                return cont(pushlex('form'), afterExport, poplex);
            if (type == 'import')
                return cont(pushlex('form'), afterImport, poplex);
            return pass(pushlex('stat'), expression, expect(';'), poplex);
        }
        function expression(type) {
            return expressionInner(type, false);
        }
        function expressionNoComma(type) {
            return expressionInner(type, true);
        }
        function expressionInner(type, noComma) {
            if (cx.state.fatArrowAt == cx.stream.start) {
                var body = noComma ? arrowBodyNoComma : arrowBody;
                if (type == '(')
                    return cont(pushcontext, pushlex(')'), commasep(pattern, ')'), poplex, expect('=>'), body, popcontext);
                else if (type == 'variable')
                    return pass(pushcontext, pattern, expect('=>'), body, popcontext);
            }
            var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
            if (atomicTypes.hasOwnProperty(type))
                return cont(maybeop);
            if (type == 'function')
                return cont(functiondef, maybeop);
            if (type == 'keyword c')
                return cont(noComma ? maybeexpressionNoComma : maybeexpression);
            if (type == '(')
                return cont(pushlex(')'), maybeexpression, comprehension, expect(')'), poplex, maybeop);
            if (type == 'operator' || type == 'spread')
                return cont(noComma ? expressionNoComma : expression);
            if (type == '[')
                return cont(pushlex(']'), arrayLiteral, poplex, maybeop);
            if (type == '{')
                return contCommasep(objprop, '}', null, maybeop);
            if (type == 'quasi') {
                return pass(quasi, maybeop);
            }
            return cont();
        }
        function maybeexpression(type) {
            if (type.match(/[;\}\)\],]/))
                return pass();
            return pass(expression);
        }
        function maybeexpressionNoComma(type) {
            if (type.match(/[;\}\)\],]/))
                return pass();
            return pass(expressionNoComma);
        }
        function maybeoperatorComma(type, value) {
            if (type == ',')
                return cont(expression);
            return maybeoperatorNoComma(type, value, false);
        }
        function maybeoperatorNoComma(type, value, noComma) {
            var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
            var expr = noComma == false ? expression : expressionNoComma;
            if (type == '=>')
                return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
            if (type == 'operator') {
                if (/\+\+|--/.test(value))
                    return cont(me);
                if (value == '?')
                    return cont(expression, expect(':'), expr);
                return cont(expr);
            }
            if (type == 'quasi') {
                return pass(quasi, me);
            }
            if (type == ';')
                return;
            if (type == '(')
                return contCommasep(expressionNoComma, ')', 'call', me);
            if (type == '.')
                return cont(property, me);
            if (type == '[')
                return cont(pushlex(']'), maybeexpression, expect(']'), poplex, me);
        }
        function quasi(type, value) {
            if (type != 'quasi')
                return pass();
            if (value.slice(value.length - 2) != '${')
                return cont(quasi);
            return cont(expression, continueQuasi);
        }
        function continueQuasi(type) {
            if (type == '}') {
                cx.marked = 'string-2';
                cx.state.tokenize = tokenQuasi;
                return cont(quasi);
            }
        }
        function arrowBody(type) {
            findFatArrow(cx.stream, cx.state);
            return pass(type == '{' ? statement : expression);
        }
        function arrowBodyNoComma(type) {
            findFatArrow(cx.stream, cx.state);
            return pass(type == '{' ? statement : expressionNoComma);
        }
        function maybelabel(type) {
            if (type == ':')
                return cont(poplex, statement);
            return pass(maybeoperatorComma, expect(';'), poplex);
        }
        function property(type) {
            if (type == 'variable') {
                cx.marked = 'property';
                return cont();
            }
        }
        function objprop(type, value) {
            if (type == 'variable' || cx.style == 'keyword') {
                cx.marked = 'property';
                if (value == 'get' || value == 'set')
                    return cont(getterSetter);
                return cont(afterprop);
            } else if (type == 'number' || type == 'string') {
                cx.marked = jsonldMode ? 'property' : cx.style + ' property';
                return cont(afterprop);
            } else if (type == 'jsonld-keyword') {
                return cont(afterprop);
            } else if (type == '[') {
                return cont(expression, expect(']'), afterprop);
            }
        }
        function getterSetter(type) {
            if (type != 'variable')
                return pass(afterprop);
            cx.marked = 'property';
            return cont(functiondef);
        }
        function afterprop(type) {
            if (type == ':')
                return cont(expressionNoComma);
            if (type == '(')
                return pass(functiondef);
        }
        function commasep(what, end) {
            function proceed(type) {
                if (type == ',') {
                    var lex = cx.state.lexical;
                    if (lex.info == 'call')
                        lex.pos = (lex.pos || 0) + 1;
                    return cont(what, proceed);
                }
                if (type == end)
                    return cont();
                return cont(expect(end));
            }
            return function (type) {
                if (type == end)
                    return cont();
                return pass(what, proceed);
            };
        }
        function contCommasep(what, end, info) {
            for (var i = 3; i < arguments.length; i++)
                cx.cc.push(arguments[i]);
            return cont(pushlex(end, info), commasep(what, end), poplex);
        }
        function block(type) {
            if (type == '}')
                return cont();
            return pass(statement, block);
        }
        function maybetype(type) {
            if (isTS && type == ':')
                return cont(typedef);
        }
        function typedef(type) {
            if (type == 'variable') {
                cx.marked = 'variable-3';
                return cont();
            }
        }
        function vardef() {
            return pass(pattern, maybetype, maybeAssign, vardefCont);
        }
        function pattern(type, value) {
            if (type == 'variable') {
                register(value);
                return cont();
            }
            if (type == '[')
                return contCommasep(pattern, ']');
            if (type == '{')
                return contCommasep(proppattern, '}');
        }
        function proppattern(type, value) {
            if (type == 'variable' && !cx.stream.match(/^\s*:/, false)) {
                register(value);
                return cont(maybeAssign);
            }
            if (type == 'variable')
                cx.marked = 'property';
            return cont(expect(':'), pattern, maybeAssign);
        }
        function maybeAssign(_type, value) {
            if (value == '=')
                return cont(expressionNoComma);
        }
        function vardefCont(type) {
            if (type == ',')
                return cont(vardef);
        }
        function maybeelse(type, value) {
            if (type == 'keyword b' && value == 'else')
                return cont(pushlex('form', 'else'), statement, poplex);
        }
        function forspec(type) {
            if (type == '(')
                return cont(pushlex(')'), forspec1, expect(')'), poplex);
        }
        function forspec1(type) {
            if (type == 'var')
                return cont(vardef, expect(';'), forspec2);
            if (type == ';')
                return cont(forspec2);
            if (type == 'variable')
                return cont(formaybeinof);
            return pass(expression, expect(';'), forspec2);
        }
        function formaybeinof(_type, value) {
            if (value == 'in' || value == 'of') {
                cx.marked = 'keyword';
                return cont(expression);
            }
            return cont(maybeoperatorComma, forspec2);
        }
        function forspec2(type, value) {
            if (type == ';')
                return cont(forspec3);
            if (value == 'in' || value == 'of') {
                cx.marked = 'keyword';
                return cont(expression);
            }
            return pass(expression, expect(';'), forspec3);
        }
        function forspec3(type) {
            if (type != ')')
                cont(expression);
        }
        function functiondef(type, value) {
            if (value == '*') {
                cx.marked = 'keyword';
                return cont(functiondef);
            }
            if (type == 'variable') {
                register(value);
                return cont(functiondef);
            }
            if (type == '(')
                return cont(pushcontext, pushlex(')'), commasep(funarg, ')'), poplex, statement, popcontext);
        }
        function funarg(type) {
            if (type == 'spread')
                return cont(funarg);
            return pass(pattern, maybetype);
        }
        function className(type, value) {
            if (type == 'variable') {
                register(value);
                return cont(classNameAfter);
            }
        }
        function classNameAfter(type, value) {
            if (value == 'extends')
                return cont(expression, classNameAfter);
            if (type == '{')
                return cont(pushlex('}'), classBody, poplex);
        }
        function classBody(type, value) {
            if (type == 'variable' || cx.style == 'keyword') {
                if (value == 'static') {
                    cx.marked = 'keyword';
                    return cont(classBody);
                }
                cx.marked = 'property';
                if (value == 'get' || value == 'set')
                    return cont(classGetterSetter, functiondef, classBody);
                return cont(functiondef, classBody);
            }
            if (value == '*') {
                cx.marked = 'keyword';
                return cont(classBody);
            }
            if (type == ';')
                return cont(classBody);
            if (type == '}')
                return cont();
        }
        function classGetterSetter(type) {
            if (type != 'variable')
                return pass();
            cx.marked = 'property';
            return cont();
        }
        function afterModule(type, value) {
            if (type == 'string')
                return cont(statement);
            if (type == 'variable') {
                register(value);
                return cont(maybeFrom);
            }
        }
        function afterExport(_type, value) {
            if (value == '*') {
                cx.marked = 'keyword';
                return cont(maybeFrom, expect(';'));
            }
            if (value == 'default') {
                cx.marked = 'keyword';
                return cont(expression, expect(';'));
            }
            return pass(statement);
        }
        function afterImport(type) {
            if (type == 'string')
                return cont();
            return pass(importSpec, maybeFrom);
        }
        function importSpec(type, value) {
            if (type == '{')
                return contCommasep(importSpec, '}');
            if (type == 'variable')
                register(value);
            if (value == '*')
                cx.marked = 'keyword';
            return cont(maybeAs);
        }
        function maybeAs(_type, value) {
            if (value == 'as') {
                cx.marked = 'keyword';
                return cont(importSpec);
            }
        }
        function maybeFrom(_type, value) {
            if (value == 'from') {
                cx.marked = 'keyword';
                return cont(expression);
            }
        }
        function arrayLiteral(type) {
            if (type == ']')
                return cont();
            return pass(expressionNoComma, maybeArrayComprehension);
        }
        function maybeArrayComprehension(type) {
            if (type == 'for')
                return pass(comprehension, expect(']'));
            if (type == ',')
                return cont(commasep(maybeexpressionNoComma, ']'));
            return pass(commasep(expressionNoComma, ']'));
        }
        function comprehension(type) {
            if (type == 'for')
                return cont(forspec, comprehension);
            if (type == 'if')
                return cont(expression, comprehension);
        }
        function isContinuedStatement(state, textAfter) {
            return state.lastType == 'operator' || state.lastType == ',' || isOperatorChar.test(textAfter.charAt(0)) || /[,.]/.test(textAfter.charAt(0));
        }
        return {
            startState: function (basecolumn) {
                var state = {
                    tokenize: tokenBase,
                    lastType: 'sof',
                    cc: [],
                    lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, 'block', false),
                    localVars: parserConfig.localVars,
                    context: parserConfig.localVars && { vars: parserConfig.localVars },
                    indented: 0
                };
                if (parserConfig.globalVars && typeof parserConfig.globalVars == 'object')
                    state.globalVars = parserConfig.globalVars;
                return state;
            },
            token: function (stream, state) {
                if (stream.sol()) {
                    if (!state.lexical.hasOwnProperty('align'))
                        state.lexical.align = false;
                    state.indented = stream.indentation();
                    findFatArrow(stream, state);
                }
                if (state.tokenize != tokenComment && stream.eatSpace())
                    return null;
                var style = state.tokenize(stream, state);
                if (type == 'comment')
                    return style;
                state.lastType = type == 'operator' && (content == '++' || content == '--') ? 'incdec' : type;
                return parseJS(state, style, type, content, stream);
            },
            indent: function (state, textAfter) {
                if (state.tokenize == tokenComment)
                    return CodeMirror.Pass;
                if (state.tokenize != tokenBase)
                    return 0;
                var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;
                if (!/^\s*else\b/.test(textAfter))
                    for (var i = state.cc.length - 1; i >= 0; --i) {
                        var c = state.cc[i];
                        if (c == poplex)
                            lexical = lexical.prev;
                        else if (c != maybeelse)
                            break;
                    }
                if (lexical.type == 'stat' && firstChar == '}')
                    lexical = lexical.prev;
                if (statementIndent && lexical.type == ')' && lexical.prev.type == 'stat')
                    lexical = lexical.prev;
                var type = lexical.type, closing = firstChar == type;
                if (type == 'vardef')
                    return lexical.indented + (state.lastType == 'operator' || state.lastType == ',' ? lexical.info + 1 : 0);
                else if (type == 'form' && firstChar == '{')
                    return lexical.indented;
                else if (type == 'form')
                    return lexical.indented + indentUnit;
                else if (type == 'stat')
                    return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);
                else if (lexical.info == 'switch' && !closing && parserConfig.doubleIndentSwitch != false)
                    return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
                else if (lexical.align)
                    return lexical.column + (closing ? 0 : 1);
                else
                    return lexical.indented + (closing ? 0 : indentUnit);
            },
            electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
            blockCommentStart: jsonMode ? null : '/*',
            blockCommentEnd: jsonMode ? null : '*/',
            lineComment: jsonMode ? null : '//',
            fold: 'brace',
            closeBrackets: '()[]{}\'\'""``',
            helperType: jsonMode ? 'json' : 'javascript',
            jsonldMode: jsonldMode,
            jsonMode: jsonMode
        };
    });
    CodeMirror.registerHelper('wordChars', 'javascript', /[\w$]/);
    CodeMirror.defineMIME('text/javascript', 'javascript');
    CodeMirror.defineMIME('text/ecmascript', 'javascript');
    CodeMirror.defineMIME('application/javascript', 'javascript');
    CodeMirror.defineMIME('application/x-javascript', 'javascript');
    CodeMirror.defineMIME('application/ecmascript', 'javascript');
    CodeMirror.defineMIME('application/json', {
        name: 'javascript',
        json: true
    });
    CodeMirror.defineMIME('application/x-json', {
        name: 'javascript',
        json: true
    });
    CodeMirror.defineMIME('application/ld+json', {
        name: 'javascript',
        jsonld: true
    });
    CodeMirror.defineMIME('text/typescript', {
        name: 'javascript',
        typescript: true
    });
    CodeMirror.defineMIME('application/typescript', {
        name: 'javascript',
        typescript: true
    });
}));
(function () {
    var HSLCircle, Picker, cssColorToRGB, fmod, hslToCSS, hslToRGB, hueToRGB, isValidCSSColor, map, normalizeColor, rgbToHSL, style, __slice = [].slice;
    hueToRGB = function (m1, m2, h) {
        h = h < 0 ? h + 1 : h > 1 ? h - 1 : h;
        if (h * 6 < 1) {
            return m1 + (m2 - m1) * h * 6;
        }
        if (h * 2 < 1) {
            return m2;
        }
        if (h * 3 < 2) {
            return m1 + (m2 - m1) * (0.66666 - h) * 6;
        }
        return m1;
    };
    hslToRGB = function (h, s, l) {
        var m1, m2;
        m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
        m1 = l * 2 - m2;
        return {
            r: hueToRGB(m1, m2, h + 0.33333),
            g: hueToRGB(m1, m2, h),
            b: hueToRGB(m1, m2, h - 0.33333)
        };
    };
    rgbToHSL = function (r, g, b) {
        var diff, h, l, max, min, s, sum;
        max = Math.max(r, g, b);
        min = Math.min(r, g, b);
        diff = max - min;
        sum = max + min;
        h = min === max ? 0 : r === max ? (60 * (g - b) / diff + 360) % 360 : g === max ? 60 * (b - r) / diff + 120 : 60 * (r - g) / diff + 240;
        l = sum / 2;
        s = l === 0 ? 0 : l === 1 ? 1 : l <= 0.5 ? diff / sum : diff / (2 - sum);
        return {
            h: h,
            s: s,
            l: l
        };
    };
    hslToCSS = function (h, s, l, a) {
        if (a != null) {
            return 'hsla(' + fmod(Math.round(h * 180 / Math.PI), 360) + ',' + Math.round(s * 100) + '%,' + Math.round(l * 100) + '%,' + a + ')';
        } else {
            return 'hsl(' + fmod(Math.round(h * 180 / Math.PI), 360) + ',' + Math.round(s * 100) + '%,' + Math.round(l * 100) + '%)';
        }
    };
    cssColorToRGB = function (cssColor) {
        var b, g, m, r, rgb, s;
        s = document.createElement('span');
        document.body.appendChild(s);
        s.style.backgroundColor = cssColor;
        rgb = getComputedStyle(s).backgroundColor;
        document.body.removeChild(s);
        m = /^rgb\((\d+), (\d+), (\d+)\)$/.exec(rgb);
        if (!m) {
            m = /^rgba\((\d+), (\d+), (\d+), ([\d.]+)\)$/.exec(rgb);
        }
        r = parseInt(m[1]);
        g = parseInt(m[2]);
        b = parseInt(m[3]);
        if (m[4]) {
            return {
                r: r / 255,
                g: g / 255,
                b: b / 255,
                a: parseFloat(m[4])
            };
        }
        return {
            r: r / 255,
            g: g / 255,
            b: b / 255
        };
    };
    isValidCSSColor = function (cssColor) {
        var ret, s;
        s = document.createElement('span');
        document.body.appendChild(s);
        s.style.backgroundColor = cssColor;
        ret = s.style.backgroundColor.length > 0;
        s.remove();
        return ret;
    };
    style = function (tag, styles) {
        var n, v;
        for (n in styles) {
            v = styles[n];
            tag.style[n] = v;
        }
        return tag;
    };
    fmod = function (x, m) {
        x = x % m;
        if (x < 0) {
            x += m;
        }
        return x;
    };
    map = function (v, min, max) {
        return min + (max - min) * Math.min(1, Math.max(0, v));
    };
    HSLCircle = function () {
        function HSLCircle(radius, width, lightness) {
            var b, canvas, ctx, d, data, dx, dy, g, h, imgdata, r, s, x, y, _i, _j, _ref, _ref1, _ref2;
            this.radius = radius;
            this.width = width;
            this.lightness = lightness;
            radius = this.radius;
            width = this.width;
            canvas = this.canvas = document.createElement('canvas');
            canvas.width = canvas.height = radius * 2;
            ctx = canvas.getContext('2d');
            imgdata = ctx.createImageData(canvas.width, canvas.height);
            data = imgdata.data;
            for (y = _i = 0, _ref = canvas.height; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
                for (x = _j = 0, _ref1 = canvas.width; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
                    dy = y - radius;
                    dx = x - radius;
                    d = Math.sqrt(dy * dy + dx * dx);
                    if (d > radius + 1.5) {
                        continue;
                    }
                    d -= 10;
                    s = Math.max(0, Math.min(1, d / (radius - width / 2 - 10)));
                    h = Math.atan2(dy, dx) / (Math.PI * 2);
                    _ref2 = hslToRGB(h, s, this.lightness), r = _ref2.r, g = _ref2.g, b = _ref2.b;
                    data[(y * canvas.width + x) * 4 + 0] = r * 255;
                    data[(y * canvas.width + x) * 4 + 1] = g * 255;
                    data[(y * canvas.width + x) * 4 + 2] = b * 255;
                    data[(y * canvas.width + x) * 4 + 3] = 255;
                }
            }
            ctx.putImageData(imgdata, 0, 0);
        }
        HSLCircle.prototype.drawHSLCircle = function (canvas, saturation) {
            var ctx, highlighted_r, radius, width;
            canvas.width = canvas.height = 2 * this.radius;
            ctx = canvas.getContext('2d');
            width = this.width;
            radius = this.radius;
            highlighted_r = map(saturation, width, radius);
            ctx.save();
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.arc(radius, radius, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(radius, radius, highlighted_r, 0, Math.PI * 2);
            ctx.arc(radius, radius, highlighted_r - width, 0, Math.PI * 2, true);
            ctx.fill();
            ctx.globalCompositeOperation = 'source-in';
            ctx.drawImage(this.canvas, 0, 0);
            return ctx.restore();
        };
        return HSLCircle;
    }();
    normalizeColor = function (color) {
        if (typeof color === 'string') {
            color = cssColorToRGB(color);
        }
        if (color.r != null && color.g != null && color.b != null) {
            color = rgbToHSL(color.r, color.g, color.b);
            color.h = color.h * Math.PI / 180;
        } else if (color.h != null && color.s != null && color.l != null) {
            color.h = color.h * Math.PI / 180;
        }
        return color;
    };
    Picker = function () {
        var attachEvents, makeCircle, makeColorPreview, makeKnob, makeLightnessSlider, makeRoot, radius, width;
        radius = 80;
        width = 25;
        function Picker(color) {
            this.color = normalizeColor(color);
            this.refColor = this.color;
            this.el = makeRoot();
            this.circleContainer = this.el.appendChild(makeCircle.call(this));
            this.lSlider = this.el.appendChild(makeLightnessSlider.call(this));
            this.colorPreview = this.el.appendChild(makeColorPreview.call(this));
            attachEvents.call(this);
            this.setLightness(this.color.l);
        }
        Picker.prototype.setHue = function (h) {
            var b, oR, r;
            this.color.h = h;
            r = map(this.color.s, width, radius) - width / 2;
            oR = radius - width / 2;
            style(this.hueKnob, {
                left: Math.round(oR + Math.cos(h) * r + 6 - 1) + 'px',
                top: Math.round(oR + Math.sin(h) * r + 6 - 1) + 'px'
            });
            this.colorPreview.style.backgroundColor = this.lKnob.style.backgroundColor = this.hueKnob.style.backgroundColor = hslToCSS(this.color.h, this.color.s, this.color.l);
            b = hslToCSS(this.color.h, this.color.s, 0.5);
            this.lSlider.style.backgroundImage = '-webkit-linear-gradient(bottom, black, ' + b + ' 50%, white)';
            this.lSlider.style.backgroundImage = '-moz-linear-gradient(bottom, black, ' + b + ' 50%, white)';
            return this.emit('changed');
        };
        Picker.prototype.setSaturation = function (s) {
            this.color.s = s;
            this.circle.drawHSLCircle(this.circleCanvas, s);
            return this.setHue(this.color.h);
        };
        Picker.prototype.setLightness = function (l) {
            this.color.l = l;
            this.circle = new HSLCircle(radius, width, l);
            this.lKnob.style.top = (1 - l) * this.lSlider._height - 11 + 'px';
            return this.setSaturation(this.color.s);
        };
        Picker.prototype.setHSL = function (h, s, l) {
            this.color.h = fmod(h, 360) * Math.PI / 180;
            this.color.s = Math.max(0, Math.min(1, s));
            l = Math.max(0, Math.min(1, l));
            return this.setLightness(l);
        };
        Picker.prototype.getHSL = function () {
            return {
                h: fmod(this.color.h * 180 / Math.PI, 360),
                s: this.color.s,
                l: this.color.l
            };
        };
        Picker.prototype.setRGB = function (r, g, b) {
            var h, l, s, _ref;
            _ref = rgbToHSL(r, g, b), h = _ref.h, s = _ref.s, l = _ref.l;
            return this.setHSL(h, s, l);
        };
        Picker.prototype.getRGB = function () {
            return hslToRGB(this.color.h / (Math.PI * 2), this.color.s, this.color.l);
        };
        Picker.prototype.getCSS = function () {
            return hslToCSS(this.color.h, this.color.s, this.color.l);
        };
        Picker.prototype.setCSS = function (css) {
            var b, g, r, _ref;
            _ref = cssColorToRGB(css), r = _ref.r, g = _ref.g, b = _ref.b;
            return this.setRGB(r, g, b);
        };
        Picker.prototype.on = function (e, l) {
            var _base;
            if (this._listeners == null) {
                this._listeners = {};
            }
            return ((_base = this._listeners)[e] != null ? _base[e] : _base[e] = []).push(l);
        };
        Picker.prototype.emit = function () {
            var args, e, l, _i, _len, _ref, _ref1, _results;
            e = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
            if (this._listeners) {
                _ref1 = (_ref = this._listeners[e]) != null ? _ref : [];
                _results = [];
                for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                    l = _ref1[_i];
                    _results.push(l.call.apply(l, [this].concat(__slice.call(args))));
                }
                return _results;
            }
        };
        Picker.prototype.removeListener = function (e, l) {
            var k;
            if (this._listeners[e]) {
                return this._listeners[e] = function () {
                    var _i, _len, _ref, _results;
                    _ref = this._listeners[e];
                    _results = [];
                    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                        k = _ref[_i];
                        if (k !== l) {
                            _results.push(k);
                        }
                    }
                    return _results;
                }.call(this);
            }
        };
        attachEvents = function () {
            var c, updateCursor;
            this.lKnob.onmousedown = function (_this) {
                return function (e) {
                    var move, up;
                    document.documentElement.style.cursor = 'pointer';
                    window.addEventListener('mousemove', move = function (e) {
                        var r, y;
                        r = _this.lSlider.getBoundingClientRect();
                        y = e.clientY - r.top;
                        return _this.setLightness(Math.max(0, Math.min(1, 1 - y / _this.lSlider._height)));
                    });
                    window.addEventListener('mouseup', up = function (e) {
                        window.removeEventListener('mousemove', move);
                        window.removeEventListener('mouseup', up);
                        window.removeEventListener('blur', up);
                        return document.documentElement.style.cursor = '';
                    });
                    window.addEventListener('blur', up);
                    e.preventDefault();
                    return e.stopPropagation();
                };
            }(this);
            c = this.circleContainer;
            updateCursor = function (_this) {
                return function (e) {
                    var d, dx, dy, r, t, x, y;
                    x = e.layerX;
                    y = e.layerY;
                    dx = x - radius;
                    dy = y - radius;
                    d = Math.sqrt(dx * dx + dy * dy);
                    t = Math.atan2(dy, dx);
                    r = map(_this.color.s, width, radius);
                    if (r - width < d && d < r) {
                        if (-Math.PI / 8 < t && t < Math.PI / 8 || t >= 7 * Math.PI / 8 || t <= -7 * Math.PI / 8) {
                            return c.style.cursor = 'ew-resize';
                        } else if (Math.PI / 8 <= t && t < 3 * Math.PI / 8 || -7 * Math.PI / 8 < t && t <= -5 * Math.PI / 8) {
                            return c.style.cursor = 'nwse-resize';
                        } else if (3 * Math.PI / 8 <= t && t < 5 * Math.PI / 8 || -5 * Math.PI / 8 < t && t <= -3 * Math.PI / 8) {
                            return c.style.cursor = 'ns-resize';
                        } else if (5 * Math.PI / 8 <= t && t < 7 * Math.PI / 8 || -3 * Math.PI / 8 < t && t <= -Math.PI / 8) {
                            return c.style.cursor = 'nesw-resize';
                        }
                    } else {
                        return c.style.cursor = '';
                    }
                };
            }(this);
            c.addEventListener('mouseover', function (e) {
                var move, out;
                updateCursor(e);
                c.addEventListener('mousemove', move = function (e) {
                    return updateCursor(e);
                });
                c.addEventListener('mouseout', out = function (e) {
                    c.style.cursor = '';
                    c.removeEventListener('mousemove', move);
                    c.removeEventListener('mouseout', out);
                    return window.removeEventListener('blur', out);
                });
                return window.addEventListener('blur', out);
            });
            c.addEventListener('mousedown', function (_this) {
                return function (e) {
                    var d, dx, dy, move, r, t, up, x, y;
                    e.preventDefault();
                    x = e.layerX;
                    y = e.layerY;
                    dx = x - radius;
                    dy = y - radius;
                    d = Math.sqrt(dx * dx + dy * dy);
                    t = Math.atan2(dy, dx);
                    r = map(_this.color.s, width, radius);
                    if (!(r - width < d && d < r)) {
                        return;
                    }
                    document.documentElement.style.cursor = c.style.cursor;
                    window.addEventListener('mousemove', move = function (e) {
                        var cx, cy, s;
                        r = _this.circleCanvas.getBoundingClientRect();
                        cx = r.left + r.width / 2;
                        cy = r.top + r.height / 2;
                        dx = e.clientX - cx;
                        dy = e.clientY - cy;
                        d = Math.sqrt(dx * dx + dy * dy);
                        d -= 10;
                        s = Math.max(0, Math.min(1, d / (radius - width / 2 - 10)));
                        return _this.setSaturation(s);
                    });
                    window.addEventListener('mouseup', up = function (e) {
                        window.removeEventListener('mousemove', move);
                        window.removeEventListener('mouseup', up);
                        window.removeEventListener('blur', up);
                        return document.documentElement.style.cursor = '';
                    });
                    return window.addEventListener('blur', up);
                };
            }(this));
            return this.hueKnob.onmousedown = function (_this) {
                return function (e) {
                    var move, up;
                    document.documentElement.style.cursor = 'pointer';
                    window.addEventListener('mousemove', move = function (e) {
                        var cx, cy, r;
                        r = _this.circleCanvas.getBoundingClientRect();
                        cx = r.left + r.width / 2;
                        cy = r.top + r.height / 2;
                        return _this.setHue(Math.atan2(e.clientY - cy, e.clientX - cx));
                    });
                    window.addEventListener('mouseup', up = function (e) {
                        window.removeEventListener('mousemove', move);
                        window.removeEventListener('mouseup', up);
                        window.removeEventListener('blur', up);
                        return document.documentElement.style.cursor = '';
                    });
                    window.addEventListener('blur', up);
                    e.preventDefault();
                    return e.stopPropagation();
                };
            }(this);
        };
        makeRoot = function () {
            var div;
            div = document.createElement('div');
            div.className = 'picker';
            style(div, {
                display: 'inline-block',
                background: 'hsl(0, 0%, 97%)',
                padding: '6px',
                borderRadius: '6px',
                boxShadow: '1px 1px 5px hsla(0, 0%, 39%, 0.2), hsla(0, 0%, 100%, 0.9) 0px 0px 1em 0.3em inset',
                border: '1px solid hsla(0, 0%, 59%, 0.2)',
                position: 'absolute',
                backgroundImage: '-webkit-linear-gradient(left top, hsla(0, 0%, 0%, 0.05) 25%, transparent 25%, transparent 50%, hsla(0, 0%, 0%, 0.05) 50%, hsla(0, 0%, 0%, 0.05) 75%, transparent 75%, transparent)',
                backgroundSize: '40px 40px'
            });
            style(div, {
                backgroundImage: '-moz-linear-gradient(left top, hsla(0, 0%, 0%, 0.05) 25%, transparent 25%, transparent 50%, hsla(0, 0%, 0%, 0.05) 50%, hsla(0, 0%, 0%, 0.05) 75%, transparent 75%, transparent)',
                zIndex: '1000'
            });
            return div;
        };
        makeCircle = function () {
            var circleContainer, k;
            circleContainer = document.createElement('div');
            style(circleContainer, {
                display: 'inline-block',
                width: radius * 2 + 'px',
                height: radius * 2 + 'px',
                borderRadius: radius + 'px',
                boxShadow: '0px 0px 7px rgba(0,0,0,0.3)'
            });
            circleContainer.appendChild(this.circleCanvas = document.createElement('canvas'));
            this.hueKnob = k = makeKnob(27);
            circleContainer.appendChild(k);
            return circleContainer;
        };
        makeLightnessSlider = function () {
            var k, lSlider;
            lSlider = document.createElement('div');
            style(lSlider, {
                display: 'inline-block',
                width: '20px',
                height: radius * 2 - 22 + 'px',
                marginLeft: '6px',
                borderRadius: '10px',
                boxShadow: 'hsla(0, 100%, 100%, 0.1) 0 1px 2px 1px inset, hsla(0, 100%, 100%, 0.2) 0 1px inset, hsla(0, 0%, 0%, 0.4) 0 -1px 1px inset, hsla(0, 0%, 0%, 0.4) 0 1px 1px',
                position: 'relative',
                top: '-11px'
            });
            lSlider._height = radius * 2 - 22;
            this.lKnob = k = makeKnob(22);
            style(k, { left: '-1px' });
            lSlider.appendChild(k);
            return lSlider;
        };
        makeColorPreview = function () {
            var colorPreview, originalColor, originalColorTransparent;
            colorPreview = document.createElement('div');
            originalColor = hslToCSS(this.refColor.h, this.refColor.s, this.refColor.l);
            originalColorTransparent = hslToCSS(this.refColor.h, this.refColor.s, this.refColor.l, 0);
            style(colorPreview, {
                boxShadow: 'hsla(0, 0%, 0%, 0.5) 0 1px 5px, hsla(0, 100%, 100%, 0.4) 0 1px 1px inset, hsla(0, 0%, 0%, 0.3) 0 -1px 1px inset',
                height: '25px',
                marginTop: '6px',
                borderRadius: '3px',
                backgroundImage: '-webkit-linear-gradient(-20deg, ' + originalColorTransparent + ', ' + originalColorTransparent + ' 69%, ' + originalColor + ' 70%, ' + originalColor + ')'
            });
            style(colorPreview, { backgroundImage: '-moz-linear-gradient(-20deg, ' + originalColorTransparent + ', ' + originalColorTransparent + ' 69%, ' + originalColor + ' 70%, ' + originalColor + ')' });
            return colorPreview;
        };
        makeKnob = function (size) {
            var el;
            el = document.createElement('div');
            el.className = 'knob';
            style(el, {
                position: 'absolute',
                width: size + 'px',
                height: size + 'px',
                backgroundColor: 'red',
                borderRadius: Math.floor(size / 2) + 'px',
                cursor: 'pointer',
                backgroundImage: '-webkit-gradient(radial, 50% 0%, 0, 50% 0%, 15, color-stop(0%, rgba(255, 255, 255, 0.8)), color-stop(100%, rgba(255, 255, 255, 0.2)))',
                boxShadow: 'white 0px 1px 1px inset, rgba(0, 0, 0, 0.4) 0px -1px 1px inset, rgba(0, 0, 0, 0.4) 0px 1px 4px 0px, rgba(0, 0, 0, 0.6) 0 0 2px'
            });
            style(el, { backgroundImage: 'radial-gradient(circle at center top, rgba(255,255,255,0.8), rgba(255, 255, 255, 0.2) 15px' });
            return el;
        };
        Picker.prototype.presentModal = function (x, y) {
            var modalFrame;
            style(this.el, {
                left: x + 'px',
                top: y - 10 + 'px',
                opacity: '0',
                webkitTransition: '0.15s',
                MozTransition: '0.15s'
            });
            modalFrame = document.createElement('div');
            modalFrame.style.position = 'fixed';
            modalFrame.style.top = modalFrame.style.left = modalFrame.style.bottom = modalFrame.style.right = '0';
            modalFrame.style.zIndex = '999';
            modalFrame.onclick = function (_this) {
                return function () {
                    var end;
                    document.body.removeChild(modalFrame);
                    _this.el.style.top = y + 10 + 'px';
                    _this.el.style.opacity = 0;
                    end = function () {
                        document.body.removeChild(_this.el);
                        _this.el.removeEventListener('webkitTransitionEnd', end);
                        return _this.el.removeEventListener('transitionend', end);
                    };
                    _this.el.addEventListener('webkitTransitionEnd', end);
                    _this.el.addEventListener('transitionend', end);
                    return _this.emit('closed');
                };
            }(this);
            document.body.appendChild(modalFrame);
            document.body.appendChild(this.el);
            this.el.offsetHeight;
            this.el.style.opacity = '1';
            this.el.style.top = y + 'px';
            return this;
        };
        Picker.prototype.presentModalBeneath = function (el) {
            var elPos, x, y;
            elPos = el.getBoundingClientRect();
            x = elPos.left + window.scrollX;
            y = elPos.bottom + window.scrollY + 4;
            return this.presentModal(x, y);
        };
        return Picker;
    }();
    window.thistle = {
        Picker: Picker,
        isValidCSSColor: isValidCSSColor
    };
}.call(this));
if (typeof Color === 'undefined')
    var Color = {};
if (typeof Color.Space === 'undefined')
    Color.Space = {};
(function () {
    'use strict';
    var useEval = false;
    var functions = {};
    var shortcuts = {
        'HEX24>HSL': 'HEX24>RGB>HSL',
        'HEX32>HSLA': 'HEX32>RGBA>HSLA',
        'HEX24>CMYK': 'HEX24>RGB>CMY>CMYK',
        'RGB>CMYK': 'RGB>CMY>CMYK'
    };
    var root = Color.Space = function (color, route) {
        if (shortcuts[route]) {
            route = shortcuts[route];
        }
        var r = route.split('>');
        if (typeof color === 'object' && color[0] >= 0) {
            var type = r[0];
            var tmp = {};
            for (var i = 0; i < type.length; i++) {
                var str = type.substr(i, 1);
                tmp[str] = color[i];
            }
            color = tmp;
        }
        if (functions[route]) {
            return functions[route](color);
        }
        var f = 'color';
        for (var pos = 1, key = r[0]; pos < r.length; pos++) {
            if (pos > 1) {
                key = key.substr(key.indexOf('_') + 1);
            }
            key += (pos === 0 ? '' : '_') + r[pos];
            color = root[key](color);
            if (useEval) {
                f = 'Color.Space.' + key + '(' + f + ')';
            }
        }
        if (useEval) {
            functions[route] = eval('(function(color) { return ' + f + ' })');
        }
        return color;
    };
    root.RGB_W3 = function (o) {
        return 'rgb(' + (o.R >> 0) + ',' + (o.G >> 0) + ',' + (o.B >> 0) + ')';
    };
    root.RGBA_W3 = function (o) {
        var alpha = typeof o.A === 'number' ? o.A / 255 : 1;
        return 'rgba(' + (o.R >> 0) + ',' + (o.G >> 0) + ',' + (o.B >> 0) + ',' + alpha + ')';
    };
    root.W3_RGB = function (o) {
        o = o.substr(4, o.length - 5).split(',');
        return {
            R: parseInt(o[0], 10),
            G: parseInt(o[1], 10),
            B: parseInt(o[2], 10)
        };
    };
    root.W3_RGBA = function (o) {
        o = o.substr(5, o.length - 6).split(',');
        return {
            R: parseInt(o[0], 10),
            G: parseInt(o[1], 10),
            B: parseInt(o[2], 10),
            A: parseFloat(o[3]) * 255
        };
    };
    root.HSL_W3 = function (o) {
        return 'hsl(' + (o.H + 0.5 >> 0) + ',' + (o.S + 0.5 >> 0) + '%,' + (o.L + 0.5 >> 0) + '%)';
    };
    root.HSLA_W3 = function (o) {
        var alpha = typeof o.A === 'number' ? o.A / 255 : 1;
        return 'hsla(' + (o.H + 0.5 >> 0) + ',' + (o.S + 0.5 >> 0) + '%,' + (o.L + 0.5 >> 0) + '%,' + alpha + ')';
    };
    root.W3_HSL = function (o) {
        var start = o.indexOf('(') + 1;
        var end = o.indexOf(')');
        o = o.substr(start, end - start).split(',');
        return {
            H: parseInt(o[0], 10),
            S: parseInt(o[1], 10),
            L: parseInt(o[2], 10)
        };
    };
    root.W3_HSLA = function (o) {
        var start = o.indexOf('(') + 1;
        var end = o.indexOf(')');
        o = o.substr(start, end - start).split(',');
        return {
            H: parseInt(o[0], 10),
            S: parseInt(o[1], 10),
            L: parseInt(o[2], 10),
            A: parseFloat(o[3], 10) * 255
        };
    };
    root.W3_HEX = root.W3_HEX24 = function (o) {
        if (o.substr(0, 1) === '#')
            o = o.substr(1);
        if (o.length === 3)
            o = o[0] + o[0] + o[1] + o[1] + o[2] + o[2];
        return parseInt('0x' + o, 16);
    };
    root.W3_HEX32 = function (o) {
        if (o.substr(0, 1) === '#')
            o = o.substr(1);
        if (o.length === 6) {
            return parseInt('0xFF' + o, 10);
        } else {
            return parseInt('0x' + o, 16);
        }
    };
    root.HEX_W3 = root.HEX24_W3 = function (o, maxLength) {
        if (!maxLength)
            maxLength = 6;
        if (!o)
            o = 0;
        var n;
        var z = o.toString(16);
        n = z.length;
        while (n < maxLength) {
            z = '0' + z;
            n++;
        }
        n = z.length;
        while (n > maxLength) {
            z = z.substr(1);
            n--;
        }
        return '#' + z;
    };
    root.HEX32_W3 = function (o) {
        return root.HEX_W3(o, 8);
    };
    root.HEX_RGB = root.HEX24_RGB = function (o) {
        return {
            R: o >> 16,
            G: o >> 8 & 255,
            B: o & 255
        };
    };
    root.HEX32_RGBA = function (o) {
        return {
            R: o >>> 16 & 255,
            G: o >>> 8 & 255,
            B: o & 255,
            A: o >>> 24
        };
    };
    root.RGBA_HEX32 = function (o) {
        return (o.A << 24 | o.R << 16 | o.G << 8 | o.B) >>> 0;
    };
    root.RGB_HEX24 = root.RGB_HEX = function (o) {
        if (o.R < 0)
            o.R = 0;
        if (o.G < 0)
            o.G = 0;
        if (o.B < 0)
            o.B = 0;
        if (o.R > 255)
            o.R = 255;
        if (o.G > 255)
            o.G = 255;
        if (o.B > 255)
            o.B = 255;
        return o.R << 16 | o.G << 8 | o.B;
    };
    root.RGB_CMY = function (o) {
        return {
            C: 1 - o.R / 255,
            M: 1 - o.G / 255,
            Y: 1 - o.B / 255
        };
    };
    root.RGBA_HSLA = root.RGB_HSL = function (o) {
        var _R = o.R / 255, _G = o.G / 255, _B = o.B / 255, min = Math.min(_R, _G, _B), max = Math.max(_R, _G, _B), D = max - min, H, S, L = (max + min) / 2;
        if (D === 0) {
            H = 0;
            S = 0;
        } else {
            if (L < 0.5)
                S = D / (max + min);
            else
                S = D / (2 - max - min);
            var DR = ((max - _R) / 6 + D / 2) / D;
            var DG = ((max - _G) / 6 + D / 2) / D;
            var DB = ((max - _B) / 6 + D / 2) / D;
            if (_R === max)
                H = DB - DG;
            else if (_G === max)
                H = 1 / 3 + DR - DB;
            else if (_B === max)
                H = 2 / 3 + DG - DR;
            if (H < 0)
                H += 1;
            if (H > 1)
                H -= 1;
        }
        return {
            H: H * 360,
            S: S * 100,
            L: L * 100,
            A: o.A
        };
    };
    root.RGBA_HSVA = root.RGB_HSV = function (o) {
        var _R = o.R / 255, _G = o.G / 255, _B = o.B / 255, min = Math.min(_R, _G, _B), max = Math.max(_R, _G, _B), D = max - min, H, S, V = max;
        if (D === 0) {
            H = 0;
            S = 0;
        } else {
            S = D / max;
            var DR = ((max - _R) / 6 + D / 2) / D;
            var DG = ((max - _G) / 6 + D / 2) / D;
            var DB = ((max - _B) / 6 + D / 2) / D;
            if (_R === max)
                H = DB - DG;
            else if (_G === max)
                H = 1 / 3 + DR - DB;
            else if (_B === max)
                H = 2 / 3 + DG - DR;
            if (H < 0)
                H += 1;
            if (H > 1)
                H -= 1;
        }
        return {
            H: H * 360,
            S: S * 100,
            V: V * 100,
            A: o.A
        };
    };
    root.CMY_RGB = function (o) {
        return {
            R: Math.max(0, (1 - o.C) * 255),
            G: Math.max(0, (1 - o.M) * 255),
            B: Math.max(0, (1 - o.Y) * 255)
        };
    };
    root.CMY_CMYK = function (o) {
        var C = o.C;
        var M = o.M;
        var Y = o.Y;
        var K = Math.min(Y, Math.min(M, Math.min(C, 1)));
        C = Math.round((C - K) / (1 - K) * 100);
        M = Math.round((M - K) / (1 - K) * 100);
        Y = Math.round((Y - K) / (1 - K) * 100);
        K = Math.round(K * 100);
        return {
            C: C,
            M: M,
            Y: Y,
            K: K
        };
    };
    root.CMYK_CMY = function (o) {
        return {
            C: o.C * (1 - o.K) + o.K,
            M: o.M * (1 - o.K) + o.K,
            Y: o.Y * (1 - o.K) + o.K
        };
    };
    root.HSLA_RGBA = root.HSL_RGB = function (o) {
        var H = o.H / 360;
        var S = o.S / 100;
        var L = o.L / 100;
        var R, G, B;
        var temp1, temp2, temp3;
        if (S === 0) {
            R = G = B = L;
        } else {
            if (L < 0.5)
                temp2 = L * (1 + S);
            else
                temp2 = L + S - S * L;
            temp1 = 2 * L - temp2;
            temp3 = H + 1 / 3;
            if (temp3 < 0)
                temp3 += 1;
            if (temp3 > 1)
                temp3 -= 1;
            if (6 * temp3 < 1)
                R = temp1 + (temp2 - temp1) * 6 * temp3;
            else if (2 * temp3 < 1)
                R = temp2;
            else if (3 * temp3 < 2)
                R = temp1 + (temp2 - temp1) * (2 / 3 - temp3) * 6;
            else
                R = temp1;
            temp3 = H;
            if (temp3 < 0)
                temp3 += 1;
            if (temp3 > 1)
                temp3 -= 1;
            if (6 * temp3 < 1)
                G = temp1 + (temp2 - temp1) * 6 * temp3;
            else if (2 * temp3 < 1)
                G = temp2;
            else if (3 * temp3 < 2)
                G = temp1 + (temp2 - temp1) * (2 / 3 - temp3) * 6;
            else
                G = temp1;
            temp3 = H - 1 / 3;
            if (temp3 < 0)
                temp3 += 1;
            if (temp3 > 1)
                temp3 -= 1;
            if (6 * temp3 < 1)
                B = temp1 + (temp2 - temp1) * 6 * temp3;
            else if (2 * temp3 < 1)
                B = temp2;
            else if (3 * temp3 < 2)
                B = temp1 + (temp2 - temp1) * (2 / 3 - temp3) * 6;
            else
                B = temp1;
        }
        return {
            R: R * 255,
            G: G * 255,
            B: B * 255,
            A: o.A
        };
    };
    root.HSVA_RGBA = root.HSV_RGB = function (o) {
        var H = o.H / 360;
        var S = o.S / 100;
        var V = o.V / 100;
        var R, G, B, D, A, C;
        if (S === 0) {
            R = G = B = Math.round(V * 255);
        } else {
            if (H >= 1)
                H = 0;
            H = 6 * H;
            D = H - Math.floor(H);
            A = Math.round(255 * V * (1 - S));
            B = Math.round(255 * V * (1 - S * D));
            C = Math.round(255 * V * (1 - S * (1 - D)));
            V = Math.round(255 * V);
            switch (Math.floor(H)) {
            case 0:
                R = V;
                G = C;
                B = A;
                break;
            case 1:
                R = B;
                G = V;
                B = A;
                break;
            case 2:
                R = A;
                G = V;
                B = C;
                break;
            case 3:
                R = A;
                G = B;
                B = V;
                break;
            case 4:
                R = C;
                G = A;
                B = V;
                break;
            case 5:
                R = V;
                G = A;
                B = B;
                break;
            }
        }
        return {
            R: R,
            G: G,
            B: B,
            A: o.A
        };
    };
}());
Inlet = function () {
    function inlet(ed, options) {
        var editor = ed;
        var slider;
        var picker;
        if (!options)
            options = {};
        if (!options.picker)
            options.picker = {};
        if (!options.slider)
            options.slider = {};
        var container = options.container || document.body;
        var topOffset = options.picker.topOffset || 220;
        var bottomOffset = options.picker.bottomOffset || 16;
        var topBoundary = options.picker.topBoundary || 250;
        var leftOffset = options.picker.leftOffset || 75;
        var y_offset = options.slider.yOffset || 15;
        var wrapper = editor.getWrapperElement();
        wrapper.addEventListener('mousedown', onClick);
        editor.setOption('onKeyEvent', onKeyDown);
        var sliderDiv = document.createElement('div');
        sliderDiv.className = 'inlet_slider';
        sliderDiv.style.visibility = 'hidden';
        sliderDiv.style.position = 'absolute';
        sliderDiv.style.top = 0;
        container.appendChild(sliderDiv);
        var slider = document.createElement('input');
        slider.className = 'range';
        slider.setAttribute('type', 'range');
        slider.addEventListener('input', onSlide);
        slider.addEventListener('change', onSlide);
        slider.addEventListener('mouseup', onSlideMouseUp);
        sliderDiv.appendChild(slider);
        function onSlide(event) {
            var value = String(slider.value);
            var cursor = editor.getCursor(true);
            var number = getMatch(cursor, 'number');
            if (!number)
                return;
            var start = {
                line: cursor.line,
                ch: number.start
            };
            var end = {
                line: cursor.line,
                ch: number.end
            };
            editor.dragging = true;
            editor.replaceRange(value, start, end);
        }
        function onSlideMouseUp(event) {
            slider.value = 0;
            var cursor = editor.getCursor(true);
            var number = getMatch(cursor, 'number');
            if (!number)
                return;
            var value = parseFloat(number.string);
            var sliderRange = getSliderRange(value);
            slider.setAttribute('value', value);
            slider.setAttribute('step', sliderRange.step);
            slider.setAttribute('min', sliderRange.min);
            slider.setAttribute('max', sliderRange.max);
            slider.value = value;
            editor.dragging = false;
        }
        var LEFT = 37;
        var UP = 38;
        var RIGHT = 39;
        var DOWN = 40;
        function onKeyDown() {
            if (arguments.length == 1) {
                event = arguments[0];
            } else {
                event = arguments[1];
            }
            if (event.keyCode == LEFT || event.keyCode == DOWN) {
                if (sliderDiv.style.visibility === 'visible') {
                    slider.stepDown(1);
                    onSlide();
                    return true;
                } else if (event.altKey) {
                    onClick();
                } else {
                }
            } else if (event.keyCode == RIGHT || event.keyCode == UP) {
                if (sliderDiv.style.visibility === 'visible') {
                    slider.stepUp(1);
                    onSlide();
                    return true;
                } else if (event.altKey) {
                    onClick();
                } else {
                }
            } else {
                sliderDiv.style.visibility = 'hidden';
            }
        }
        var pickerCallback = function (color, type) {
            var cursor = editor.getCursor();
            if (!type)
                return;
            var match = getMatch(cursor, type);
            var start = {
                line: cursor.line,
                ch: match.start
            };
            var end = {
                line: cursor.line,
                ch: match.end
            };
            editor.picking = true;
            editor.replaceRange(color, start, end);
            setTimeout(function () {
                editor.picking = false;
            }, 100);
        };
        picker = new thistle.Picker('#ffffff');
        function onClick(ev) {
            var cursor = editor.getCursor(true);
            var token = editor.getTokenAt(cursor);
            cursorOffset = editor.cursorCoords(true, 'page');
            var numberMatch = getMatch(cursor, 'number');
            var hslMatch = getMatch(cursor, 'hsl');
            var hexMatch = getMatch(cursor, 'hex');
            var rgbMatch = getMatch(cursor, 'rgb');
            var pickerTop = cursorOffset.top - topOffset;
            if (cursorOffset.top < topBoundary) {
                pickerTop = cursorOffset.top + bottomOffset;
            }
            var pickerLeft = cursorOffset.left - leftOffset;
            sliderDiv.style.visibility = 'hidden';
            if (hexMatch) {
                var color = hexMatch.string;
                picker = new thistle.Picker(color);
                picker.setCSS(color);
                picker.presentModal(pickerLeft, pickerTop);
                picker.on('changed', function () {
                    picked = picker.getCSS();
                    picked = Color.Space(picked, 'W3>HSL>RGB>HEX24>W3');
                    pickerCallback(picked, 'hex');
                });
            } else if (hslMatch) {
                var color = hslMatch.string;
                picker = new thistle.Picker(color);
                picker.setCSS(color);
                picker.presentModal(pickerLeft, pickerTop);
                picker.on('changed', function () {
                    picked = picker.getCSS();
                    pickerCallback(picked, 'hsl');
                });
            } else if (rgbMatch) {
                var color = rgbMatch.string;
                picker = new thistle.Picker(color);
                picker.setCSS(color);
                picker.presentModal(pickerLeft, pickerTop);
                picker.on('changed', function () {
                    picked = picker.getCSS();
                    picked = Color.Space(picked, 'W3>HSL>RGB>W3');
                    pickerCallback(picked, 'rgb');
                });
            } else if (numberMatch) {
                slider.value = 0;
                var value = parseFloat(numberMatch.string);
                var sliderRange = getSliderRange(value);
                slider.setAttribute('value', value);
                slider.setAttribute('step', sliderRange.step);
                slider.setAttribute('min', sliderRange.min);
                slider.setAttribute('max', sliderRange.max);
                slider.value = value;
                var sliderTop = cursorOffset.top - y_offset;
                var sliderStyle = window.getComputedStyle(sliderDiv);
                var sliderWidth = getPixels(sliderStyle.width);
                var sliderLeft = cursorOffset.left - sliderWidth / 2;
                sliderDiv.style.top = sliderTop - 10 + 'px';
                sliderDiv.style.left = sliderLeft + 'px';
                sliderDiv.style.visibility = 'visible';
            } else {
            }
        }
        function getSliderRange(value) {
            var range, step, sliderMin, sliderMax;
            if (value === 0) {
                range = [
                    -100,
                    100
                ];
            } else {
                range = [
                    -value * 3,
                    value * 5
                ];
            }
            if (range[0] < range[1]) {
                min = range[0];
                max = range[1];
            } else {
                min = range[1];
                max = range[0];
            }
            if (max - min > 20) {
                step = 1;
            } else {
                step = (max - min) / 200;
            }
            return {
                min: min,
                max: max,
                step: step
            };
        }
        function getMatch(cursor, type) {
            if (!type)
                return;
            var re;
            switch (type.toLowerCase()) {
            case 'hsl':
                re = /hsla?\(\s*(\d{1,3})\s*,\s*(\d{1,3}\%)\s*,\s*(\d{1,3}\%)\s*(?:\s*,\s*(\d+(?:\.\d+)?)\s*)?\)/g;
                break;
            case 'rgb':
                re = /rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)/;
                break;
            case 'hex':
                re = /#[a-fA-F0-9]{3,6}/g;
                break;
            case 'number':
                re = /[-]?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g;
                break;
            default:
                throw new Error('invalid match selection');
                return;
            }
            var line = editor.getLine(cursor.line);
            var match = re.exec(line);
            while (match) {
                var val = match[0];
                var len = val.length;
                var start = match.index;
                var end = match.index + len;
                if (cursor.ch >= start && cursor.ch <= end) {
                    match = null;
                    return {
                        start: start,
                        end: end,
                        string: val
                    };
                }
                match = re.exec(line);
            }
            return;
        }
    }
    function getPixels(style) {
        var pix = 0;
        if (style.length > 2) {
            pix = parseFloat(style.slice(0, style.length - 2));
        }
        if (!pix)
            pix = 0;
        return pix;
    }
    function getOffset(el) {
        var _x = 0;
        var _y = 0;
        while (el && !isNaN(el.offsetLeft) && !isNaN(el.offsetTop)) {
            _x += el.offsetLeft - el.scrollLeft;
            _y += el.offsetTop - el.scrollTop;
            el = el.offsetParent;
        }
        return {
            top: _y,
            left: _x
        };
    }
    return inlet;
}();
define('inlet', [], function () {
    return;
});
define('chiasm/src/plugins/configEditor', [
    'd3',
    'model',
    'lodash',
    'bower_components/codemirror/lib/codemirror',
    'bower_components/codemirror/mode/javascript/javascript',
    'inlet'
], function (d3, Model, _, CodeMirror) {
    return function ConfigEditor(chiasm) {
        var model = Model({
            publicProperties: [
                'hidden',
                'size'
            ],
            hidden: false,
            size: '400px'
        });
        var div = d3.select(chiasm.container).append('div').style('position', 'absolute');
        var editor = CodeMirror(div.node(), {
            viewportMargin: Infinity,
            mode: 'javascript'
        });
        var oldConfigStr;
        chiasm.when('config', function (config) {
            var newConfigStr = JSON.stringify(config, null, 2);
            if (newConfigStr !== oldConfigStr) {
                editor.setValue(newConfigStr);
            }
        });
        var changeListener = _.throttle(function () {
            oldConfigStr = editor.getValue();
            chiasm.config = JSON.parse(oldConfigStr);
        }, 33);
        editor.on('change', changeListener);
        model.when('box', function (box) {
            div.style('left', box.x + 'px').style('top', box.y + 'px').style('width', box.width + 'px').style('height', box.height + 'px');
            div.select('.CodeMirror').style('height', box.height + 'px');
        });
        model.destroy = function () {
            editor.on('change', changeListener);
            editor.getWrapperElement().remove();
        };
        Inlet(editor);
        return model;
    };
});
(function (exports) {
    crossfilter.version = '1.3.11';
    function crossfilter_identity(d) {
        return d;
    }
    crossfilter.permute = permute;
    function permute(array, index) {
        for (var i = 0, n = index.length, copy = new Array(n); i < n; ++i) {
            copy[i] = array[index[i]];
        }
        return copy;
    }
    var bisect = crossfilter.bisect = bisect_by(crossfilter_identity);
    bisect.by = bisect_by;
    function bisect_by(f) {
        function bisectLeft(a, x, lo, hi) {
            while (lo < hi) {
                var mid = lo + hi >>> 1;
                if (f(a[mid]) < x)
                    lo = mid + 1;
                else
                    hi = mid;
            }
            return lo;
        }
        function bisectRight(a, x, lo, hi) {
            while (lo < hi) {
                var mid = lo + hi >>> 1;
                if (x < f(a[mid]))
                    hi = mid;
                else
                    lo = mid + 1;
            }
            return lo;
        }
        bisectRight.right = bisectRight;
        bisectRight.left = bisectLeft;
        return bisectRight;
    }
    var heap = crossfilter.heap = heap_by(crossfilter_identity);
    heap.by = heap_by;
    function heap_by(f) {
        function heap(a, lo, hi) {
            var n = hi - lo, i = (n >>> 1) + 1;
            while (--i > 0)
                sift(a, i, n, lo);
            return a;
        }
        function sort(a, lo, hi) {
            var n = hi - lo, t;
            while (--n > 0)
                t = a[lo], a[lo] = a[lo + n], a[lo + n] = t, sift(a, 1, n, lo);
            return a;
        }
        function sift(a, i, n, lo) {
            var d = a[--lo + i], x = f(d), child;
            while ((child = i << 1) <= n) {
                if (child < n && f(a[lo + child]) > f(a[lo + child + 1]))
                    child++;
                if (x <= f(a[lo + child]))
                    break;
                a[lo + i] = a[lo + child];
                i = child;
            }
            a[lo + i] = d;
        }
        heap.sort = sort;
        return heap;
    }
    var heapselect = crossfilter.heapselect = heapselect_by(crossfilter_identity);
    heapselect.by = heapselect_by;
    function heapselect_by(f) {
        var heap = heap_by(f);
        function heapselect(a, lo, hi, k) {
            var queue = new Array(k = Math.min(hi - lo, k)), min, i, x, d;
            for (i = 0; i < k; ++i)
                queue[i] = a[lo++];
            heap(queue, 0, k);
            if (lo < hi) {
                min = f(queue[0]);
                do {
                    if (x = f(d = a[lo]) > min) {
                        queue[0] = d;
                        min = f(heap(queue, 0, k)[0]);
                    }
                } while (++lo < hi);
            }
            return queue;
        }
        return heapselect;
    }
    var insertionsort = crossfilter.insertionsort = insertionsort_by(crossfilter_identity);
    insertionsort.by = insertionsort_by;
    function insertionsort_by(f) {
        function insertionsort(a, lo, hi) {
            for (var i = lo + 1; i < hi; ++i) {
                for (var j = i, t = a[i], x = f(t); j > lo && f(a[j - 1]) > x; --j) {
                    a[j] = a[j - 1];
                }
                a[j] = t;
            }
            return a;
        }
        return insertionsort;
    }
    var quicksort = crossfilter.quicksort = quicksort_by(crossfilter_identity);
    quicksort.by = quicksort_by;
    function quicksort_by(f) {
        var insertionsort = insertionsort_by(f);
        function sort(a, lo, hi) {
            return (hi - lo < quicksort_sizeThreshold ? insertionsort : quicksort)(a, lo, hi);
        }
        function quicksort(a, lo, hi) {
            var sixth = (hi - lo) / 6 | 0, i1 = lo + sixth, i5 = hi - 1 - sixth, i3 = lo + hi - 1 >> 1, i2 = i3 - sixth, i4 = i3 + sixth;
            var e1 = a[i1], x1 = f(e1), e2 = a[i2], x2 = f(e2), e3 = a[i3], x3 = f(e3), e4 = a[i4], x4 = f(e4), e5 = a[i5], x5 = f(e5);
            var t;
            if (x1 > x2)
                t = e1, e1 = e2, e2 = t, t = x1, x1 = x2, x2 = t;
            if (x4 > x5)
                t = e4, e4 = e5, e5 = t, t = x4, x4 = x5, x5 = t;
            if (x1 > x3)
                t = e1, e1 = e3, e3 = t, t = x1, x1 = x3, x3 = t;
            if (x2 > x3)
                t = e2, e2 = e3, e3 = t, t = x2, x2 = x3, x3 = t;
            if (x1 > x4)
                t = e1, e1 = e4, e4 = t, t = x1, x1 = x4, x4 = t;
            if (x3 > x4)
                t = e3, e3 = e4, e4 = t, t = x3, x3 = x4, x4 = t;
            if (x2 > x5)
                t = e2, e2 = e5, e5 = t, t = x2, x2 = x5, x5 = t;
            if (x2 > x3)
                t = e2, e2 = e3, e3 = t, t = x2, x2 = x3, x3 = t;
            if (x4 > x5)
                t = e4, e4 = e5, e5 = t, t = x4, x4 = x5, x5 = t;
            var pivot1 = e2, pivotValue1 = x2, pivot2 = e4, pivotValue2 = x4;
            a[i1] = e1;
            a[i2] = a[lo];
            a[i3] = e3;
            a[i4] = a[hi - 1];
            a[i5] = e5;
            var less = lo + 1, great = hi - 2;
            var pivotsEqual = pivotValue1 <= pivotValue2 && pivotValue1 >= pivotValue2;
            if (pivotsEqual) {
                for (var k = less; k <= great; ++k) {
                    var ek = a[k], xk = f(ek);
                    if (xk < pivotValue1) {
                        if (k !== less) {
                            a[k] = a[less];
                            a[less] = ek;
                        }
                        ++less;
                    } else if (xk > pivotValue1) {
                        while (true) {
                            var greatValue = f(a[great]);
                            if (greatValue > pivotValue1) {
                                great--;
                                continue;
                            } else if (greatValue < pivotValue1) {
                                a[k] = a[less];
                                a[less++] = a[great];
                                a[great--] = ek;
                                break;
                            } else {
                                a[k] = a[great];
                                a[great--] = ek;
                                break;
                            }
                        }
                    }
                }
            } else {
                for (var k = less; k <= great; k++) {
                    var ek = a[k], xk = f(ek);
                    if (xk < pivotValue1) {
                        if (k !== less) {
                            a[k] = a[less];
                            a[less] = ek;
                        }
                        ++less;
                    } else {
                        if (xk > pivotValue2) {
                            while (true) {
                                var greatValue = f(a[great]);
                                if (greatValue > pivotValue2) {
                                    great--;
                                    if (great < k)
                                        break;
                                    continue;
                                } else {
                                    if (greatValue < pivotValue1) {
                                        a[k] = a[less];
                                        a[less++] = a[great];
                                        a[great--] = ek;
                                    } else {
                                        a[k] = a[great];
                                        a[great--] = ek;
                                    }
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            a[lo] = a[less - 1];
            a[less - 1] = pivot1;
            a[hi - 1] = a[great + 1];
            a[great + 1] = pivot2;
            sort(a, lo, less - 1);
            sort(a, great + 2, hi);
            if (pivotsEqual) {
                return a;
            }
            if (less < i1 && great > i5) {
                var lessValue, greatValue;
                while ((lessValue = f(a[less])) <= pivotValue1 && lessValue >= pivotValue1)
                    ++less;
                while ((greatValue = f(a[great])) <= pivotValue2 && greatValue >= pivotValue2)
                    --great;
                for (var k = less; k <= great; k++) {
                    var ek = a[k], xk = f(ek);
                    if (xk <= pivotValue1 && xk >= pivotValue1) {
                        if (k !== less) {
                            a[k] = a[less];
                            a[less] = ek;
                        }
                        less++;
                    } else {
                        if (xk <= pivotValue2 && xk >= pivotValue2) {
                            while (true) {
                                var greatValue = f(a[great]);
                                if (greatValue <= pivotValue2 && greatValue >= pivotValue2) {
                                    great--;
                                    if (great < k)
                                        break;
                                    continue;
                                } else {
                                    if (greatValue < pivotValue1) {
                                        a[k] = a[less];
                                        a[less++] = a[great];
                                        a[great--] = ek;
                                    } else {
                                        a[k] = a[great];
                                        a[great--] = ek;
                                    }
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            return sort(a, less, great + 1);
        }
        return sort;
    }
    var quicksort_sizeThreshold = 32;
    var crossfilter_array8 = crossfilter_arrayUntyped, crossfilter_array16 = crossfilter_arrayUntyped, crossfilter_array32 = crossfilter_arrayUntyped, crossfilter_arrayLengthen = crossfilter_arrayLengthenUntyped, crossfilter_arrayWiden = crossfilter_arrayWidenUntyped;
    if (typeof Uint8Array !== 'undefined') {
        crossfilter_array8 = function (n) {
            return new Uint8Array(n);
        };
        crossfilter_array16 = function (n) {
            return new Uint16Array(n);
        };
        crossfilter_array32 = function (n) {
            return new Uint32Array(n);
        };
        crossfilter_arrayLengthen = function (array, length) {
            if (array.length >= length)
                return array;
            var copy = new array.constructor(length);
            copy.set(array);
            return copy;
        };
        crossfilter_arrayWiden = function (array, width) {
            var copy;
            switch (width) {
            case 16:
                copy = crossfilter_array16(array.length);
                break;
            case 32:
                copy = crossfilter_array32(array.length);
                break;
            default:
                throw new Error('invalid array width!');
            }
            copy.set(array);
            return copy;
        };
    }
    function crossfilter_arrayUntyped(n) {
        var array = new Array(n), i = -1;
        while (++i < n)
            array[i] = 0;
        return array;
    }
    function crossfilter_arrayLengthenUntyped(array, length) {
        var n = array.length;
        while (n < length)
            array[n++] = 0;
        return array;
    }
    function crossfilter_arrayWidenUntyped(array, width) {
        if (width > 32)
            throw new Error('invalid array width!');
        return array;
    }
    function crossfilter_filterExact(bisect, value) {
        return function (values) {
            var n = values.length;
            return [
                bisect.left(values, value, 0, n),
                bisect.right(values, value, 0, n)
            ];
        };
    }
    function crossfilter_filterRange(bisect, range) {
        var min = range[0], max = range[1];
        return function (values) {
            var n = values.length;
            return [
                bisect.left(values, min, 0, n),
                bisect.left(values, max, 0, n)
            ];
        };
    }
    function crossfilter_filterAll(values) {
        return [
            0,
            values.length
        ];
    }
    function crossfilter_null() {
        return null;
    }
    function crossfilter_zero() {
        return 0;
    }
    function crossfilter_reduceIncrement(p) {
        return p + 1;
    }
    function crossfilter_reduceDecrement(p) {
        return p - 1;
    }
    function crossfilter_reduceAdd(f) {
        return function (p, v) {
            return p + +f(v);
        };
    }
    function crossfilter_reduceSubtract(f) {
        return function (p, v) {
            return p - f(v);
        };
    }
    exports.crossfilter = crossfilter;
    function crossfilter() {
        var crossfilter = {
            add: add,
            remove: removeData,
            dimension: dimension,
            groupAll: groupAll,
            size: size
        };
        var data = [], n = 0, m = 0, M = 8, filters = crossfilter_array8(0), filterListeners = [], dataListeners = [], removeDataListeners = [];
        function add(newData) {
            var n0 = n, n1 = newData.length;
            if (n1) {
                data = data.concat(newData);
                filters = crossfilter_arrayLengthen(filters, n += n1);
                dataListeners.forEach(function (l) {
                    l(newData, n0, n1);
                });
            }
            return crossfilter;
        }
        function removeData() {
            var newIndex = crossfilter_index(n, n), removed = [];
            for (var i = 0, j = 0; i < n; ++i) {
                if (filters[i])
                    newIndex[i] = j++;
                else
                    removed.push(i);
            }
            filterListeners.forEach(function (l) {
                l(0, [], removed);
            });
            removeDataListeners.forEach(function (l) {
                l(newIndex);
            });
            for (var i = 0, j = 0, k; i < n; ++i) {
                if (k = filters[i]) {
                    if (i !== j)
                        filters[j] = k, data[j] = data[i];
                    ++j;
                }
            }
            data.length = j;
            while (n > j)
                filters[--n] = 0;
        }
        function dimension(value) {
            var dimension = {
                filter: filter,
                filterExact: filterExact,
                filterRange: filterRange,
                filterFunction: filterFunction,
                filterAll: filterAll,
                top: top,
                bottom: bottom,
                group: group,
                groupAll: groupAll,
                dispose: dispose,
                remove: dispose
            };
            var one = ~m & -~m, zero = ~one, values, index, newValues, newIndex, sort = quicksort_by(function (i) {
                    return newValues[i];
                }), refilter = crossfilter_filterAll, refilterFunction, indexListeners = [], dimensionGroups = [], lo0 = 0, hi0 = 0;
            dataListeners.unshift(preAdd);
            dataListeners.push(postAdd);
            removeDataListeners.push(removeData);
            m |= one;
            if (M >= 32 ? !one : m & (1 << M) - 1) {
                filters = crossfilter_arrayWiden(filters, M <<= 1);
            }
            preAdd(data, 0, n);
            postAdd(data, 0, n);
            function preAdd(newData, n0, n1) {
                newValues = newData.map(value);
                newIndex = sort(crossfilter_range(n1), 0, n1);
                newValues = permute(newValues, newIndex);
                var bounds = refilter(newValues), lo1 = bounds[0], hi1 = bounds[1], i;
                if (refilterFunction) {
                    for (i = 0; i < n1; ++i) {
                        if (!refilterFunction(newValues[i], i))
                            filters[newIndex[i] + n0] |= one;
                    }
                } else {
                    for (i = 0; i < lo1; ++i)
                        filters[newIndex[i] + n0] |= one;
                    for (i = hi1; i < n1; ++i)
                        filters[newIndex[i] + n0] |= one;
                }
                if (!n0) {
                    values = newValues;
                    index = newIndex;
                    lo0 = lo1;
                    hi0 = hi1;
                    return;
                }
                var oldValues = values, oldIndex = index, i0 = 0, i1 = 0;
                values = new Array(n);
                index = crossfilter_index(n, n);
                for (i = 0; i0 < n0 && i1 < n1; ++i) {
                    if (oldValues[i0] < newValues[i1]) {
                        values[i] = oldValues[i0];
                        index[i] = oldIndex[i0++];
                    } else {
                        values[i] = newValues[i1];
                        index[i] = newIndex[i1++] + n0;
                    }
                }
                for (; i0 < n0; ++i0, ++i) {
                    values[i] = oldValues[i0];
                    index[i] = oldIndex[i0];
                }
                for (; i1 < n1; ++i1, ++i) {
                    values[i] = newValues[i1];
                    index[i] = newIndex[i1] + n0;
                }
                bounds = refilter(values), lo0 = bounds[0], hi0 = bounds[1];
            }
            function postAdd(newData, n0, n1) {
                indexListeners.forEach(function (l) {
                    l(newValues, newIndex, n0, n1);
                });
                newValues = newIndex = null;
            }
            function removeData(reIndex) {
                for (var i = 0, j = 0, k; i < n; ++i) {
                    if (filters[k = index[i]]) {
                        if (i !== j)
                            values[j] = values[i];
                        index[j] = reIndex[k];
                        ++j;
                    }
                }
                values.length = j;
                while (j < n)
                    index[j++] = 0;
                var bounds = refilter(values);
                lo0 = bounds[0], hi0 = bounds[1];
            }
            function filterIndexBounds(bounds) {
                var lo1 = bounds[0], hi1 = bounds[1];
                if (refilterFunction) {
                    refilterFunction = null;
                    filterIndexFunction(function (d, i) {
                        return lo1 <= i && i < hi1;
                    });
                    lo0 = lo1;
                    hi0 = hi1;
                    return dimension;
                }
                var i, j, k, added = [], removed = [];
                if (lo1 < lo0) {
                    for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {
                        filters[k = index[i]] ^= one;
                        added.push(k);
                    }
                } else if (lo1 > lo0) {
                    for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {
                        filters[k = index[i]] ^= one;
                        removed.push(k);
                    }
                }
                if (hi1 > hi0) {
                    for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {
                        filters[k = index[i]] ^= one;
                        added.push(k);
                    }
                } else if (hi1 < hi0) {
                    for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {
                        filters[k = index[i]] ^= one;
                        removed.push(k);
                    }
                }
                lo0 = lo1;
                hi0 = hi1;
                filterListeners.forEach(function (l) {
                    l(one, added, removed);
                });
                return dimension;
            }
            function filter(range) {
                return range == null ? filterAll() : Array.isArray(range) ? filterRange(range) : typeof range === 'function' ? filterFunction(range) : filterExact(range);
            }
            function filterExact(value) {
                return filterIndexBounds((refilter = crossfilter_filterExact(bisect, value))(values));
            }
            function filterRange(range) {
                return filterIndexBounds((refilter = crossfilter_filterRange(bisect, range))(values));
            }
            function filterAll() {
                return filterIndexBounds((refilter = crossfilter_filterAll)(values));
            }
            function filterFunction(f) {
                refilter = crossfilter_filterAll;
                filterIndexFunction(refilterFunction = f);
                lo0 = 0;
                hi0 = n;
                return dimension;
            }
            function filterIndexFunction(f) {
                var i, k, x, added = [], removed = [];
                for (i = 0; i < n; ++i) {
                    if (!(filters[k = index[i]] & one) ^ !!(x = f(values[i], i))) {
                        if (x)
                            filters[k] &= zero, added.push(k);
                        else
                            filters[k] |= one, removed.push(k);
                    }
                }
                filterListeners.forEach(function (l) {
                    l(one, added, removed);
                });
            }
            function top(k) {
                var array = [], i = hi0, j;
                while (--i >= lo0 && k > 0) {
                    if (!filters[j = index[i]]) {
                        array.push(data[j]);
                        --k;
                    }
                }
                return array;
            }
            function bottom(k) {
                var array = [], i = lo0, j;
                while (i < hi0 && k > 0) {
                    if (!filters[j = index[i]]) {
                        array.push(data[j]);
                        --k;
                    }
                    i++;
                }
                return array;
            }
            function group(key) {
                var group = {
                    top: top,
                    all: all,
                    reduce: reduce,
                    reduceCount: reduceCount,
                    reduceSum: reduceSum,
                    order: order,
                    orderNatural: orderNatural,
                    size: size,
                    dispose: dispose,
                    remove: dispose
                };
                dimensionGroups.push(group);
                var groups, groupIndex, groupWidth = 8, groupCapacity = crossfilter_capacity(groupWidth), k = 0, select, heap, reduceAdd, reduceRemove, reduceInitial, update = crossfilter_null, reset = crossfilter_null, resetNeeded = true, groupAll = key === crossfilter_null;
                if (arguments.length < 1)
                    key = crossfilter_identity;
                filterListeners.push(update);
                indexListeners.push(add);
                removeDataListeners.push(removeData);
                add(values, index, 0, n);
                function add(newValues, newIndex, n0, n1) {
                    var oldGroups = groups, reIndex = crossfilter_index(k, groupCapacity), add = reduceAdd, initial = reduceInitial, k0 = k, i0 = 0, i1 = 0, j, g0, x0, x1, g, x;
                    if (resetNeeded)
                        add = initial = crossfilter_null;
                    groups = new Array(k), k = 0;
                    groupIndex = k0 > 1 ? crossfilter_arrayLengthen(groupIndex, n) : crossfilter_index(n, groupCapacity);
                    if (k0)
                        x0 = (g0 = oldGroups[0]).key;
                    while (i1 < n1 && !((x1 = key(newValues[i1])) >= x1))
                        ++i1;
                    while (i1 < n1) {
                        if (g0 && x0 <= x1) {
                            g = g0, x = x0;
                            reIndex[i0] = k;
                            if (g0 = oldGroups[++i0])
                                x0 = g0.key;
                        } else {
                            g = {
                                key: x1,
                                value: initial()
                            }, x = x1;
                        }
                        groups[k] = g;
                        while (!(x1 > x)) {
                            groupIndex[j = newIndex[i1] + n0] = k;
                            if (!(filters[j] & zero))
                                g.value = add(g.value, data[j]);
                            if (++i1 >= n1)
                                break;
                            x1 = key(newValues[i1]);
                        }
                        groupIncrement();
                    }
                    while (i0 < k0) {
                        groups[reIndex[i0] = k] = oldGroups[i0++];
                        groupIncrement();
                    }
                    if (k > i0)
                        for (i0 = 0; i0 < n0; ++i0) {
                            groupIndex[i0] = reIndex[groupIndex[i0]];
                        }
                    j = filterListeners.indexOf(update);
                    if (k > 1) {
                        update = updateMany;
                        reset = resetMany;
                    } else {
                        if (!k && groupAll) {
                            k = 1;
                            groups = [{
                                    key: null,
                                    value: initial()
                                }];
                        }
                        if (k === 1) {
                            update = updateOne;
                            reset = resetOne;
                        } else {
                            update = crossfilter_null;
                            reset = crossfilter_null;
                        }
                        groupIndex = null;
                    }
                    filterListeners[j] = update;
                    function groupIncrement() {
                        if (++k === groupCapacity) {
                            reIndex = crossfilter_arrayWiden(reIndex, groupWidth <<= 1);
                            groupIndex = crossfilter_arrayWiden(groupIndex, groupWidth);
                            groupCapacity = crossfilter_capacity(groupWidth);
                        }
                    }
                }
                function removeData() {
                    if (k > 1) {
                        var oldK = k, oldGroups = groups, seenGroups = crossfilter_index(oldK, oldK);
                        for (var i = 0, j = 0; i < n; ++i) {
                            if (filters[i]) {
                                seenGroups[groupIndex[j] = groupIndex[i]] = 1;
                                ++j;
                            }
                        }
                        groups = [], k = 0;
                        for (i = 0; i < oldK; ++i) {
                            if (seenGroups[i]) {
                                seenGroups[i] = k++;
                                groups.push(oldGroups[i]);
                            }
                        }
                        if (k > 1) {
                            for (var i = 0; i < j; ++i)
                                groupIndex[i] = seenGroups[groupIndex[i]];
                        } else {
                            groupIndex = null;
                        }
                        filterListeners[filterListeners.indexOf(update)] = k > 1 ? (reset = resetMany, update = updateMany) : k === 1 ? (reset = resetOne, update = updateOne) : reset = update = crossfilter_null;
                    } else if (k === 1) {
                        if (groupAll)
                            return;
                        for (var i = 0; i < n; ++i)
                            if (filters[i])
                                return;
                        groups = [], k = 0;
                        filterListeners[filterListeners.indexOf(update)] = update = reset = crossfilter_null;
                    }
                }
                function updateMany(filterOne, added, removed) {
                    if (filterOne === one || resetNeeded)
                        return;
                    var i, k, n, g;
                    for (i = 0, n = added.length; i < n; ++i) {
                        if (!(filters[k = added[i]] & zero)) {
                            g = groups[groupIndex[k]];
                            g.value = reduceAdd(g.value, data[k]);
                        }
                    }
                    for (i = 0, n = removed.length; i < n; ++i) {
                        if ((filters[k = removed[i]] & zero) === filterOne) {
                            g = groups[groupIndex[k]];
                            g.value = reduceRemove(g.value, data[k]);
                        }
                    }
                }
                function updateOne(filterOne, added, removed) {
                    if (filterOne === one || resetNeeded)
                        return;
                    var i, k, n, g = groups[0];
                    for (i = 0, n = added.length; i < n; ++i) {
                        if (!(filters[k = added[i]] & zero)) {
                            g.value = reduceAdd(g.value, data[k]);
                        }
                    }
                    for (i = 0, n = removed.length; i < n; ++i) {
                        if ((filters[k = removed[i]] & zero) === filterOne) {
                            g.value = reduceRemove(g.value, data[k]);
                        }
                    }
                }
                function resetMany() {
                    var i, g;
                    for (i = 0; i < k; ++i) {
                        groups[i].value = reduceInitial();
                    }
                    for (i = 0; i < n; ++i) {
                        if (!(filters[i] & zero)) {
                            g = groups[groupIndex[i]];
                            g.value = reduceAdd(g.value, data[i]);
                        }
                    }
                }
                function resetOne() {
                    var i, g = groups[0];
                    g.value = reduceInitial();
                    for (i = 0; i < n; ++i) {
                        if (!(filters[i] & zero)) {
                            g.value = reduceAdd(g.value, data[i]);
                        }
                    }
                }
                function all() {
                    if (resetNeeded)
                        reset(), resetNeeded = false;
                    return groups;
                }
                function top(k) {
                    var top = select(all(), 0, groups.length, k);
                    return heap.sort(top, 0, top.length);
                }
                function reduce(add, remove, initial) {
                    reduceAdd = add;
                    reduceRemove = remove;
                    reduceInitial = initial;
                    resetNeeded = true;
                    return group;
                }
                function reduceCount() {
                    return reduce(crossfilter_reduceIncrement, crossfilter_reduceDecrement, crossfilter_zero);
                }
                function reduceSum(value) {
                    return reduce(crossfilter_reduceAdd(value), crossfilter_reduceSubtract(value), crossfilter_zero);
                }
                function order(value) {
                    select = heapselect_by(valueOf);
                    heap = heap_by(valueOf);
                    function valueOf(d) {
                        return value(d.value);
                    }
                    return group;
                }
                function orderNatural() {
                    return order(crossfilter_identity);
                }
                function size() {
                    return k;
                }
                function dispose() {
                    var i = filterListeners.indexOf(update);
                    if (i >= 0)
                        filterListeners.splice(i, 1);
                    i = indexListeners.indexOf(add);
                    if (i >= 0)
                        indexListeners.splice(i, 1);
                    i = removeDataListeners.indexOf(removeData);
                    if (i >= 0)
                        removeDataListeners.splice(i, 1);
                    return group;
                }
                return reduceCount().orderNatural();
            }
            function groupAll() {
                var g = group(crossfilter_null), all = g.all;
                delete g.all;
                delete g.top;
                delete g.order;
                delete g.orderNatural;
                delete g.size;
                g.value = function () {
                    return all()[0].value;
                };
                return g;
            }
            function dispose() {
                dimensionGroups.forEach(function (group) {
                    group.dispose();
                });
                var i = dataListeners.indexOf(preAdd);
                if (i >= 0)
                    dataListeners.splice(i, 1);
                i = dataListeners.indexOf(postAdd);
                if (i >= 0)
                    dataListeners.splice(i, 1);
                i = removeDataListeners.indexOf(removeData);
                if (i >= 0)
                    removeDataListeners.splice(i, 1);
                m &= zero;
                return filterAll();
            }
            return dimension;
        }
        function groupAll() {
            var group = {
                reduce: reduce,
                reduceCount: reduceCount,
                reduceSum: reduceSum,
                value: value,
                dispose: dispose,
                remove: dispose
            };
            var reduceValue, reduceAdd, reduceRemove, reduceInitial, resetNeeded = true;
            filterListeners.push(update);
            dataListeners.push(add);
            add(data, 0, n);
            function add(newData, n0) {
                var i;
                if (resetNeeded)
                    return;
                for (i = n0; i < n; ++i) {
                    if (!filters[i]) {
                        reduceValue = reduceAdd(reduceValue, data[i]);
                    }
                }
            }
            function update(filterOne, added, removed) {
                var i, k, n;
                if (resetNeeded)
                    return;
                for (i = 0, n = added.length; i < n; ++i) {
                    if (!filters[k = added[i]]) {
                        reduceValue = reduceAdd(reduceValue, data[k]);
                    }
                }
                for (i = 0, n = removed.length; i < n; ++i) {
                    if (filters[k = removed[i]] === filterOne) {
                        reduceValue = reduceRemove(reduceValue, data[k]);
                    }
                }
            }
            function reset() {
                var i;
                reduceValue = reduceInitial();
                for (i = 0; i < n; ++i) {
                    if (!filters[i]) {
                        reduceValue = reduceAdd(reduceValue, data[i]);
                    }
                }
            }
            function reduce(add, remove, initial) {
                reduceAdd = add;
                reduceRemove = remove;
                reduceInitial = initial;
                resetNeeded = true;
                return group;
            }
            function reduceCount() {
                return reduce(crossfilter_reduceIncrement, crossfilter_reduceDecrement, crossfilter_zero);
            }
            function reduceSum(value) {
                return reduce(crossfilter_reduceAdd(value), crossfilter_reduceSubtract(value), crossfilter_zero);
            }
            function value() {
                if (resetNeeded)
                    reset(), resetNeeded = false;
                return reduceValue;
            }
            function dispose() {
                var i = filterListeners.indexOf(update);
                if (i >= 0)
                    filterListeners.splice(i);
                i = dataListeners.indexOf(add);
                if (i >= 0)
                    dataListeners.splice(i);
                return group;
            }
            return reduceCount();
        }
        function size() {
            return n;
        }
        return arguments.length ? add(arguments[0]) : crossfilter;
    }
    function crossfilter_index(n, m) {
        return (m < 257 ? crossfilter_array8 : m < 65537 ? crossfilter_array16 : crossfilter_array32)(n);
    }
    function crossfilter_range(n) {
        var range = crossfilter_index(n, n);
        for (var i = -1; ++i < n;)
            range[i] = i;
        return range;
    }
    function crossfilter_capacity(w) {
        return w === 8 ? 256 : w === 16 ? 65536 : 4294967296;
    }
}(typeof exports !== 'undefined' && exports || this));
define('crossfilter', [], function () {
    return;
});
define('chiasm/src/plugins/crossfilter', [
    'model',
    'crossfilter'
], function (Model) {
    return function () {
        var model = Model({
            publicProperties: ['dimensions'],
            dimensions: []
        });
        var listeners = [];
        model.when([
            'data',
            'dimensions'
        ], function (data, dimensionProperties) {
            var observation = crossfilter(data), dimensions = {};
            listeners.forEach(model.cancel);
            listeners = [];
            dimensionProperties.forEach(function (property) {
                var dimension = observation.dimension(function (d) {
                    return d[property];
                });
                dimensions[property] = dimension;
                listeners.push(model.when(property + 'Filter', function (filter) {
                    dimension.filter(filter);
                    updateAll();
                }));
            });
            function updateAll() {
                dimensionProperties.forEach(function (property) {
                    model[property + 'Top'] = dimensions[property].top(Infinity);
                });
            }
            updateAll();
        });
        return model;
    };
});
define('chiasm/src/plugins/csvLoader', [
    'd3',
    'model'
], function (d3, Model) {
    return function CsvLoader() {
        var model = Model({
            publicProperties: [
                'csvPath',
                'numericColumns',
                'timeColumns'
            ],
            csvPath: Model.None,
            numericColumns: [],
            timeColumns: []
        });
        model.when([
            'csvPath',
            'numericColumns',
            'timeColumns'
        ], function (csvPath, numericColumns, timeColumns) {
            if (csvPath !== Model.None) {
                d3.csv(csvPath, function (d) {
                    numericColumns.forEach(function (column) {
                        d[column] = +d[column];
                    });
                    timeColumns.forEach(function (column) {
                        d[column] = new Date(d[column]);
                    });
                    return d;
                }, function (err, data) {
                    model.data = data;
                });
            }
        });
        return model;
    };
});
define('chiasm/src/plugins/dummyVis', [
    'd3',
    'model'
], function (d3, Model) {
    return function DummyVis(chiasm) {
        var model = Model({
            publicProperties: [
                'color',
                'text',
                'lineWidth',
                'size'
            ],
            color: 'white',
            text: '',
            lineWidth: 8,
            size: 1
        });
        var svg = d3.select(chiasm.container).append('svg').style('position', 'absolute');
        var rect = svg.append('rect').attr('x', 0).attr('y', 0);
        var text = svg.append('text').attr('font-size', '7em').attr('text-anchor', 'middle').attr('alignment-baseline', 'middle');
        var lineDrag = function () {
            var x1, x2;
            return d3.behavior.drag().on('dragstart', function (d) {
                x1 = d3.event.sourceEvent.pageX;
            }).on('drag', function (d) {
                var x2 = d3.event.sourceEvent.pageX, newLineWidth = model.lineWidth + x2 - x1;
                newLineWidth = newLineWidth < 1 ? 1 : newLineWidth;
                model.lineWidth = newLineWidth;
                x1 = x2;
            });
        }();
        model.when('color', function (color) {
            rect.attr('fill', color);
        });
        model.when('text', text.text, text);
        model.when('box', function (box) {
            svg.style('left', box.x + 'px').style('top', box.y + 'px');
            svg.attr('width', box.width).attr('height', box.height);
            rect.attr('width', box.width).attr('height', box.height);
            text.attr('x', box.width / 2).attr('y', box.height / 2);
        });
        model.when([
            'box',
            'lineWidth'
        ], function (box, lineWidth) {
            var w = box.width, h = box.height, lines = svg.selectAll('line').data([
                    {
                        x1: 0,
                        y1: 0,
                        x2: w,
                        y2: h
                    },
                    {
                        x1: 0,
                        y1: h,
                        x2: w,
                        y2: 0
                    }
                ]);
            lines.enter().append('line');
            lines.attr('x1', function (d) {
                return d.x1;
            }).attr('y1', function (d) {
                return d.y1;
            }).attr('x2', function (d) {
                return d.x2;
            }).attr('y2', function (d) {
                return d.y2;
            }).style('stroke-width', lineWidth).style('stroke-opacity', 0.2).style('stroke', 'black').call(lineDrag);
        });
        model.destroy = function () {
            chiasm.container.removeChild(svg.node());
        };
        return model;
    };
});
define('chiasm/src/plugins/layout', [
    'chiasm/src/plugins/computeLayout',
    'model',
    'lodash'
], function (computeLayout, Model, _) {
    return function Layout(chiasm) {
        var model = Model({
            publicProperties: ['layout'],
            layout: {}
        });
        function setBox() {
            model.box = {
                x: 0,
                y: 0,
                width: chiasm.container.clientWidth,
                height: chiasm.container.clientHeight
            };
        }
        setBox();
        window.addEventListener('resize', setBox);
        model.when([
            'layout',
            'sizes',
            'box'
        ], function (layout, sizes, box) {
            var boxes = computeLayout(layout, sizes, box);
            Object.keys(boxes).forEach(function (alias) {
                chiasm.getComponent(alias).then(function (component) {
                    component.box = boxes[alias];
                });
            });
        });
        model.when(['layout'], function (layout) {
            var aliases = aliasesInLayout(layout);
            extractSizes(aliases);
            aliases.forEach(function (alias) {
                chiasm.getComponent(alias).then(function (component) {
                    component.when('size', function (size) {
                        extractSizes(aliases);
                    });
                });
            });
        });
        function extractSizes(aliases) {
            var sizes = {};
            Promise.all(aliases.map(function (alias) {
                return new Promise(function (resolve, reject) {
                    chiasm.getComponent(alias).then(function (component) {
                        if (component.size || component.hidden) {
                            sizes[alias] = {};
                            if (component.size) {
                                sizes[alias].size = component.size;
                            }
                            if (component.hidden) {
                                sizes[alias].hidden = component.hidden;
                            }
                        }
                        resolve();
                    }, reject);
                });
            })).then(function () {
                if (!_.isEqual(model.sizes, sizes)) {
                    model.sizes = sizes;
                }
            }, function (err) {
                throw err;
            });
        }
        function aliasesInLayout(layout) {
            var aliases = [];
            if (isLeafNode(layout)) {
                aliases.push(layout);
            } else {
                layout.children.forEach(function (child) {
                    aliases.push.apply(aliases, aliasesInLayout(child));
                });
            }
            return aliases;
        }
        function isLeafNode(layout) {
            return typeof layout === 'string';
        }
        return model;
    };
});
define('chiasm/src/plugins/lineChart', [
    'chiasm/src/plugins/reactivis',
    'd3',
    'model'
], function (reactivis, d3, Model) {
    var None = Model.None;
    return function LineChart(chiasm) {
        var model = Model();
        model.container = chiasm.container;
        reactivis.svg(model);
        reactivis.title(model);
        reactivis.margin(model);
        reactivis.color(model);
        reactivis.xAccessor(model);
        reactivis.xScale(model, 'time');
        reactivis.xAxis(model);
        reactivis.yAccessor(model);
        reactivis.yAxis(model);
        model.when([
            'data',
            'yAccessor'
        ], function (data, yAccessor) {
            model.yDomain = d3.extent(data, yAccessor);
        });
        model.when([
            'data',
            'yDomain',
            'height'
        ], function (data, yDomain, height) {
            model.yScale = d3.scale.linear().domain(yDomain).range([
                height,
                0
            ]);
        });
        model.when([
            'data',
            'yScale',
            'yAccessor'
        ], function (data, yScale, yAccessor) {
            model.y = function (d) {
                return yScale(yAccessor(d));
            };
        });
        model.when('g', function (g) {
            model.lineG = g.append('g');
        });
        model.lineColumn = None;
        model.when([
            'lineG',
            'data',
            'lineColumn',
            'x',
            'y',
            'color'
        ], function (lineG, data, lineColumn, x, y, color) {
            var linesData = d3.nest().key(function (d) {
                    if (lineColumn !== None) {
                        return d[lineColumn];
                    } else {
                        return 'X';
                    }
                }).entries(data), line = d3.svg.line().x(x).y(y), lines = lineG.selectAll('.line').data(linesData);
            lines.enter().append('path').attr('class', 'line');
            lines.attr('d', function (d) {
                return line(d.values);
            }).style('stroke', color);
            lines.exit().remove();
        });
        model.destroy = function () {
            if (model.container && model.svg) {
                model.svg.node().innerHTML = '';
                model.container.removeChild(model.svg.node());
            }
        };
        return model;
    };
});
define('chiasm/src/plugins/links', [
    'd3',
    'model'
], function (d3, Model) {
    return function Links(chiasm) {
        var model = Model({
            publicProperties: ['bindings'],
            bindings: []
        });
        model.when('bindings', function (bindings) {
            bindings.forEach(function (bindingExpr) {
                var parts = bindingExpr.split('->').map(function (str) {
                        return str.trim();
                    }), source = parts[0].split('.'), sourceAlias = source[0], sourceProperty = source[1], target = parts[1].split('.'), targetAlias = target[0], targetProperty = target[1];
                chiasm.getComponent(sourceAlias).then(function (sourceComponent) {
                    chiasm.getComponent(targetAlias).then(function (targetComponent) {
                        sourceComponent.when(sourceProperty, function (value) {
                            targetComponent[targetProperty] = value;
                        });
                    });
                });
            });
        });
        return model;
    };
});
define('chiasm/src/plugins/scatterPlot', [
    'd3',
    'model',
    'chiasm/src/plugins/reactivis'
], function (d3, Model, reactivis) {
    var None = Model.None;
    var addPublicProperty = reactivis.addPublicProperty;
    return function ScatterPlot(chiasm) {
        var model = Model();
        model.container = chiasm.container;
        reactivis.svg(model);
        reactivis.title(model);
        reactivis.margin(model);
        reactivis.xAccessor(model);
        reactivis.xScale(model, 'linear');
        reactivis.xAxis(model);
        reactivis.yAccessor(model);
        reactivis.yAxis(model);
        reactivis.color(model);
        addPublicProperty(model, 'yDomainMin', None);
        addPublicProperty(model, 'yDomainMax', None);
        model.when([
            'data',
            'yAccessor',
            'yDomainMin',
            'yDomainMax'
        ], function (data, yAccessor, yDomainMin, yDomainMax) {
            if (yDomainMin === None && yDomainMax === None) {
                model.yDomain = d3.extent(data, yAccessor);
            } else {
                if (yDomainMin === None) {
                    yDomainMin = d3.min(data, yAccessor);
                }
                if (yDomainMax === None) {
                    yDomainMax = d3.max(data, yAccessor);
                }
                model.yDomain = [
                    yDomainMin,
                    yDomainMax
                ];
            }
        });
        model.when([
            'yDomain',
            'height'
        ], function (yDomain, height) {
            model.yScale = d3.scale.linear().domain(yDomain).range([
                height,
                0
            ]);
        });
        model.when([
            'yScale',
            'yAccessor'
        ], function (yScale, yAccessor) {
            model.y = function (d) {
                return yScale(yAccessor(d));
            };
        });
        addPublicProperty(model, 'sizeColumn', None);
        addPublicProperty(model, 'sizeDefault', 3);
        addPublicProperty(model, 'sizeMin', 0.5);
        addPublicProperty(model, 'sizeMax', 6);
        model.when([
            'sizeColumn',
            'data',
            'sizeDefault',
            'sizeMin',
            'sizeMax'
        ], function (sizeColumn, data, sizeDefault, sizeMin, sizeMax) {
            if (sizeColumn !== None) {
                var getSize = function (d) {
                        return d[sizeColumn];
                    }, sizeScale = d3.scale.linear().domain(d3.extent(data, getSize)).range([
                        sizeMin,
                        sizeMax
                    ]);
                model.getSizeScaled = function (d) {
                    return sizeScale(getSize(d));
                };
            } else {
                model.getSizeScaled = function (d) {
                    return sizeDefault;
                };
            }
        });
        model.when('g', function (g) {
            model.circlesG = g.append('g');
        });
        model.when([
            'data',
            'circlesG',
            'x',
            'y',
            'getSizeScaled',
            'color'
        ], function (data, circlesG, x, y, getSizeScaled, color) {
            var circles = circlesG.selectAll('circle').data(data);
            circles.enter().append('circle');
            circles.transition().duration(500).attr('cx', x).attr('cy', y).attr('r', getSizeScaled).attr('fill', color);
            circles.exit().remove();
        });
        model.destroy = function () {
            if (model.container && model.svg) {
                model.svg.node().innerHTML = '';
                model.container.removeChild(model.svg.node());
            }
        };
        return model;
    };
});
define('chiasmBundle', [
    'chiasm',
    'chiasm/src/plugins/barChart',
    'chiasm/src/plugins/colorScale',
    'chiasm/src/plugins/computeLayout',
    'chiasm/src/plugins/configEditor',
    'chiasm/src/plugins/crossfilter',
    'chiasm/src/plugins/csvLoader',
    'chiasm/src/plugins/dummyVis',
    'chiasm/src/plugins/layout',
    'chiasm/src/plugins/lineChart',
    'chiasm/src/plugins/links',
    'chiasm/src/plugins/reactivis',
    'chiasm/src/plugins/scatterPlot'
], function (Chiasm) {
    return Chiasm;
});